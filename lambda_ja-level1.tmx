<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE tmx SYSTEM "tmx11.dtd">
<tmx version="1.1">
  <header creationtool="OmegaT" o-tmf="OmegaT TMX" adminlang="EN-US" datatype="plaintext" creationtoolversion="2.6.3_7" segtype="sentence" srclang="EN-US"/>
  <body>
<!-- Default translations -->
    <tu>
      <tuv lang="EN-US">
        <seg>#average()</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032909Z">
        <seg>#average()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#collect(Supplier, BiConsumer, BiConsumer)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032859Z">
        <seg>#collect(Supplier, BiConsumer, BiConsumer)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#doubleStream(java.util.Spliterator.OfDouble, boolean)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032834Z">
        <seg>#doubleStream(java.util.Spliterator.OfDouble, boolean)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#findFirst()</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032900Z">
        <seg>#findFirst()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#flatMap(Function)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032840Z">
        <seg>#flatMap(Function)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#forEach(Consumer)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032842Z">
        <seg>#forEach(Consumer)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#forEach(DoubleConsumer)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032923Z">
        <seg>#forEach(DoubleConsumer)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#forEach(IntConsumer)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032915Z">
        <seg>#forEach(IntConsumer)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#forEach(LongConsumer)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032905Z">
        <seg>#forEach(LongConsumer)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#groupingBy(Function)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T033427Z">
        <seg>#groupingBy(Function)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#groupingBy(Function, Collector)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032347Z">
        <seg>#groupingBy(Function, Collector)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#groupingBy(Function, Supplier, Collector)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032347Z">
        <seg>#groupingBy(Function, Supplier, Collector)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#groupingByConcurrent(Function)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032348Z">
        <seg>#groupingByConcurrent(Function)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#groupingByConcurrent(Function, Collector)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T033427Z">
        <seg>#groupingByConcurrent(Function, Collector)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#groupingByConcurrent(Function, Supplier, Collector)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T034223Z">
        <seg>#groupingByConcurrent(Function, Supplier, Collector)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#intStream(java.util.Spliterator.OfInt, boolean)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032834Z">
        <seg>#intStream(java.util.Spliterator.OfInt, boolean)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#longStream(java.util.Spliterator.OfLong, boolean)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032834Z">
        <seg>#longStream(java.util.Spliterator.OfLong, boolean)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#max()</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032909Z">
        <seg>#max()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#max(Comparator)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032852Z">
        <seg>#max(Comparator)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#min()</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032908Z">
        <seg>#min()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#min(Comparator)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032852Z">
        <seg>#min(Comparator)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#partitioningBy(Predicate)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T040122Z">
        <seg>#partitioningBy(Predicate)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#partitioningBy(Predicate, Collector)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T035915Z">
        <seg>#partitioningBy(Predicate, Collector)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#reduce(BinaryOperator)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032853Z">
        <seg>#reduce(BinaryOperator)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#reduce(Object, BinaryOperator)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032851Z">
        <seg>#reduce(Object, BinaryOperator)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#reduce(double, DoubleBinaryOperator)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032927Z">
        <seg>#reduce(double, DoubleBinaryOperator)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#reduce(int, IntBinaryOperator)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032920Z">
        <seg>#reduce(int, IntBinaryOperator)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#reduce(long, LongBinaryOperator)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032911Z">
        <seg>#reduce(long, LongBinaryOperator)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#reducing(BinaryOperator)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T031648Z">
        <seg>#reducing(BinaryOperator)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#reducing(Object, BinaryOperator)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T031221Z">
        <seg>#reducing(Object, BinaryOperator)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#reducing(Object, Function, BinaryOperator)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T031224Z">
        <seg>#reducing(Object, Function, BinaryOperator)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#stream(java.util.Spliterator, boolean)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032833Z">
        <seg>#stream(java.util.Spliterator, boolean)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#sum()</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032908Z">
        <seg>#sum()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#summarizingDouble(ToDoubleFunction)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T051041Z">
        <seg>#summarizingDouble(ToDoubleFunction)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#summarizingInt(ToIntFunction)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T051059Z">
        <seg>#summarizingInt(ToIntFunction)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#summarizingLong(ToLongFunction)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T051042Z">
        <seg>#summarizingLong(ToLongFunction)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#toConcurrentMap(Function, Function)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T040641Z">
        <seg>#toConcurrentMap(Function, Function)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#toConcurrentMap(Function, Function, BinaryOperator)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T041720Z">
        <seg>#toConcurrentMap(Function, Function, BinaryOperator)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#toConcurrentMap(Function, Function, BinaryOperator, Supplier)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T050305Z">
        <seg>#toConcurrentMap(Function, Function, BinaryOperator, Supplier)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#toMap(Function, Function)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T041719Z">
        <seg>#toMap(Function, Function)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#toMap(Function, Function, BinaryOperator)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T040640Z">
        <seg>#toMap(Function, Function, BinaryOperator)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#toMap(Function, Function, BinaryOperator, Supplier)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T040641Z">
        <seg>#toMap(Function, Function, BinaryOperator, Supplier)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Depending on the specific reduction operation, this may perform better or worse, depending on the relative cost of the accumulator and combiner functions.)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T070612Z">
        <seg>(具体的な簡約処理によっては、これはより性能が良い場合もあれば悪い場合もある。これは累積関数と統合関数の相対的なコストに依存する)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Even if the language had a "parallel for-each" construct, the mutative accumulation approach would still required the developer to provide thread-safe updates to the shared accumulating variable {@code sum}, and the required synchronization would then likely eliminate any performance gain from parallelism.) Using {@code reduce()} instead removes all of the burden of parallelizing the reduction operation, and the library can provide an efficient parallel implementation with no additional synchronization required.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T130547Z">
        <seg>(たとえ言語が「並列for-each」文を備えていたとしても、可変な累積を使う方法では共有累積変数{@code sum}の更新に対するスレッド安全性を開発者が確保する必要があり、そこで必要となる同期は、並列化から得られる効率の向上をほとんど失なわせてしまうだろう)。代わりに{@code reduce()}を使えば簡約処理を並列化する際の一切の面倒を除去でき、ライブラリは余分な同期処理を必要とせずに効率的な並列実装を提供できるようになる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(For example, an unordered collector that accumulated elements to a {@code List} would consider two lists equivalent if they contained the same elements, ignoring order.)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T081833Z">
        <seg>(例えば、要素を{@code List}に累積する、順序を持たないコレクタは、2つのリストが順序を無視して同じ要素を含んでいれば等価であるとして扱うだろう)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(For example, {@link Collection#stream() Collection.stream()} creates a sequential stream, and {@link Collection#parallelStream() Collection.parallelStream()} creates a parallel one.) This choice of execution mode may be modified by the {@link #sequential()} or {@link #parallel()} methods, and may be queried with the {@link #isParallel()} method.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T065029Z">
        <seg>(例えば、{@link Collection#stream() Collection.stream()}は逐次ストリームを作成し、{@link Collection#parallelStream() Collection.parallelStream()}は並列ストリームを作成する)。この実行モードの選択は{@link #sequential()}メソッドや{@link #parallel()}メソッドで変更でき、{@link #isParallel()}メソッドで調べられる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(If a mapped stream is {@code null} an empty stream is used, instead.)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T065716Z">
        <seg>(もし写像されたストリームが{@code null}であれば、代わりに空のストリームが使われる)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(If a stable result is desired, use {@link #findFirst()} instead.)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T083502Z">
        <seg>(もし安定した結果を望むならば、代わりに{@link #findFirst()}を用いよ)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(If a stream does require closing, it can be declared as a resource in a {@code try}-with-resources statement.)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T064636Z">
        <seg>(もしストリームを閉じる必要がある場合、{@code try}-with-resources文の資源として宣言できる)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Summation is an example of a reduction operation.)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T075326Z">
        <seg>(和の計算は簡約(reduction)処理の1例である)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The combiner is necessary in parallel reductions, where the input is partitioned, a partial accumulation computed for each partition, and then the partial results are combined to produce a final result.)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T131655Z">
        <seg>(統合関数は並列簡約において必要である。並列簡約では入力が分割され、部分的な累積結果が各部分に対して計算され、そして最終結果を生成するために中間結果が統合される)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The {@code ?} for the second type parameter merely indicates that we don't care about the intermediate representation used by this collector.) If we wanted to create a collector to tabulate the sum of salaries by department, we could reuse {@code summingSalaries} using {@link java.util.stream.Collectors#groupingBy(java.util.function.Function, java.util.stream.Collector) groupingBy}:</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T014234Z">
        <seg>(第2型変数に対する{@code ?}は、単にコレクタが使う中間表現について気にしないという意味である)。もし部門ごとの給与の合計の表を作るコレクタを作りたいなら、{@link java.util.stream.Collectors#groupingBy(java.util.function.Function, java.util.stream.Collector) groupingBy}を利用して{@code summingSalaries}を再利用できる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(This behavior becomes even more important when the input stream is infinite and not merely large.)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T033529Z">
        <seg>(この挙動は入力のストリームが単に大きいだけでなく、無限である場合にはより重要となる)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(This behavior is also implemented by the predefined collector {@link Collectors#toCollection(Supplier)}).</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T070237Z">
        <seg>この挙動は予め用意されたコレクタ{@link Collectors#toCollection(Supplier)}を使っても実装できる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(This might be true if the result container has no intrinsic order, such as a {@link Set}.)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T074722Z">
        <seg>(これは結果コンテナが{@link Set}など、本質的な順序を持たない場合に当てはまる)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(a op b) op c == a op (b op c)
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032833Z">
        <seg>(a op b) op c == a op (b op c)
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(c, e) -&gt; c.add(e.toString()),</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032817Z">
        <seg>(c, e) -&gt; c.add(e.toString()),</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(c1, c2) -&gt; c1.addAll(c2));
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032819Z">
        <seg>(c1, c2) -&gt; c1.addAll(c2));
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(left, right) -&gt; { left.addAll(right); return left; });
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T070209Z">
        <seg>(left, right) -&gt; { left.addAll(right); return left; });
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(s, a) -&gt; s + ", " + a));
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T041512Z">
        <seg>(s, a) -&gt; s + ", " + a));
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(sum, b) -&gt; sum + b.getWeight())</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032807Z">
        <seg>(sum, b) -&gt; sum + b.getWeight())</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(where {@link java.util.stream.Collectors#groupingByConcurrent} is the concurrent equivalent of {@code groupingBy}).</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T020302Z">
        <seg>(ここで{@link java.util.stream.Collectors#groupingByConcurrent}は{@code groupingBy}の並行版である)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.collect(ArrayList::new, ArrayList::add, ArrayList::addAll);
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032821Z">
        <seg>.collect(ArrayList::new, ArrayList::add, ArrayList::addAll);
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.collect(Collectors.groupingBy(Employee::getDepartment));</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032934Z">
        <seg>.collect(Collectors.groupingBy(Employee::getDepartment));</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.collect(Collectors.groupingBy(Employee::getDepartment,</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032934Z">
        <seg>.collect(Collectors.groupingBy(Employee::getDepartment,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.collect(Collectors.groupingBy(Transaction::getBuyer));
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032830Z">
        <seg>.collect(Collectors.groupingBy(Transaction::getBuyer));
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.collect(Collectors.joining(", "));</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032931Z">
        <seg>.collect(Collectors.joining(", "));</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.collect(Collectors.partitioningBy(s -&gt; s.getGrade() &gt;= PASS_THRESHOLD));

}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032936Z">
        <seg>.collect(Collectors.partitioningBy(s -&gt; s.getGrade() &gt;= PASS_THRESHOLD));

}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.collect(Collectors.summingInt(Employee::getSalary)));</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032932Z">
        <seg>.collect(Collectors.summingInt(Employee::getSalary)));</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.collect(Collectors.toList());
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032821Z">
        <seg>.collect(Collectors.toList());
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.collect(Collectors.toList());  // No side-effects!</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T090753Z">
        <seg>.collect(Collectors.toList());  // 副作用無し!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.collect(groupingByConcurrent(Transaction::getBuyer));
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032832Z">
        <seg>.collect(groupingByConcurrent(Transaction::getBuyer));
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.filter(b -&gt; b.getColor() == RED)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032735Z">
        <seg>.filter(b -&gt; b.getColor() == RED)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.filter(e -&gt; e &gt; 2)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032905Z">
        <seg>.filter(e -&gt; e &gt; 2)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.filter(e -&gt; e.length() &gt; 3)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032841Z">
        <seg>.filter(e -&gt; e.length() &gt; 3)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.filter(p -&gt; p.getGender() == MALE)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032843Z">
        <seg>.filter(p -&gt; p.getGender() == MALE)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.filter(w -&gt; w.getColor() == RED)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032835Z">
        <seg>.filter(w -&gt; w.getColor() == RED)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.forEach(s -&gt; results.add(s));  // Unnecessary use of side-effects!</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032748Z">
        <seg>.forEach(s -&gt; results.add(s));  // Unnecessary use of side-effects!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.map(Object::toString)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032931Z">
        <seg>.map(Object::toString)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.map(String::toUpperCase)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032841Z">
        <seg>.map(String::toUpperCase)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.map(e -&gt; e * e)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032905Z">
        <seg>.map(e -&gt; e * e)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.mapToDouble(w -&gt; w.getWeight())</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032923Z">
        <seg>.mapToDouble(w -&gt; w.getWeight())</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.mapToInt(Widget::getWeight)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032802Z">
        <seg>.mapToInt(Widget::getWeight)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.mapToInt(b -&gt; b.getWeight())</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032735Z">
        <seg>.mapToInt(b -&gt; b.getWeight())</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.mapToInt(w -&gt; w.getWeight())</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032835Z">
        <seg>.mapToInt(w -&gt; w.getWeight())</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.mapToLong(w -&gt; w.getWeight())</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032903Z">
        <seg>.mapToLong(w -&gt; w.getWeight())</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.max();
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032802Z">
        <seg>.max();
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.peek(e -&gt; System.out.println("Filtered value: " + e))</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T072240Z">
        <seg>.peek(e -&gt; System.out.println("絞り込まれた値: " + e))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.peek(e -&gt; System.out.println("Mapped value: " + e))</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T072407Z">
        <seg>.peek(e -&gt; System.out.println("写像された値: " + e))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.reduce(0,</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032807Z">
        <seg>.reduce(0,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.sum();
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032736Z">
        <seg>.sum();
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.toArray(Person[]::new);
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032843Z">
        <seg>.toArray(Person[]::new);
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.toString();
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032856Z">
        <seg>.toString();
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.unordered()</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032832Z">
        <seg>.unordered()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Accumulate names into a List</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140213T121157Z">
        <seg>// 名前をListに累積する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Accumulate names into a TreeSet</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140213T121209Z">
        <seg>// 名前をTreeSetに累積する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Compute sum of salaries by department</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140213T121327Z">
        <seg>// 部署ごとに給与の合計を求める</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Compute sum of salaries of employee</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140213T121255Z">
        <seg>// 従業員の給与の和を求める</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Convert elements to strings and concatenate them, separated by commas</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140213T121229Z">
        <seg>// 要素を文字列に変換し、カンマで区切って連結する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Group employees by department</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140213T121303Z">
        <seg>// 部署ごとに従業員をグループ化する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Partition students into passing and failing</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140213T121349Z">
        <seg>// 学生を合格者と不合格者に分ける</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1.8</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032833Z">
        <seg>1.8</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>= Collectors.groupingBy(Employee::getDepartment, summingSalaries);
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T072056Z">
        <seg>= Collectors.groupingBy(Employee::getDepartment, summingSalaries);
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>= Collectors.summingInt(Employee::getSalary))
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T071914Z">
        <seg>= Collectors.summingInt(Employee::getSalary))
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>= Collectors.summingInt(Employee::getSalary);
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032823Z">
        <seg>= Collectors.summingInt(Employee::getSalary);
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>= employees.stream()</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032933Z">
        <seg>= employees.stream()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>= employees.stream().collect(Collectors.groupingBy(Employee::getDepartment,</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032824Z">
        <seg>= employees.stream().collect(Collectors.groupingBy(Employee::getDepartment,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>= people.stream().collect(collectingAndThen(toList(), Collections::unmodifiableList));
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032938Z">
        <seg>= people.stream().collect(collectingAndThen(toList(), Collections::unmodifiableList));
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>= people.stream().collect(groupingBy(Person::getCity,</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T031506Z">
        <seg>= people.stream().collect(groupingBy(Person::getCity,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>= people.stream().collect(groupingBy(Person::getCity, ConcurrentSkipListMap::new,</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T035801Z">
        <seg>= people.stream().collect(groupingBy(Person::getCity, ConcurrentSkipListMap::new,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>= people.stream().collect(groupingBy(Person::getCity, TreeMap::new,</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T033552Z">
        <seg>= people.stream().collect(groupingBy(Person::getCity, TreeMap::new,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>= people.stream().collect(groupingBy(Person::getCity, reducing(BinaryOperator.maxBy(byHeight))));
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T031111Z">
        <seg>= people.stream().collect(groupingBy(Person::getCity, reducing(BinaryOperator.maxBy(byHeight))));
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>= people.stream().collect(groupingByConcurrent(Person::getCity,</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T035717Z">
        <seg>= people.stream().collect(groupingByConcurrent(Person::getCity,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>= personStream.collect(Collectors.groupingBy(Person::getCity));
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032857Z">
        <seg>= personStream.collect(Collectors.groupingBy(Person::getCity));
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>= personStream.collect(Collectors.groupingBy(Person::getState,</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032858Z">
        <seg>= personStream.collect(Collectors.groupingBy(Person::getState,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>= txns.parallelStream()</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032830Z">
        <seg>= txns.parallelStream()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A mutable reduction operation that accumulates input elements into a mutable result container, optionally transforming the accumulated result into a final representation after all input elements have been processed.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T051500Z">
        <seg>入力要素を可変な結果コンテナに累積し、さらに追加可能な処理として、全ての入力要素が処理された後に累積した結果を最終形に変換する可変的簡約処理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A mutable reduction operation accumulates input elements into a mutable result container, such as a {@code Collection} or {@code StringBuilder}, as it processes the elements in the stream.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T011406Z">
        <seg>可変的簡約処理(mutable reduction operation)は入力要素を処理しながら{@code Collection}や{@code StringBuilder}などの可変な結果コンテナに累積していく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A reduction operation (also called a fold) takes a sequence of input elements and combines them into a single summary result by repeated application of a combining operation, such as finding the sum or maximum of a set of numbers, or accumulating elements into a list.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T100928Z">
        <seg>簡約(reduction)処理(折り畳み(fold)とも呼ばれる)は入力要素の列を受け取り、統合処理を繰り返し適用して1つの要約値に統合する。例えば数値の集合の和や最大値を求めたり、要素を1つのリストに累積する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A a1 = supplier.get();</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032825Z">
        <seg>A a1 = supplier.get();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A a2 = supplier.get();</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032827Z">
        <seg>A a2 = supplier.get();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A a3 = supplier.get();</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032827Z">
        <seg>A a3 = supplier.get();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A behavioral parameter is said to interfere with a non-concurrent data source if it modifies, or causes to be modified, the stream's data source.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T044038Z">
        <seg>挙動パラメータはストリームの並行でない情報源を変更したり変更させたりするとき、情報源に干渉する(interfere)という</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A concurrent reduction is one where the accumulator function is called concurrently from multiple threads, using the same concurrently-modifiable result container, rather than keeping the result isolated during accumulation.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T065925Z">
        <seg>並行的な簡約とは、累積中に結果を隔離するのではなく、並列に変更可能な同じ結果コンテナを使って累積関数が複数のスレッドから並行的に呼ばれる簡約である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A concurrent reduction should only be applied if the collector has the {@link Characteristics#UNORDERED} characteristics or if the originating data is unordered.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T070018Z">
        <seg>並行的簡約はコレクタが{@link Characteristics#UNORDERED}特性を持つか、元のデータが順序を持たないときにのみ適用されるべきである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A function that accepts two partial results and merges them.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T072556Z">
        <seg>部分的な結果を2つ取ってそれらを併合する関数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A function that creates and returns a new mutable result container.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T072408Z">
        <seg>新しい可変な結果コンテナを作成して返す関数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A function that folds a value into a mutable result container.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T072501Z">
        <seg>値を可変な結果コンテナに折り畳む関数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A higher-quality spliterator will provide balanced and known-size splits, accurate sizing information, and a number of other {@link java.util.Spliterator#characteristics() characteristics} of the spliterator or data that can be used by implementations to optimize execution.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T025635Z">
        <seg>より高品質のスプリッテレータは均等でサイズが既知となるような分割処理を備え、大きさに関する情報を累積し、スプリッテレータやデータに関する他のいくつもの{@link java.util.Spliterator#characteristics() 特性}を備えて実装が実行を最適化するのに使えるようにするだろう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A more performant approach would be to accumulate the results into a {@link java.lang.StringBuilder}, which is a mutable container for accumulating strings.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T011600Z">
        <seg>より性能面で良い方法は、{@link java.lang.StringBuilder}という、文字列を累積していく可変的コンテナに結果を累積していく方法だろう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A mutable builder for a {@code DoubleStream}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T095418Z">
        <seg>{@code DoubleStream}の可変なビルダ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A mutable builder for a {@code LongStream}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T092041Z">
        <seg>{@code LongStream}の可変なビルダ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A mutable builder for a {@code Stream}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T084626Z">
        <seg>{@code Stream}の可変なビルダ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A mutable builder for an {@code IntStream}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T093039Z">
        <seg>{@code IntStream}の可変なビルダ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A mutable reduction is one in which the reduced value is a mutable result container, such as an {@code ArrayList}, and elements are incorporated by updating the state of the result rather than by replacing the result.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T075821Z">
        <seg>可変的簡約は、簡約した値が{@code ArrayList}などの可変な結果コンテナであるものであり、結果を置き換えるのではなく結果の状態を変更して各要素を組み入れるような簡約である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A new sequential {@code IntStream}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T092912Z">
        <seg>新しい逐次的な{@code IntStream}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A parallel implementation would partition the input, create a result container for each partition, accumulate the contents of each partition into a subresult for that partition, and then use the combiner function to merge the subresults into a combined result.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T053018Z">
        <seg>並列実装は入力を分割し、各部分ごとに結果コンテナを作成し、各部分の要素を中間結果に対して累積し、統合関数を使って中間結果を併合して統合結果を得るだろう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A sequence of elements supporting sequential and parallel aggregate operations.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T042320Z">
        <seg>逐次集計処理および並列集計処理を備える要素の列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A sequence of primitive double-valued elements supporting sequential and parallel aggregate operations.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T093115Z">
        <seg>プリミティブのdoubleである要素の列であり、逐次集計処理および並列集計処理を備える。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A sequence of primitive int-valued elements supporting sequential and parallel aggregate operations.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T092118Z">
        <seg>プリミティブのintである要素の列であり、逐次集計処理および並列集計処理を備える。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A sequence of primitive long-valued elements supporting sequential and parallel aggregate operations.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T085415Z">
        <seg>プリミティブのlongである要素の列であり、逐次集計処理および並列集計処理を備える。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A sequential implementation of a reduction using a collector would create a single result container using the supplier function, and invoke the accumulator function once for each input element.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T053028Z">
        <seg>コレクタを使った簡約の逐次的な実装は供給関数を使って1つの結果コンテナのみを生成し、各入力要素に対して1回ずつ累積関数を呼びだすだろう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A small number of stream operations, such as {@code forEach()} and {@code peek()}, can operate only via side-effects; these should be used with care.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T085339Z">
        <seg>{@code forEach()}や{@code peek()}といった少数のストリーム処理は副作用のみを処理できる。それらは注意して使う必要がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A spliterator is the parallel analogue of an {@link java.util.Iterator}; it describes a (possibly infinite) collection of elements, with support for sequentially advancing, bulk traversal, and splitting off some portion of the input into another spliterator which can be processed in parallel.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T024512Z">
        <seg>スプリッテレータは要素の(無限かもしれない)コレクションを表現する。そして逐次的に進めていく・まとめて走査する・並列に処理できる他のスプリッテレータに入力の一部を分割するといった処理を備える。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A stateful lambda (or other object implementing the appropriate functional interface) is one whose result depends on any state which might change during the execution of the stream pipeline.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T075825Z">
        <seg>状態を持つラムダ(または他の適切な関数的インターフェースを実装したオブジェクト)とは、ストリームパイプラインの実行中に変化する可能性がある何らかの状態に結果が依存するものである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A stream builder has a lifecycle, which starts in a building phase, during which elements can be added, and then transitions to a built phase, after which elements may not be added.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T084929Z">
        <seg>{@code StreamBuilder}はライフサイクルを持ち、要素を追加できる構築中段階から始まり、要素を追加できなくなる構築済段階に移行する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A stream implementation may throw {@link IllegalStateException} if it detects that the stream is being reused.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T064213Z">
        <seg>ストリームの実装はストリームが再利用されているのを検知した場合、{@link IllegalStateException}を投げる場合がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A stream is not a data structure that stores elements; instead, it conveys elements from a source such as a data structure, an array, a generator function, or an I/O channel, through a pipeline of computational operations.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T024132Z">
        <seg>ストリームは要素を保持するデータ構造ではない。その代わりにデータ源(データ構造・ジェネレータ関数・IOチャネルなど)から計算処理のパイプラインを通して値をもたらす。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A stream pipeline consists of a source (such as a {@code Collection}, an array, a generator function, or an I/O channel); followed by zero or more intermediate operations such as {@code Stream.filter} or {@code Stream.map}; and a terminal operation such as {@code Stream.forEach} or {@code Stream.reduce}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T031155Z">
        <seg>ストリームパイプラインは複数の構成要素からなり、データ源(source, {@code Collection}・配列・ジェネレータ関数・IOチャネルなど)の後に{@code Stream.filter}や{@code Stream.map}といった零個以上の中間処理と{@code Stream.forEach}や{@code Stream.reduce}といった末端処理が続く。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A stream pipeline consists of a source (which might be an array, a collection, a generator function, an I/O channel, etc), zero or more intermediate operations (which transform a stream into another stream, such as {@link Stream#filter(Predicate)}), and a terminal operation (which produces a result or side-effect, such as {@link Stream#count()} or {@link Stream#forEach(Consumer)}).</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T043434Z">
        <seg>ストリームパイプラインは情報源(source、配列・コレクション・生成関数・I/Oチャンネルなど)、零個以上の中間処理(intermediate operations)({@link Stream#filter(Predicate)}のようにストリームを別のストリームに変換する)、末端処理(terminal operation)({@link Stream#count()}や{@link Stream#forEach(Consumer)}のように結果や副作用を生成する)からなる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A stream pipeline, like the "widgets" example above, can be viewed as a query on the stream source.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T044643Z">
        <seg>上記の「ウィジェット」の例のようなストリームパイプラインはストリーム源に対する問い合わせとして見ることもできる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A stream should be operated on (invoking an intermediate or terminal stream operation) only once.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T063859Z">
        <seg>ストリームは一度だけ利用する(中間処理や末端処理を呼び出す)べきである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A task to execute when the stream is closed</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T080608Z">
        <seg>ストリームが閉じられた場合に実行される作業</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A terminal operation is short-circuiting if, when presented with infinite input, it may terminate in finite time.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T034637Z">
        <seg>末端処理は、無限の入力を与えられた際に有限の時間で終了する場合があるならば短絡的である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A {@code Collector} encapsulates the functions used as arguments to {@link #collect(Supplier, BiConsumer, BiConsumer)}, allowing for reuse of collection strategies and composition of collect operations such as multiple-level grouping or partitioning.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T080715Z">
        <seg>{@code Collector}は{@link #collect(Supplier, BiConsumer, BiConsumer)}の引数として使われる関数をカプセル化し、収集戦略の再利用を可能にすると共に、複数レベルのグループ化や組分けなどといった風に収集処理の合成を可能にする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A {@code Collector} is specified by four functions that work together to accumulate entries into a mutable result container, and optionally perform a final transform on the result.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T052323Z">
        <seg>{@code Collector}は要素を結果コンテナに協調して累積し、追加可能な処理として結果に対して最終的な変換をする4つの関数によって記述される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A {@code Collector} which concatenates CharSequence elements, separated by the specified delimiter, in encounter order</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140213T122437Z">
        <seg>CharSequenceである要素を出現順に指定された文字列で区切って連結する{@code Collector}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A {@code Spliterator.OfDouble} describing the stream elements</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T041924Z">
        <seg>ストリーム要素を表す{@code Spliterator.OfDouble}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A {@code Supplier} of a {@code Spliterator.OfDouble}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T042029Z">
        <seg>{@code Spliterator.OfDouble}の{@code Supplier}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A {@code collect} operation requires three functions: a supplier function to construct new instances of the result container, an accumulator function to incorporate an input element into a result container, and a combining function to merge the contents of one result container into another.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T065535Z">
        <seg>{@code collect}処理は3つの関数を必要とする。新しい結果コンテナを構築する供給関数(supplier function)・結果コンテナに入力要素を取り入れる累積関数(accumulator function)・ある結果コンテナの中身を別のコンテナに併合する統合関数(combining function)である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A {@link java.util.stream.Collector} that supports concurrent reduction is marked with the {@link java.util.stream.Collector.Characteristics#CONCURRENT} characteristic.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T015736Z">
        <seg>並行簡約をサポートする{@link java.util.stream.Collector}は{@link java.util.stream.Collector.Characteristics#CONCURRENT}特性の印が付けられている。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Accessing an element of a deeply concatenated stream can result in deep call chains, or even {@code StackOverflowException}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T084507Z">
        <seg>深く連結されたストリームの要素にアクセスする際には、深い呼び出し連鎖が起きる場合があり、場合によっては{@code StackOverflowException}も起きる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Accordingly, behavioral parameters in stream pipelines whose source might not be concurrent should never modify the stream's data source.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T043726Z">
        <seg>したがって、情報源が並行的でない可能性があるストリームパイプラインの挙動パラメターはストリームの情報源を決して変更するべきではない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Adapts a {@code Collector} accepting elements of type {@code U} to one accepting elements of type {@code T} by applying a mapping function to each input element before accumulation.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T022419Z">
        <seg>{@code Collector}の各入力要素に対して累積前に写像関数を適用して、{@code U}型を受けとる{@code Collector}を{@code T}型を受けとる{@code Collector}へと適合させる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Adapts a {@code Collector} to perform an additional finishing transformation.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T022824Z">
        <seg>{@code Collector}に対して追加の仕上げ処理をするように適合させる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additional stream sources can be provided by third-party libraries using these techniques.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T030645Z">
        <seg>その他にもストリームの情報源がサードパーティのライブラリからこれらの手法を使って用意されるだろう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additionally, the {@code combiner} function must be associative and must be compatible with the {@code accumulator} function: for all {@code u} and {@code t}, {@code combiner.apply(u, accumulator.apply(identity, t))} must be {@code equals()} to {@code accumulator.apply(u, t)}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T010623Z">
        <seg>加えて、{@code combiner}関数は結合的であり、{@code accumulator}関数と適合する必要がある。つまり任意の{@code u}と{@code t}について{@code combiner.apply(u, accumulator.apply(identity, t))}は{@code accumulator.apply(u, t)}に対して{@code equals()}の意味で等しい必要がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additionally, the {@code combiner} function must be compatible with the {@code accumulator} function; for all {@code u} and {@code t}, the following must hold:</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T075420Z">
        <seg>加えて、{@code combiner}関数は{@code accumulator}関数と適合する必要がある。つまり任意の{@code u}と{@code t}について次の式が成り立つ必要がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Adds an element to the stream being built.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T085034Z">
        <seg>構築中のストリームに要素を追加する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After the terminal operation is performed, the stream pipeline is considered consumed, and can no longer be used; if you need to traverse the same data source again, you must return to the data source to get a new stream.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T031810Z">
        <seg>末端処理を実行した後はそのストリームは消費されたものとみなされ、その後は利用できなくなる。もし同じ情報源を再び走査したい場合は、元のデータ源から新しいストリームを得る必要がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All close handlers are run, even if earlier close handlers throw exceptions.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T080228Z">
        <seg>ストリームを閉じるハンドラは先行するハンドラが例外を投げたとしても全て実行される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All streams operations can execute either in serial or in parallel.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T040156Z">
        <seg>全てのストリーム処理は逐次的にも並列にも実行できる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All the streams returned from JDK collections, and most other JDK classes, are well-behaved in this manner; for streams generated by other libraries, see Low-level stream construction for requirements for building well-behaved streams.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T075122Z">
        <seg>JDKの全てのコレクションや他のほとんどのJDKクラスから返されるストリームはこの意味で行儀が良い。他のライブラリから生成されるストリームに関して、行儀が良いストリームを構築するための必要条件については低水準ストリーム構築を参照せよ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An equivalent sequence of increasing values can be produced sequentially using a {@code for} loop as follows:</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T091839Z">
        <seg>増加する値の同等な列は{@code for}ループを使って次のように逐次的に生成できる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An example of a stateful lambda is the parameter to {@code map()} in:</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T075917Z">
        <seg>状態を持つラムダの例は次のコードの中での{@code map()}へのパラメータである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An intermediate operation is short-circuiting if, when presented with infinite input, it may produce a finite stream as a result.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T034622Z">
        <seg>中間処理は、無限の入力を与えられた際に有限のストリームを結果として生成する場合があるならば短絡的である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An operation on a stream produces a result, but does not modify its source.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T024147Z">
        <seg>ストリームに対する処理は成果物を生成するが、元となるデータ源を変更しない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An operator or function {@code op} is associative if the following holds:</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T020926Z">
        <seg>演算子または関数{@code op}は次の条件を満たすとき結合的である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An {@code IllegalStateException} is thrown if there are further attempts to operate on the builder after it has entered the built state.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T085222Z">
        <seg>このビルダに対してさらなる処理をしようとすると{@code IllegalStateException}が投げられる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And the following produces a {@code Map} mapping a unique identifier to students:</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T040342Z">
        <seg>そして次のコードは一意的な識別子から生徒に写像する{@code Map}を生成する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ArrayList::addAll);
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032855Z">
        <seg>ArrayList::addAll);
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ArrayList&lt;String&gt; results = new ArrayList&lt;&gt;();</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032747Z">
        <seg>ArrayList&lt;String&gt; results = new ArrayList&lt;&gt;();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ArrayList&lt;String&gt; strings = new ArrayList&lt;&gt;();</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032814Z">
        <seg>ArrayList&lt;String&gt; strings = new ArrayList&lt;&gt;();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ArrayList&lt;String&gt; strings = stream.collect(() -&gt; new ArrayList&lt;&gt;(),</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032817Z">
        <seg>ArrayList&lt;String&gt; strings = stream.collect(() -&gt; new ArrayList&lt;&gt;(),</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a result, under parallel computation, some pipelines containing stateful intermediate operations may require multiple passes on the data or may need to buffer significant data.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T034428Z">
        <seg>結果として、並列計算において、状態を持つ中間処理を含むパイプラインは複数のパスで実行される必要がある場合がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As an example of how to transform a stream pipeline that inappropriately uses side-effects to one that does not, the following code searches a stream of strings for those matching a given regular expression, and puts the matches in a list.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T085507Z">
        <seg>不適切に副作用を使うストリームパイプラインを使わないものに変換する方法の例として、次のコードは文字列のストリームから与えられた正規表現に適合する文字列を探して適合結果をリストに保存する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with the regular reduction operation, {@code collect()} operations can only be parallelized if appropriate conditions are met.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T014627Z">
        <seg>通常の簡約処理と同じように{@code collect()}処理も適切な条件を満たしたときのみ並列化できる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with {@code reduce()}, a benefit of expressing {@code collect} in this abstract way is that it is directly amenable to parallelization: we can accumulate partial results in parallel and then combine them, so long as the accumulation and combining functions satisfy the appropriate requirements.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T012238Z">
        <seg>{@code reduce()}と同様に{@code collect}をこのような抽象的な形で表す利点は、並列化を直ちに適用できる点である。つまり累積関数と統合関数が要件を満たす限り、中間結果を並列に累積し、その後統合するようにできる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Associativity</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T020910Z">
        <seg>結合性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At the lowest level, all streams are driven by a spliterator.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T024639Z">
        <seg>最も下の水準では、全てのストリームはスプリッテレータを使って駆動する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>AutoCloseable#close()</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T080727Z">
        <seg>AutoCloseable#close()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Base interface for streams, which are sequences of elements supporting sequential and parallel aggregate operations.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T075020Z">
        <seg>ストリームの基礎となるインターフェース。逐次集計処理および並列集計処理を備える要素の列である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>BiConsumer&lt;R, ?</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032811Z">
        <seg>BiConsumer&lt;R, ?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>BiConsumer&lt;R, R&gt; combiner);
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032812Z">
        <seg>BiConsumer&lt;R, R&gt; combiner);
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>BiFunction&lt;U, ?</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032804Z">
        <seg>BiFunction&lt;U, ?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>BinaryOperator&lt;U&gt; combiner);
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032805Z">
        <seg>BinaryOperator&lt;U&gt; combiner);
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Builds the stream, transitioning this builder to the built state.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T085212Z">
        <seg>ストリームを構築し、このビルダを構築済状態に移行させる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By contrast, streams do not provide a means to directly access or manipulate their elements, and are instead concerned with declaratively describing their source and the computational operations which will be performed in aggregate on that source.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T044250Z">
        <seg>対照的に、ストリームは要素へ直接アクセスする手段や要素を直接操作する手段を備えておらず、代わりに情報源と、情報源に対してまとめて実行される計算処理を宣言的に示すことに注意を注ぐ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calling this method after invoking an terminal stream operation method may yield unpredictable results.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T075626Z">
        <seg>末端ストリーム処理を起動した後にこのメソッドを呼ぶと予測できない結果を得る場合がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Certain aggregate operations, such as filtering duplicates ( {@code distinct()}) or grouped reductions ( {@code Collectors.groupingBy()}) can be implemented more efficiently if ordering of elements is not relevant.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T095759Z">
        <seg>重複の除去({@code distinct()})やグループ化({@code Collectors.groupingBy()})などのある種の集約処理は要素の順序が重要でなければより効率的に実装できる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Certain stream sources (such as {@code List} or arrays) are intrinsically ordered, whereas others (such as {@code HashSet}) are not.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T091103Z">
        <seg>ある種のストリーム源({@code List}や配列など)は本質的に順序付けられている(ordered)が、他のもの({@code HashSet}など)はそうでない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Characteristics indicating properties of a {@code Collector}, which can be used to optimize reduction implementations.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T074214Z">
        <seg>簡約処理の実装の最適化に利用できる、{@code Collector}の性質を表す特性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Classes to support functional-style operations on streams of elements, such as map-reduce transformations on collections.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T023233Z">
        <seg>コレクションに対する写像(map)・簡約(reduce)変換といった、関数型の操作を要素のストリームに対して提供するクラス群。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Close handlers are run when the {@link #close()} method is called on the stream, and are executed in the order they were added.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T080156Z">
        <seg>ストリームを閉じるハンドラはストリームの{@link #close()}メソッドが呼ばれた差異に呼ばれ、追加された順序で実行される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Closes this stream, causing all close handlers for this stream pipeline to be called.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T080726Z">
        <seg>このストリームを閉じ、ストリームパイプラインを閉じる全てのハンドラが呼ばれるようにする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Collections and streams, while bearing some superficial similarities, have different goals.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T043643Z">
        <seg>コレクションとストリームは表面上の類似点はあるものの、異なる目的を持つ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Collections are primarily concerned with the efficient management of, and access to, their elements.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T043752Z">
        <seg>コレクションはその要素の効率的な管理とその要素への効率的なアクセスに主に注意を注ぐ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Collector.of(TreeSet::new, TreeSet::add,</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T070208Z">
        <seg>Collector.of(TreeSet::new, TreeSet::add,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Collector&lt;Employee, ?, Integer&gt; summingSalaries</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032822Z">
        <seg>Collector&lt;Employee, ?, Integer&gt; summingSalaries</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Collector&lt;Employee, ?, Map&lt;Department, Integer&gt;&gt; summingSalariesByDept</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T072056Z">
        <seg>Collector&lt;Employee, ?, Map&lt;Department, Integer&gt;&gt; summingSalariesByDept</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Collector&lt;Widget, ?, TreeSet&lt;Widget&gt;&gt; intoSet =</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T070208Z">
        <seg>Collector&lt;Widget, ?, TreeSet&lt;Widget&gt;&gt; intoSet =</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Collectors</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032859Z">
        <seg>Collectors</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Collectors also have a set of characteristics, such as {@link Characteristics#CONCURRENT}, that provide hints that can be used by a reduction implementation to provide better performance.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T052657Z">
        <seg>Collectorは{@link Characteristics#CONCURRENT}といった特性の集合を備える。これらの特性は簡約の実装がより良い性能を出すためのヒントとして扱われる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Collectors are designed to be composed; many of the methods in {@link Collectors} are functions that take a collector and produce a new collector.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T070717Z">
        <seg>コレクタは合成できるように設計してある。{@link Collectors}にある多くのメソッドはコレクタを受け取り新しいコレクタを作る関数である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Collectors.groupingBy(Person::getCity)));
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032858Z">
        <seg>Collectors.groupingBy(Person::getCity)));
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Collectors.summingInt(Employee::getSalary)));</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032935Z">
        <seg>Collectors.summingInt(Employee::getSalary)));</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Comparator&lt;Person&gt; byHeight = Comparator.comparing(Person::getHeight);</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T031112Z">
        <seg>Comparator&lt;Person&gt; byHeight = Comparator.comparing(Person::getHeight);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Comparator&lt;String&gt; byLength = Comparator.comparing(String::length);</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T031502Z">
        <seg>Comparator&lt;String&gt; byLength = Comparator.comparing(String::length);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Concurrent stream sources are those whose {@code Spliterator} reports the {@code CONCURRENT} characteristic.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T043535Z">
        <seg>並行ストリーム源とはその{@code Spliterator}が{@code CONCURRENT}特性を示すものである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ConcurrentMap&lt;City, Set&lt;String&gt;&gt; namesByCity</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T035716Z">
        <seg>ConcurrentMap&lt;City, Set&lt;String&gt;&gt; namesByCity</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consequently, a concurrent reduction is only possible if ordering is not important for the stream being processed.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T020045Z">
        <seg>その結果、並行簡約は処理しているストリームに対して順序が重要でない場合のみ可能となる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consumable.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T024841Z">
        <seg>消費できる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Creates a lazily concatenated stream whose elements are all the elements of the first stream followed by all the elements of the second stream.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T084104Z">
        <seg>ストリームの要素が、最初のストリームの全ての要素の後に2つ目のストリームの全ての要素を並べたような、遅延的に連結されたストリームを返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Creates a new sequential or parallel {@code DoubleStream} from a {@code Spliterator.OfDouble}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T041909Z">
        <seg>{@code Spliterator.OfDouble}から新しい逐次あるいは並列{@code DoubleStream}を作成する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Creates a new sequential or parallel {@code DoubleStream} from a {@code Supplier} of {@code Spliterator.OfDouble}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T041943Z">
        <seg>{@code Spliterator.OfDouble}の{@code Supplier}から新しい逐次あるいは並列{@code DoubleStream}を作成する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Creates a new sequential or parallel {@code IntStream} from a {@code Spliterator.OfInt}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T041304Z">
        <seg>{@code Spliterator.OfInt}から新しい逐次あるいは並列{@code IntStream}を作成する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Creates a new sequential or parallel {@code IntStream} from a {@code Supplier} of {@code Spliterator.OfInt}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T041402Z">
        <seg>{@code Spliterator.OfInt}の{@code Supplier}から新しい逐次あるいは並列{@code IntStream}を作成する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Creates a new sequential or parallel {@code LongStream} from a {@code Spliterator.OfLong}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T041533Z">
        <seg>{@code Spliterator.OfLong}から新しい逐次あるいは並列{@code LongStream}を作成する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Creates a new sequential or parallel {@code LongStream} from a {@code Supplier} of {@code Spliterator.OfLong}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T041649Z">
        <seg>{@code Spliterator.OfLong}の{@code Supplier}から新しい逐次あるいは並列{@code LongStream}を作成する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Creates a new sequential or parallel {@code Stream} from a {@code Spliterator}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T032136Z">
        <seg>{@code Spliterator}から新しい逐次あるいは並列{@code Stream}を作成する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Creates a new sequential or parallel {@code Stream} from a {@code Supplier} of {@code Spliterator}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T040135Z">
        <seg>{@code Spliterator}の{@code Supplier}から新しい逐次あるいは並列{@code Stream}を作成する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Documents</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032728Z">
        <seg>Documents</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DoubleStream</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032836Z">
        <seg>DoubleStream</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DoubleStream#builder()</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032929Z">
        <seg>DoubleStream#builder()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DoubleStream.of(1, 2, 3, 4)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032923Z">
        <seg>DoubleStream.of(1, 2, 3, 4)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each mapped stream is {@link java.util.stream.BaseStream#close() closed} after its contents have been placed into this stream.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T065636Z">
        <seg>写像された各ストリームは、その内容がこのストリームに配置された後で{@link java.util.stream.BaseStream#close() 閉じられる}。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each mapped stream is {@link java.util.stream.BaseStream#close() closed} after its contents have placed been into this stream.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T070507Z">
        <seg>写像された各ストリームは、その内容がこのストリームに配置された後で{@link java.util.stream.BaseStream#close() 閉じられる}。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Either the stream is unordered, or the collector has the {@link java.util.stream.Collector.Characteristics#UNORDERED} characteristic.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T020150Z">
        <seg>ストリームが順序を持たない、またはコレクタが{@link java.util.stream.Collector.Characteristics#UNORDERED}特性を持つ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Elements sorted by increasing absolute magnitude tend to yield more accurate results.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T094234Z">
        <seg>要素を絶対値の増加順にソートするとより正確な結果が出る傾向にある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even when a pipeline is constrained to produce a result that is consistent with the encounter order of the stream source (for example, {@code IntStream.range(0,5).parallel().map(x -&gt; x*2).toArray()} must produce {@code [0, 2, 4, 6, 8]}), no guarantees are made as to the order in which the mapper function is applied to individual elements, or in what thread any behavioral parameter is executed for a given element.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T091359Z">
        <seg>パイプラインがストリーム源に対する出現順(encounter order)に対して変わらない結果を生成するように制約されていたとしても(例えば{@code IntStream.range(0,5).parallel().map(x -&gt; x*2).toArray()}は{@code [0, 2, 4, 6, 8]}を生成する必要がある)、各要素に対して写像関数が適用される順番に対する保障は成されないし、与えられた要素に対して挙動パラメータが実行されるスレッドの保障も無い。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Examples of associative operations include numeric addition, min, and max, and string concatenation.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T021137Z">
        <seg>結合的な演算の例として、数値の加算・min・max・文字列の連結などがある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Examples of mutable reduction operations include: accumulating elements into a {@code Collection}; concatenating strings using a {@code StringBuilder}; computing summary information about elements such as sum, min, max, or average; computing "pivot table" summaries such as "maximum valued transaction by seller", etc.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T052035Z">
        <seg>可変的簡約処理には、要素の{@code Collection}への累積・文字列の{@code StringBuilder}を使った連結・要素に関する和や最小値や最大値や平均などの要約情報の計算・「販売者ごとの最も売り上げが大きい取引」などの「ピボットテーブル」の計算などを含む。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Examples.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T070053Z">
        <seg>例:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Except for operations identified as explicitly nondeterministic, such as {@code findAny()}, whether a stream executes sequentially or in parallel should not change the result of the computation.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T041114Z">
        <seg>{@code findAny()}のように明示的に非決定的とされない限り、ストリームは逐次的に実行されても並列に実行されても計算結果を変えないはずである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Except for the escape-hatch operations {@code iterator()} and {@code spliterator()}, execution begins when the terminal operation is invoked, and ends when the terminal operation completes.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T042910Z">
        <seg>逃げ道である{@code iterator()}処理および{@code spliterator()}処理を除き、パイプラインの実行は末端処理が呼び出された際に開始し、末端処理が完了した時点で終了する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally the elements of the stream are collected and joined together.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T074640Z">
        <seg>最後にストリームの要素は収集され、共に結合される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First a list is created consisting of two strings: "one"; and "two".</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T074614Z">
        <seg>最初に"one"と"two"の2つの要素を持つリストが作成される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a parallel execution, this function may be called multiple times and must return a fresh value each time.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T080539Z">
        <seg>並列実行の場合、この関数は複数回呼ばれる場合があり、その度に新しい値を返す必要がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For any given element, the action may be performed at whatever time and in whatever thread the library chooses.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T073421Z">
        <seg>与えられた要素に対して、アクションはライブラリが選んだ任意の時間と任意のスレッドで実行される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For any input elements {@code t1} and {@code t2}, the results {@code r1} and {@code r2} in the computation below must be equivalent:</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T015035Z">
        <seg>任意の入力{@code t1}と{@code t2}に対し、下記の計算における結果{@code r1}と{@code r2}は等価である必要がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For any partially accumulated result, combining it with an empty result container must produce an equivalent result.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T014737Z">
        <seg>任意の中間結果に対して、空の結果コンテナを統合した場合等価な結果となる必要がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For collectors that do not have the {@code UNORDERED} characteristic, two accumulated results {@code a1} and {@code a2} are equivalent if {@code finisher.apply(a1).equals(finisher.apply(a2))}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T053826Z">
        <seg>{@code UNORDERED}特性を持たないコレクタに関しては、累積結果{@code a1}と{@code a2}は{@code finisher.apply(a1).equals(finisher.apply(a2))}が成り立つときに等価である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For concurrent collectors, an implementation is free to (but not required to) implement reduction concurrently.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T065911Z">
        <seg>並行的なコレクタに対しては、簡約の実装は簡約を並行的に実装してもよい(しかし必ずする必要はない)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, "find the first {@code String} with three consecutive vowels" need not examine all the input strings.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T024619Z">
        <seg>例えば、「3つの連続した母音を含む最初の{@code String}を探す」際には全ての入力文字列を調べなくてもよい</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, consider the following code:</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T074558Z">
        <seg>例えば、以下のコードについて考える。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, filtering a {@code Stream} obtained from a collection produces a new {@code Stream} without the filtered elements, rather than removing elements from the source collection.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T024403Z">
        <seg>例えば、コレクションを元にした{@code Stream}に対する絞り込みは、元となるコレクションから要素を削除するのではなく、絞り込んだ値からのみなる新しい{@code Stream}を生成する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, given a stream of numbers for which we want to find the sum, we can write:</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T125433Z">
        <seg>例えば、渡された数値のストリームの和を求めたい場合、次のように書ける。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, given a stream of {@code Person}, to accumulate the set of last names in each city:</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T022512Z">
        <seg>例えば{@code Person}のストリームが与えられた際に、各市の名字の集合を累積するには次のようにする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, given a stream of {@code Person}, to calculate tallest person in each city:</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T025447Z">
        <seg>例えば{@code Person}のストリームが与えられた際に、各市において最も背が高い人を計算するには次のようにする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, given a stream of {@code Person}, to calculate the longest last name of residents in each city:</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T031457Z">
        <seg>例えば{@code Person}のストリームが与えられた際に、各市において最も長い名字を計算するには次のようにする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, given the following collector that computes the sum of the salaries of a stream of employees:</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T071910Z">
        <seg>例えば、従業員のストリームから給与の合計を計算する次のコレクタが与えられたとする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if you have a stream of {@code Person}, and you want to produce a "phone book" mapping name to address, but it is possible that two persons have the same name, you can do as follows to gracefully deals with these collisions, and produce a {@code Map} mapping names to a concatenated list of addresses:</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T041451Z">
        <seg>例えば、{@code Person}のストリームがあり、名前を住所と結び付ける「電話帳」を作りたいとする。しかし別の人が同じ名前を持つこともあるため、次のように、上品にそういった衝突を処理し、名前から住所を連結したリストを結び付けた{@code Map}を生成できる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, one cannot produce any results from sorting a stream until one has seen all elements of the stream.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T034411Z">
        <seg>たとえばストリームを整列した結果はストリームの全ての要素を見るまで全く生成できない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, one could adapt the {@link #toList()} collector to always produce an immutable list with:</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T022932Z">
        <seg>例えば次のようにすると、{@link #toList()}コレクタが常に不変なリストを作るようにできる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, suppose we have a collector that computes the sum of the salaries of a stream of employees, as follows:</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T013944Z">
        <seg>例えば、次のように従業員のストリームに対して給与の和を計算するコレクタがあるとする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the following produces a {@code Map} mapping students to their grade point average:</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T040321Z">
        <seg>例えば、次のコードは生徒を平均点に写像する{@code Map}を生成する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the following will accumulate strings into an {@code ArrayList}:</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T080454Z">
        <seg>例えば、次のコードはArrayListに文字列を累積する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, to collect the String representations of the elements in a stream into an {@code ArrayList}, we could write the obvious sequential for-each form:</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T012305Z">
        <seg>例えば、ストリーム中の要素の文字列表現を{@code ArrayList}に集めたい場合、次のような明確な逐次的for-each形式でも書ける。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, to compute the set of last names of people in each city, where the city names are sorted:</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T033550Z">
        <seg>例えば、各市における名字の整列済み集合を計算するには次のようにする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, to compute the set of last names of people in each city:</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T033132Z">
        <seg>例えば、各市における名字の集合を計算するには次のようにする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, you could create a collector that accumulates widgets into a {@code TreeSet} with:</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T082403Z">
        <seg>例えば、ウィジェットを{@code TreeSet}に累積するコレクタを次のように作成できる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, {@code Collection} has methods {@link java.util.Collection#stream} and {@link java.util.Collection#parallelStream}, which produce sequential and parallel streams respectively; other stream-bearing methods such as {@link java.util.stream.IntStream#range(int, int)} produce sequential streams but these streams can be efficiently parallelized by invoking their {@link java.util.stream.BaseStream#parallel()} method.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T040146Z">
        <seg>例えば、{@code Collection}は{@link java.util.Collection#stream}メソッドと{@link java.util.Collection#parallelStream}メソッドを持ち、それぞれ逐次的ストリームと並列ストリームを生成する。{@link java.util.stream.IntStream#range(int, int)}などの他のストリームを生じるメソッドは逐次的ストリームを生成するが、結果に対して{@code parallel()}を呼ぶと効率的に並列化できる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example:</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T023101Z">
        <seg>例:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For most data sources, preventing interference means ensuring that the data source is not modified at all during the execution of the stream pipeline.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T043126Z">
        <seg>ほとんどの情報源に対しては、干渉を防ぐということはストリームパイプラインの実行中に情報源が全く変更されないのを保障するということとなる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For non-concurrent collectors, any result returned from the result supplier, accumulator, or combiner functions must be serially thread-confined.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T065758Z">
        <seg>並行的でないコレクタに対しては、結果の供給関数・累積関数・統合関数から返された結果は、逐次的にスレッドに閉じ込められている(serially thread-confined)必要がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For ordered streams, the selection of distinct elements is stable (for duplicated elements, the element appearing first in the encounter order is preserved.) For unordered streams, no stability guarantees are made.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T070643Z">
        <seg>順序を持つストリームの場合、重複を除いた要素の選択は安定的である(重複する要素の場合、出現順で最初に表われた要素が保存される)。順序を持たないストリームの場合、安定性は保障されない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For ordered streams, the sort is stable.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T071533Z">
        <seg>順序を持つストリームに対して、整列は安定的である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For parallel stream pipelines, the action may be called at whatever time and in whatever thread the element is made available by the upstream operation.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T072025Z">
        <seg>並列ストリームパイプラインの場合、アクションは上流の処理から利用可能になった際に任意の時間と任意のスレッドで呼ばれる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For parallel stream pipelines, the {@code combiner} function operates by merging the keys from one map into another, which can be an expensive operation.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032155Z">
        <seg>並列ストリームに対しては、{@code combiner}関数はあるマップから別のマップに対してキーを併合するように動作する。これの処理のコストは高くなる可能性がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For parallel stream pipelines, this operation does not guarantee to respect the encounter order of the stream, as doing so would sacrifice the benefit of parallelism.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T073401Z">
        <seg>並列ストリームパイプラインの場合、この処理はストリームの出現順順序を尊重するとは限らない。そのようにしてしまうと並列処理の利点を犠牲にしてしまうためである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For parallel streams, relaxing the ordering constraint can sometimes enable more efficient execution.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T091903Z">
        <seg>並列ストリームに対しては、順序の制約を緩めるとより効率的な実行が可能となる場合がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For sequential streams, the presence or absence of an encounter order does not affect performance, only determinism.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T091828Z">
        <seg>逐次ストリームに対しては、順序付けは決定性にのみ影響し、効率には影響しない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For spliterators that report a characteristic of {@code IMMUTABLE} or {@code CONCURRENT}, or that are late-binding, it is likely more efficient to use {@link #doubleStream(java.util.Spliterator.OfDouble, boolean)} instead.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T042001Z">
        <seg>{@code IMMUTABLE}特性や{@code CONCURRENT}特性を示すスプリッテレータや遅延束縛をするスプリッテレータは代わりに{@link #doubleStream(java.util.Spliterator.OfDouble, boolean)}を使った方がより効率的である可能性が高い。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For spliterators that report a characteristic of {@code IMMUTABLE} or {@code CONCURRENT}, or that are late-binding, it is likely more efficient to use {@link #intStream(java.util.Spliterator.OfInt, boolean)} instead.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T041429Z">
        <seg>{@code IMMUTABLE}特性や{@code CONCURRENT}特性を示すスプリッテレータや遅延束縛をするスプリッテレータは代わりに{@link #intStream(java.util.Spliterator.OfInt, boolean)}を使った方がより効率的である可能性が高い。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For spliterators that report a characteristic of {@code IMMUTABLE} or {@code CONCURRENT}, or that are late-binding, it is likely more efficient to use {@link #longStream(java.util.Spliterator.OfLong, boolean)} instead.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T041706Z">
        <seg>{@code IMMUTABLE}特性や{@code CONCURRENT}特性を示すスプリッテレータや遅延束縛をするスプリッテレータは代わりに{@link #longStream(java.util.Spliterator.OfLong, boolean)}を使った方がより効率的である可能性が高い。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For spliterators that report a characteristic of {@code IMMUTABLE} or {@code CONCURRENT}, or that are late-binding, it is likely more efficient to use {@link #stream(java.util.Spliterator, boolean)} instead.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T040322Z">
        <seg>{@code IMMUTABLE}特性や{@code CONCURRENT}特性を示すスプリッテレータや遅延束縛をするスプリッテレータは代わりに{@link #stream(java.util.Spliterator, boolean)}を使った方がより効率的である可能性が高い。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For unordered collectors, equivalence is relaxed to allow for non-equality related to differences in order.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T081827Z">
        <seg>順序を持たないコレクタに関しては、等価性は順序の違いによる差異を許すように緩めることもある</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For unordered streams, no stability guarantees are made.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T071605Z">
        <seg>順序を持たないストリームに対して、安定性の保障は成されない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For well-behaved stream sources, the source can be modified before the terminal operation commences and those modifications will be reflected in the covered elements.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T074534Z">
        <seg>行儀が良いストリーム源の場合、末端処理を開始する前なら情報源を変更でき、それらの変更はストリームが扱う要素として反映される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For {@code n &gt; 0}, the element at position {@code n}, will be the result of applying the function {@code f} to the element at position {@code n - 1}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T083725Z">
        <seg>{@code n &gt; 0}に対しては、位置{@code n}の要素は{@code f}を位置{@code n - 1}の要素に適用した結果である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>From a {@link java.util.Collection} via the {@code stream()} and {@code parallelStream()} methods;</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T040621Z">
        <seg>{@link java.util.Collection}から{@code stream()}メソッドおよび{@code parallelStream()}メソッドを利用して入手する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>From an array via {@link java.util.Arrays#stream(Object[])};</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T040557Z">
        <seg>{@link java.util.Collection}から{@code stream()}メソッドおよび{@code parallelStream()}メソッドを利用して入手する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>From static factory methods on the stream classes, such as {@link java.util.stream.Stream#of(Object[])}, {@link java.util.stream.IntStream#range(int, int)} or {@link java.util.stream.Stream#iterate(Object, UnaryOperator)};</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T025913Z">
        <seg>ストリームクラスの{@link java.util.stream.Stream#of(Object[])}, {@link java.util.stream.IntStream#range(int, int)}, {@link java.util.stream.Stream#iterate(Object, UnaryOperator)}といった静的なファクトリメソッドを利用して入手する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Functional in nature.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T024138Z">
        <seg>本質的に関数的である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Functions.identity());
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T040346Z">
        <seg>Functions.identity());
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Further, however the computation is split, it must produce an equivalent result.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T014936Z">
        <seg>さらに、どのように計算が分割されたとしても等価な結果を生成する必要がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Further, some operations are deemed short-circuiting operations.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T034553Z">
        <seg>さらに、ある種の処理は&lt;em&gt;短絡的&lt;/em&gt;(short-circuiting)処理であると言われる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Further, some terminal operations may ignore encounter order, such as {@code forEach()}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T091237Z">
        <seg>さらに、ある種の末端処理は出現順順序を無視する({@code forEach()}など)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Further, the ordering of those effects may be surprising.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T084412Z">
        <seg>さらにそれらの作用の順番は予想できないものとなる場合がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Furthermore, using side-effects here is completely unnecessary; the {@code forEach()} can simply be replaced with a reduction operation that is safer, more efficient, and more amenable to parallelization:</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T090732Z">
        <seg>さらに、ここでの副作用の利用は完全に不必要である。{@code forEach()}はより安全でより効率的でより並列化に向いた簡約処理に置き換えられる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Generally, only streams whose source is an IO channel (such as those returned by {@link Files#lines(Path, Charset)}) will require closing.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T064517Z">
        <seg>一般的に、情報源がI/Oチャンネルであるようなストリーム({@link Files#lines(Path, Charset)}が返すストリームなど)のみ閉じる必要がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Having a short-circuiting operation in the pipeline is a necessary, but not sufficient, condition for the processing of an infinite stream to terminate normally in finite time.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T040751Z">
        <seg>パイプラインが短絡的処理を含むというのは無限ストリームに対する処理が有限時間で正常に完了するための必要条件であるが十分条件ではない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here we use {@code widgets}, a {@code Collection&lt;Widget&gt;}, as a source for a stream, and then perform a filter-map-reduce on the stream to obtain the sum of the weights of the red widgets.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T033606Z">
        <seg>ここでは{@code Collection&lt;Widget&gt;}である{@code widget}をストリームのデータ源(source)として使い、ストリームに対して絞り込み(filter)・写像(map)・簡約(reduce)を実行して赤いウィジェットの重さの和を計算した</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, equivalence generally means according to {@link java.lang.Object#equals(Object)}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T015204Z">
        <seg>ここで、等価であるとは一般的には{@link java.lang.Object#equals(Object)}によるという意味である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, if the mapping operation is performed in parallel, the results for the same input could vary from run to run, due to thread scheduling differences, whereas, with a stateless lambda expression the results would always be the same.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T080039Z">
        <seg>ここでもしマップ処理が並列に実行されると、同じ入力に対しても、スレッドのスケジューリングの違いにより、実行するごとに異なる結果となる場合がある。一方、状態を持たないラムダ式であれば結果は常に同じとなる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, our supplier is just the {@link java.util.ArrayList#ArrayList() ArrayList constructor}, the accumulator adds the stringified element to an {@code ArrayList}, and the combiner simply uses {@link java.util.ArrayList#addAll addAll} to copy the strings from one container into the other.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T065554Z">
        <seg>ここでは供給関数(supplier)はただの{@link java.util.ArrayList#ArrayList() ArrayListのコンストラクタ}であり、累積関数は文字列化した要素を{@code ArrayList}に加えていき、統合関数は単に{@link java.util.ArrayList#addAll addAll}を使ってあるコンテナから別のコンテナに文字列をコピーする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, the identity element is both an initial seed value for the reduction and a default result if there are no input elements.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T131431Z">
        <seg>ここで、単位元(identity)は簡約の最初の種となるとなる値であり、要素が無い場合のデフォルトの結果でもある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How are those stream-bearing methods implemented?</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T021329Z">
        <seg>これらのストリーム関係のメソッドはどのように実装されているのだろうか。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, a concurrent collection also has a downside.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T015802Z">
        <seg>しかし、並行コレクションには欠点もある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, if the provided stream operations do not offer the desired functionality, the {@link #iterator()} and {@link #spliterator()} operations can be used to perform a controlled traversal.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T044451Z">
        <seg>ただし、用意されたストリーム演算に望む機能がない場合、走査の制御のために{@link #iterator()}演算と{@link #spliterator()}演算が利用できる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, if the source has no defined encounter order, then any permutation of the values {@code [2, 4, 6]} would be a valid result.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T091601Z">
        <seg>しかし、もしデータ源に出現順順序が定められていなければ、値{@code [2, 4, 6]}の任意の順列はどれも妥当な結果となる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, most stream pipelines, such as the "sum of weight of blocks" example above, still parallelize efficiently even under ordering constraints.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T100448Z">
        <seg>しかしながら、上記の「ウィジェットの重さの和」の例のようなほとんどのストリームパイプラインにおいては、順序の制約があっても効率的に並列化できる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, side-effects such as using {@code println()} for debugging purposes are usually harmless.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T085251Z">
        <seg>ただし、デバッグ目的での{@code println()}の利用などは通常は無害である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, since floating-point summation is not exact, the above code is not necessarily equivalent to the summation computation done by this method.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T093650Z">
        <seg>しかし、浮動小数点の和は正確でないため、上記のコードはこのメソッドによる和の計算と等価とは限らない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, since some stream operations may return their receiver rather than a new stream object, it may not be possible to detect reuse in all cases.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T064259Z">
        <seg>しかし、ある種のストリーム演算は新しいストリームオブジェクトではなくレシーバを返すため、再利用を常に検知できるとは限らない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the library is free to partition the input, perform the reduction on the partitions, and then use the combiner function to combine the partial results to achieve a parallel reduction.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T070611Z">
        <seg>しかし、ライブラリは入力を分割し、部分部分に簡約を適用し、統合関数を使って部分的な結果を統合して、並列簡約を実現してもよい</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, there are good reasons to prefer a reduce operation over a mutative accumulation such as the above.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T122948Z">
        <seg>しかし、上記のような可変な累積処理よりも簡約処理を選ぶ尤もな理由がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, we might not be happy about the performance!</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T011508Z">
        <seg>しかし性能は満足いくものではないだろう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ideally, a spliterator for a stream would report a characteristic of {@code IMMUTABLE} or {@code CONCURRENT}; if not it should be late-binding.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T030816Z">
        <seg>理想的にはストリームのスプリッテレータは{@code IMMUTABLE}特性または{@code CONCURRENT}特性を示す。そうでなければ遅延束縛(late-binding)するべきである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a result is passed to the combiner or finisher function, and the same object is not returned from that function, it is never used again.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T065259Z">
        <seg>もし結果が統合関数や仕上げ関数に渡され、同じオブジェクトがそれらの関数から返されなかった場合は、それを再び利用してはいけない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a source cannot directly supply a recommended spliterator, it may indirectly supply a spliterator using a {@code Supplier}, and construct a stream via the {@code Supplier}-accepting versions of {@link java.util.stream.StreamSupport#stream(Supplier, int, boolean) stream()}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T031003Z">
        <seg>もしデータ源が推奨されるスプリッテレータを直接用意できない場合は、スプリッテレータを{@code Supplier}と、{@code Supplier}を受けとる{@link java.util.stream.StreamSupport#stream(Supplier, int, boolean) stream()}を使って間接的に用意してもよい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a stream is ordered, most operations are constrained to operate on the elements in their encounter order; if the source of a stream is a {@code List} containing {@code [1, 2, 3]}, then the result of executing {@code map(x -&gt; x*2)} must be {@code [2, 4, 6]}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T091428Z">
        <seg>もしストリームが順序付けられている場合、ほとんどの処理は要素を出現順に処理するよう制約される。もしストリームが{@code [1, 2, 3]}を含む{@code List}である場合、{@code map(x -&gt; x*2)}を実行した結果は{@code [2, 4, 6]}である必要がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a stream is ordered, repeated execution of identical stream pipelines on an identical source will produce an identical result; if it is not ordered, repeated execution might produce different results.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T091741Z">
        <seg>もしストリームが順序付けられていれば、同じ情報源に対する同じストリームパイプラインの実行は同じ結果をもたらす。もしストリームが順序付けられていなれば、繰り返し実行はは異なる結果をもたらす場合がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a {@code CONCURRENT} collector is not also {@code UNORDERED}, then it should only be evaluated concurrently if applied to an unordered data source.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T074507Z">
        <seg>もし{@code CONCURRENT}なコレクタが{@code UNORDERED}でなければ、順序を持たないデータ源に適用された場合のみ並行に評価されるべきである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If any close handler throws an exception, the first exception thrown will be relayed to the caller of {@code close()}, with any remaining exceptions added to that exception as suppressed exceptions (unless one of the remaining exceptions is the same exception as the first exception, since an exception cannot suppress itself.) May return itself.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T080539Z">
        <seg>もしストリームを閉じるハンドラが例外を投げた場合、最初の例外に残りの例外が抑制された例外として追加され、{@code close}の呼び出し元に投げられる(残りの例外の1つが最初の例外と同じである場合は、例外は自分自身を抑制できないため除かれる)。このストリーム自身を返す場合がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If any recorded value is a NaN or the sum is at any point a NaN then the average will be NaN.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T094643Z">
        <seg>いずれかの要素が{@code NaN}であるか、いずれかの時点での和が{@code NaN}である場合、平均値は{@code NaN}となる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If any recorded value is a {@code NaN} or the sum is at any point a {@code NaN} then the average will be {@code NaN}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T024731Z">
        <seg>登録されるいずれかの要素が{@code NaN}であるか、いずれかの時点での和が{@code NaN}である場合、平均値は{@code NaN}となる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If any recorded value is a {@code NaN} or the sum is at any point a {@code NaN} then the sum will be {@code NaN}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T024354Z">
        <seg>登録されるいずれかの要素が{@code NaN}であるか、いずれかの時点での和が{@code NaN}である場合、和は{@code NaN}となる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If any stream element is a NaN or the sum is at any point a NaN then the sum will be NaN.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T093722Z">
        <seg>いずれかの要素が{@code NaN}であるか、いずれかの時点での和が{@code NaN}である場合、和は{@code NaN}となる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with {@code distinct()} in parallel pipelines, switching to sequential execution with {@link #sequential()} may improve performance.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T071400Z">
        <seg>もし並列パイプラインにおいて出現順との整合性が必要とされ、{@code distinct()}のメモリ使用量の性能が悪い場合、{@link #sequential()}を使って逐次実行に切り換えると性能が向上する場合がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with {@code limit()} in parallel pipelines, switching to sequential execution with {@link #sequential()} may improve performance.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T072816Z">
        <seg>もし並列パイプラインにおいて出現順との整合性が必要とされ、{@code limit()}のメモリ使用量の性能が悪い場合、{@link #sequential()}を使って逐次実行に切り換えると性能が向上する場合がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with {@code skip()} in parallel pipelines, switching to sequential execution with {@link #sequential()} may improve performance.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T073143Z">
        <seg>もし並列パイプラインにおいて出現順との整合性が必要とされ、{@code skip()}のメモリ使用量の性能が悪い場合、{@link #sequential()}を使って逐次実行に切り換えると性能が向上する場合がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If executed in parallel, the non-thread-safety of {@code ArrayList} would cause incorrect results, and adding needed synchronization would cause contention, undermining the benefit of parallelism.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T085648Z">
        <seg>並列に実行した場合、{@code ArrayList}のスレッド非安全性は間違った結果をもたらし、必要な同期を含めるとロック競合が起きて並列性の利点を損なってしまう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If floating-point summation were exact, this method would be equivalent to:</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T093613Z">
        <seg>もし浮動小数点の和が正確であれば、このメソッドは次と等価である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If it is not required that results are inserted into the {@code Map} in encounter order, using {@link #toConcurrentMap(Function, Function)} may offer better parallel performance.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T041559Z">
        <seg>もし結果を{@code Map}に出現順に挿入する必要がないならば、{@link #toConcurrentMap(Function, Function)}を使うとより良い並列性能が得られる場合がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If it is not required that results are merged into the {@code Map} in encounter order, using {@link #toConcurrentMap(Function, Function, BinaryOperator)} may offer better parallel performance.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T041844Z">
        <seg>もし結果を{@code Map}に出現順に併合する必要がないならば、{@link #toConcurrentMap(Function, Function, BinaryOperator)}を使うとより良い並列性能が得られる場合がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If it is not required that results are merged into the {@code Map} in encounter order, using {@link #toConcurrentMap(Function, Function, BinaryOperator, Supplier)} may offer better parallel performance.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T041822Z">
        <seg>もし結果を{@code Map}に出現順に併合する必要がないならば、{@link #toConcurrentMap(Function, Function, BinaryOperator, Supplier)}を使うとより良い並列性能が得られる場合がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If multiple threads are depositing results concurrently into a shared container, the order in which results are deposited is non-deterministic.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T015946Z">
        <seg>もし複数のスレッドが結果を並行に共有コンテナに累積していくと、結果が蓄積される順序は非決定的となる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If no elements are present, the result is 0.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T023255Z">
        <seg>要素が無ければ結果は0となる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If preservation of the order in which elements appear in the resulting {@code Map} collector is not required, using {@link #groupingByConcurrent(Function)} may offer better parallel performance.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032321Z">
        <seg>もし結果となる{@code Map}コレクタにおいて、要素が出現する順序を保存する必要がない場合、{@link #groupingByConcurrent(Function)}の方が並列性能が良い場合がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If preservation of the order in which elements are presented to the downstream collector is not required, using {@link #groupingByConcurrent(Function, Collector)} may offer better parallel performance.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T033236Z">
        <seg>もし下流のコレクタに要素を与える順序を保存する必要がない場合、{@link #groupingByConcurrent(Function, Collector)}の方が並列性能が良い場合がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If preservation of the order in which elements are presented to the downstream collector is not required, using {@link #groupingByConcurrent(Function, Supplier, Collector)} may offer better parallel performance.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T033608Z">
        <seg>もし下流のコレクタに要素を与える順序を保存する必要がない場合、{@link #groupingByConcurrent(Function, Supplier, Collector)}の方が並列性能が良い場合がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If set, it must be the case that an unchecked cast from A to R will succeed.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T074824Z">
        <seg>もしセットする場合は、AからRへの非チェックキャストは成功する必要がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the action accesses shared state, it is responsible for providing the required synchronization.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T073430Z">
        <seg>もしアクションが共有状態を変更するならば、アクションは必要な同期処理を用意する責任を負う。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the action modifies shared state, it is responsible for providing the required synchronization.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T072058Z">
        <seg>もしアクションが共有状態を変更した場合、必要な同期を用意する必要がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the behavioral parameters do have side-effects, unless explicitly stated, there are no guarantees as to the visibility of those side-effects to other threads, nor are there any guarantees that different operations on the "same" element within the same stream pipeline are executed in the same thread.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T084338Z">
        <seg>もし挙動パラメータが副作用を持つと、特に明示されない限り他のスレッドに対する副作用の可視性は保障されないし、同じストリームパイプラインの中の「同じ」要素に対する異なる処理が同じスレッドで実行されるという保障もない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the characteristic {@code IDENTITY_TRANSFORM} is set, this function may be presumed to be an identity transform with an unchecked cast from {@code A} to {@code R}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T073528Z">
        <seg>もし{@code IDENTITY_FINISH}特性がセットされている場合、この関数は{@code A}から{@code R}への非チェックキャストを伴なう恒等変換と仮定してもよい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the elements of this stream are not {@code Comparable}, a {@code java.lang.ClassCastException} may be thrown when the terminal operation is executed.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T071435Z">
        <seg>もし要素が{@code Comparable}でなければ、末端処理を実行した際に{@code java.lang.ClassCastException}が投げられる場合がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the mapped keys contains duplicates (according to {@link Object#equals(Object)}), an {@code IllegalStateException} is thrown when the collection operation is performed.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T040244Z">
        <seg>もし写像されたキーが({@link Object#equals(Object)}に従って)重複を含む場合は、収集処理が実行される際に{@code IllegalStateException}が発生する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the mapped keys contains duplicates (according to {@link Object#equals(Object)}), the value mapping function is applied to each equal element, and the results are merged using the provided merging function.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T040748Z">
        <seg>もし写像されたキーが({@link Object#equals(Object)}に従って)重複を含む場合は、等価な各要素に対して値に写像する関数が適用され、用意された併合関数により結果が併合される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the mapped keys may have duplicates, use {@link #toConcurrentMap(Function, Function, BinaryOperator)} instead.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T050425Z">
        <seg>写像されたキーが重複を含む場合は代わりに{@link #toConcurrentMap(Function, Function, BinaryOperator)}を使用せよ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the mapped keys may have duplicates, use {@link #toMap(Function, Function, BinaryOperator)} instead.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T040252Z">
        <seg>写像されたキーが重複を含む場合は代わりに{@link #toMap(Function, Function, BinaryOperator)}を使用せよ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the pipeline has more than 253 values, the divisor in the average computation will saturate at 253, leading to additional numerical errors.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T024959Z">
        <seg>もし、パイプラインに253個以上の値がある場合、平均値の計算における分母は253で飽和し、数値計算誤差の増加を引き起こす。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the stream has no encounter order, then any element may be returned.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T083136Z">
        <seg>このストリームが出現順順序を持たなければ任意の要素が返される場合がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the stream is empty then {@code false} is returned and the predicate is not evaluated.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T081724Z">
        <seg>このストリームが空であれば、述語は評価されず、{@code false}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the stream is empty then {@code true} is returned and the predicate is not evaluated.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T082044Z">
        <seg>このストリームが空であれば、述語は評価されず、{@code true}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the stream is empty, the quantification is said to be vacuously satisfied and is always {@code true} (regardless of P(x)).</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T082947Z">
        <seg>このストリームが空の場合、限量子は空虚に満たされる(vacuously satisfied)と言い、(P(x)に依らずに)常に{@code true}となる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the stream is empty, the quantification is said to be vacuously satisfied and is always {@code true}, regardless of P(x).</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T083011Z">
        <seg>このストリームが空の場合、限量子は空虚に満たされる(vacuously satisfied)と言い、(P(x)に依らずに)常に{@code true}となる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the stream is parallel, and the {@code Collector} is {@link Collector.Characteristics#CONCURRENT concurrent}, and either the stream is unordered or the collector is {@link Collector.Characteristics#UNORDERED unordered}, then a concurrent reduction will be performed (see {@link Collector} for details on concurrent reduction.)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T080925Z">
        <seg>もしストリームが並列で、{@code Collector}が{@link Collector.Characteristics#CONCURRENT 並行的}であり、ストリームが順序を持たないかコレクタが{@link Collector.Characteristics#UNORDERED 順序を持たない}場合、並行簡約が実行される(並行簡約については{@link Collector}を見よ)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If this stream contains fewer than {@code n} elements then an empty stream will be returned.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T073026Z">
        <seg>もしこのストリームが{@code n}より少ない要素を持つ場合、空のストリームが返される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If we wanted to create a collector to tabulate the sum of salaries by department, we could reuse the "sum of salaries" logic using {@link Collectors#groupingBy(Function, Collector)}:</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T072048Z">
        <seg>もし部門ごとの給与の合計の表を作るコレクタを作りたいなら、{@link java.util.stream.Collectors#groupingBy(Function, Collector) groupingBy}を利用して「給与の合計」を計算するロジックを再利用できる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If we wanted to take a stream of strings and concatenate them into a single long string, we could achieve this with ordinary reduction:</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T011441Z">
        <seg>例えば、文字列のストリームを受け取り、1つの長い文字列に連結したいとする。これは次のような通常の簡約でも実現できるだろう。 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If {@code orders} is a stream of purchase orders, and each purchase order contains a collection of line items, then the following produces a stream containing all the line items in all the orders:</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T070017Z">
        <seg>例えば{@code orders}が注文書のストリームであり、各注文書が勘定項目の集合からなる場合、以下のコードは全ての注文の全ての勘定項目を含むストリームを生成する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If {@code path} is the path to a file, then the following produces a stream of the {@code words} contained in that file:</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T070147Z">
        <seg>もし{@code path}ファイルへのパスである場合、以下のコードはそのファイルに含まれる単語({@code words})の列を生成する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If {@code widgets} is a collection of {@code Widget} objects, which have a {@code getWeight} method, we can find the heaviest widget with:</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T131212Z">
        <seg>もし{@code widgets}が{@code getWeight}メソッドを持つ{@code Widget}オブジェクトのコレクションである場合、最も重いブロックを次ようにして求められる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementations of {@link Collector} that implement various useful reduction operations, such as accumulating elements into collections, summarizing elements according to various criteria, etc.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140213T120939Z">
        <seg>要素をコレクションに累積する、様々な条件によって要素を要約するなど、様々な便利な簡約処理を実装した{@link Collector}の実装。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to the predefined implementations in {@link Collectors}, the static factory methods {@link #of(Supplier, BiConsumer, BinaryOperator, Characteristics...)} can be used to construct collectors.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T070127Z">
        <seg>コレクタの構築には、{@link Collectors}に予め用意された実装に加え、静的ファクトリメソッド{@link #of(Supplier, BiConsumer, BinaryOperator, Characteristics...)}も利用できる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to {@code Stream}, which is a stream of object references, there are primitive specializations for {@link IntStream}, {@link LongStream}, and {@link DoubleStream}, all of which are referred to as "streams" and conform to the characteristics and restrictions described here.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T042833Z">
        <seg>オブジェクトへの参照のストリームである{@code Stream}に加えて、プリミティブ値に特化した{@link IntStream}, {@link LongStream}, {@link DoubleStream}もあり、これらは全てが「ストリーム」と呼ばれ、ここに示される全ての特性と制約を満たす。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In almost all cases, terminal operations are eager, completing their traversal of the data source and processing of the pipeline before returning.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T032240Z">
        <seg>末端処理はほとんどの場合即時的(eagar)であり、値を返す前に情報源の走査とパイプラインの処理を完了する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In cases where the stream has an encounter order, but the user does not particularly care about that encounter order, explicitly de-ordering the stream with {@link java.util.stream.BaseStream#unordered() unordered()} may improve parallel performance for some stateful or terminal operations.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T100328Z">
        <seg>ストリームが出現順順序を持つが、ユーザは特に出現順にこだわらない場合、{@link java.util.stream.BaseStream#unordered() unordered()}を使って明示的にストリームの順序を取り除くと状態を持つ処理や末端処理において並列性能が向上する場合がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In its more general form, a {@code reduce} operation on elements of type {@code &lt;T&gt;} yielding a result of type {@code &lt;U&gt;} requires three parameters:</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T131252Z">
        <seg>より一般的な形式では、{@code &lt;T&gt;}型の要素に対して{@code &lt;U&gt;}型の結果を産出する{@code reduce}処理は3つのパラメータを必要とする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, this method may be implemented using compensated summation or other technique to reduce the error bound in the numerical sum compared to a simple summation of {@code double} values.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T094220Z">
        <seg>特に、このメソッドは補償付き和や他の技術を使って数値和の誤差の限度を{@code double}値の単純な和と比較して減らすように実装される場合がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In that case, the parallel invocations of the accumulator could actually deposit their results concurrently into the same shared result container, eliminating the need for the combiner to merge distinct result containers.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T015627Z">
        <seg>その場合、並列に複数起動された累積関数は共有する1つの結果コンテナに結果を累積でき、統合関数が個別の結果コンテナを統合せずに済むようにできるだろう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, the utility method {@link java.util.function.Function#identity()} may be helpful.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T040317Z">
        <seg>その場合、ユーティリティメソッド{@link java.util.function.Function#identity()}が役に立つだろう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this example, {@code widgets} is a {@code Collection&lt;Widget&gt;}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T042448Z">
        <seg>この例では{@code widgets}は{@code Collection&lt;Widget&gt;}である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Indicates that the collection operation does not commit to preserving the encounter order of input elements.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T074721Z">
        <seg>収集処理が入力要素の出現順を保存しようとしないという特性を示す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Indicates that the finisher function is the identity function and can be elided.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T074756Z">
        <seg>仕上げ関数が恒等関数であり、省略可能であるという特性を示す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Indicates that this collector is concurrent, meaning that the result container can support the accumulator function being called concurrently with the same result container from multiple threads.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T074341Z">
        <seg>このコレクタが並行的であるという特性を表す。つまり結果コンテナは累積関数が同じ結果コンテナに対して複数のスレッドから並行的に呼べるような仕様になっているという特性を表す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>IntStream</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032835Z">
        <seg>IntStream</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>IntStream#builder()</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032922Z">
        <seg>IntStream#builder()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>IntStream.of(1, 2, 3, 4)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032915Z">
        <seg>IntStream.of(1, 2, 3, 4)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Integer sum = integers.reduce(0, (a, b) -&gt; a+b);
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032845Z">
        <seg>Integer sum = integers.reduce(0, (a, b) -&gt; a+b);
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Integer sum = integers.reduce(0, Integer::sum);
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032845Z">
        <seg>Integer sum = integers.reduce(0, Integer::sum);
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Integer::sum);
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032808Z">
        <seg>Integer::sum);
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Intermediate operations are always lazy.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T024728Z">
        <seg>中間処理は必ず遅延的である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Intermediate operations are further divided into stateless and stateful operations.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T034126Z">
        <seg>中間処理はさらに状態を持たない(stateless)ものと状態を持つ(stateful)ものに分けられる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Intermediate operations return a new stream.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T031224Z">
        <seg>中間処理は新しいストリームを返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is common for either the key or the value to be the input elements.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T040309Z">
        <seg>キーまたは値が入力要素そのものである場合は多い。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is strongly recommended the spliterator report a characteristic of {@code IMMUTABLE} or {@code CONCURRENT}, or be late-binding.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T032250Z">
        <seg>スプリッテレータは{@code IMMUTABLE}特性か{@code CONCURRENT}特性を示すか、遅延束縛をするよう強く推奨される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Laziness also allows avoiding examining all the data when it is not necessary; for operations such as "find the first string longer than 1000 characters", it is only necessary to examine just enough strings to find one that has the desired characteristics without examining all of the strings available from the source.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T033546Z">
        <seg>また遅延処理は必要でない場合は全てのデータを処理しなくても良いようにできる。例えば「1000文字以上の最初の文字列を探す」といった処理では、情報源にある全ての文字列を調べる必要はなく、目的の性質を持った文字列を探すのに必要な分だけを調べればよい</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Laziness-seeking.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T024409Z">
        <seg>遅延的(lazy)であろうとする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Libraries that implement reduction based on {@code Collector}, such as {@link Stream#collect(Collector)}, must adhere to the following constraints:</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T064832Z">
        <seg>{@link Stream#collect(Collector)}のように、{@code Collector}に基いて簡約を実装するライブラリは次の制約を遵守する必要がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like an {@link java.util.Iterator}, a new stream must be generated to revisit the same elements of the source.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T025328Z">
        <seg>同じ情報源の同じ要素をもう一度処理したい場合は、{@link java.util.Iterator}と同じように、新しいストリームを生成する必要がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like {@link #reduce(Object, BinaryOperator)}, {@code collect} operations can be parallelized without requiring additional synchronization.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T075905Z">
        <seg>{@link #reduce(Object, BinaryOperator)}のように、{@code collect}処理は追加の同期処理を必要とせずに並列化できる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like {@link #reduce(double, DoubleBinaryOperator)}, {@code collect} operations can be parallelized without requiring additional synchronization.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T093518Z">
        <seg>{@link #reduce(double, DoubleBinaryOperator)}のように、{@code collect}処理は追加の同期処理を必要とせずに並列化できる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like {@link #reduce(int, IntBinaryOperator)}, {@code collect} operations can be parallelized without requiring additional synchronization.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T092439Z">
        <seg>{@link #reduce(int, IntBinaryOperator)}のように、{@code collect}処理は追加の同期処理を必要とせずに並列化できる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like {@link #reduce(long, LongBinaryOperator)}, {@code collect} operations can be parallelized without requiring additional synchronization.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T090817Z">
        <seg>{@link #reduce(long, LongBinaryOperator)}のように、{@code collect}処理は追加の同期処理を必要とせずに並列化できる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>List&lt;String&gt; asList = stringStream.collect(ArrayList::new, ArrayList::add,</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032855Z">
        <seg>List&lt;String&gt; asList = stringStream.collect(ArrayList::new, ArrayList::add,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>List&lt;String&gt; asList = stringStream.collect(Collectors.toList());
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032857Z">
        <seg>List&lt;String&gt; asList = stringStream.collect(Collectors.toList());
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>List&lt;String&gt; l = new ArrayList(Arrays.asList("one", "two"));</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032742Z">
        <seg>List&lt;String&gt; l = new ArrayList(Arrays.asList("one", "two"));</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>List&lt;String&gt; list = people.stream().map(Person::getName).collect(Collectors.toList());</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032930Z">
        <seg>List&lt;String&gt; list = people.stream().map(Person::getName).collect(Collectors.toList());</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>List&lt;String&gt; people</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032937Z">
        <seg>List&lt;String&gt; people</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>List&lt;String&gt; strings = stream.map(Object::toString)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032820Z">
        <seg>List&lt;String&gt; strings = stream.map(Object::toString)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>List&lt;String&gt;results =</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032750Z">
        <seg>List&lt;String&gt;results =</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>LongStream</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032836Z">
        <seg>LongStream</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>LongStream#builder()</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032914Z">
        <seg>LongStream#builder()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>LongStream.of(1, 2, 3, 4)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032904Z">
        <seg>LongStream.of(1, 2, 3, 4)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Low-level stream construction</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T021158Z">
        <seg>低水準ストリーム構築</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Low-level utility methods for creating and manipulating streams.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T031745Z">
        <seg>ストリームの作成や操作のための低水準ユーティリティメソッド群。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many computations where one might be tempted to use side effects can be more safely and efficiently expressed without side-effects, such as using reduction instead of mutable accumulators.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T085223Z">
        <seg>副作用を使いたくなるような多くの計算は、可変な累積変数ではなく簡約を利用するなどして、副作用を使わずにより安全で効率的に表現できる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many reductions using this form can be represented more simply by an explicit combination of {@code map} and {@code reduce} operations.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T075458Z">
        <seg>この形式を使った多くの簡約は{@code map}処理と{@code reduce}処理の明示的な組み合わせによって表現できる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many stream operations, such as filtering, mapping, or duplicate removal, can be implemented lazily, exposing opportunities for optimization.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T024443Z">
        <seg>絞り込み・写像・重複の削除といったストリームに対する多くの処理は遅延的に実装でき、最適化の機会をもたらす。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Map&lt;Boolean, List&lt;Student&gt;&gt; passingFailing =</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032935Z">
        <seg>Map&lt;Boolean, List&lt;Student&gt;&gt; passingFailing =</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Map&lt;Buyer, List&lt;Transaction&gt;&gt; salesByBuyer</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032830Z">
        <seg>Map&lt;Buyer, List&lt;Transaction&gt;&gt; salesByBuyer</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Map&lt;City, Person&gt; tallestByCity</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T031214Z">
        <seg>Map&lt;City, Person&gt; tallestByCity</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Map&lt;City, Set&lt;String&gt;&gt; lastNamesByCity</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032936Z">
        <seg>Map&lt;City, Set&lt;String&gt;&gt; lastNamesByCity</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Map&lt;City, Set&lt;String&gt;&gt; namesByCity</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T033133Z">
        <seg>Map&lt;City, Set&lt;String&gt;&gt; namesByCity</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Map&lt;City, String&gt; longestLastNameByCity</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T031504Z">
        <seg>Map&lt;City, String&gt; longestLastNameByCity</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Map&lt;Department, Integer&gt; salariesByDept</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032823Z">
        <seg>Map&lt;Department, Integer&gt; salariesByDept</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Map&lt;Department, Integer&gt; totalByDept</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032934Z">
        <seg>Map&lt;Department, Integer&gt; totalByDept</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Map&lt;Department, List&lt;Employee&gt;&gt; byDept</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032933Z">
        <seg>Map&lt;Department, List&lt;Employee&gt;&gt; byDept</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Map&lt;String, List&lt;Person&gt;&gt; peopleByCity</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032857Z">
        <seg>Map&lt;String, List&lt;Person&gt;&gt; peopleByCity</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Map&lt;String, Map&lt;String, List&lt;Person&gt;&gt;&gt; peopleByStateAndCity</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032858Z">
        <seg>Map&lt;String, Map&lt;String, List&lt;Person&gt;&gt;&gt; peopleByStateAndCity</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Map&lt;String, String&gt; phoneBook</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T041510Z">
        <seg>Map&lt;String, String&gt; phoneBook</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Map&lt;String, Student&gt; studentIdToStudent</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T040343Z">
        <seg>Map&lt;String, Student&gt; studentIdToStudent</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Map&lt;Student, Double&gt; studentToGPA</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T040333Z">
        <seg>Map&lt;Student, Double&gt; studentToGPA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>May not evaluate the predicate on all elements if not necessary for determining the result.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T081652Z">
        <seg>結果を特定するのに必要でなければ全ての要素に対しては述語を評価しない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>May return itself, either because the stream was already parallel, or because the underlying stream state was modified to be parallel.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T075803Z">
        <seg>このストリームが既に逐次的であるため、または元のストリームの状態を並列であるように変更したため、このストリーム自身を返す場合がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>May return itself, either because the stream was already sequential, or because the underlying stream state was modified to be sequential.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T075733Z">
        <seg>このストリームが既に逐次的であるため、または元のストリームの状態を逐次的であるように変更したため、このストリーム自身を返す場合がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>May return itself, either because the stream was already unordered, or because the underlying stream state was modified to be unordered.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T080007Z">
        <seg>このストリームが既に順序を持たないため、または元のストリームの状態を順序を持たないように変更したため、このストリーム自身を返す場合がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>More formally, the {@code identity} value must be an identity for the combiner function.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T131748Z">
        <seg>より形式的には値{@code identity}は統合関数の単位元である必要がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most stream operations accept parameters that describe user-specified behavior, such as the lambda expression {@code w -&gt; w.getWeight()} passed to {@code mapToInt} in the example above.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T062543Z">
        <seg>ほとんどのストリーム処理はユーザが指定する挙動を表わすパラメータを受け取る。上の例において{@code mapToInt}に渡されるラムダ式{@code w -&gt; w.getWeight()}などである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most stream operations accept parameters that describe user-specified behavior, which are often lambda expressions.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T041936Z">
        <seg>ほとんどのストリーム処理はユーザが指定した挙動を表すパラメータを受け取る。そのパラメータはラムダ式である場合が多い。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most streams are backed by collections, arrays, or generating functions, which require no special resource management.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T064600Z">
        <seg>ほとんどのストリームはコレクション・配列・生成関数が元になっており、特別な資源管理を必要としない</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mutable reduction</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T011233Z">
        <seg>可変的簡約</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Next the list is modified by adding a third string: "three".</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T074628Z">
        <seg>次にリストは3つ目の文字列"three"の追加により変更される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No storage.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T024059Z">
        <seg>記憶領域を持たない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Non-interference</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T041957Z">
        <seg>非干渉性(Non-interference)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Not only is a reduction "more abstract" -- it operates on the stream as a whole rather than individual elements -- but a properly constructed reduce operation is inherently parallelizable, so long as the function(s) used to process the elements are associative and stateless.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T125210Z">
        <seg>ただ単に「より抽象的」である(個別の要素ではなくストリーム全体に対して処理する)というだけでなく、適切に構築された簡約処理は、要素を処理する関数が結合的で状態を持たない限り、本質的に並列化できる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note also that attempting to access mutable state from behavioral parameters presents you with a bad choice with respect to safety and performance; if you do not synchronize access to that state, you have a data race and therefore your code is broken, but if you do synchronize access to that state, you risk having contention undermine the parallelism you are seeking to benefit from.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T081814Z">
        <seg>挙動パラメータから可変的な状態にアクセスしようとするのは安全性と効率の面で悪い選択となることにも注意されたい。もしその状態へのアクセスを同期させなければデータ競合(data race)を起こし、したがってコードは正しくなくなるだろう。しかし状態へのアクセスを同期させれば得ようとしている並列性を損なうロック競合(contention)が発生する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that if it is important that the elements for a given key appear in the order they appear in the source, then we cannot use a concurrent reduction, as ordering is one of the casualties of concurrent insertion.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T020838Z">
        <seg>もし与えられたキーに対する要素が情報源の中で出現する順序が重要である場合、順序は並行的な挿入によって失なわれる特性の1つなので、並行簡約は使えないことに注意されたい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Numerous other stream-bearing methods in the JDK, including {@link java.util.BitSet#stream()}, {@link java.util.regex.Pattern#splitAsStream(java.lang.CharSequence)}, and {@link java.util.jar.JarFile#stream()}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T030214Z">
        <seg>{@link java.util.BitSet#stream()}, {@link java.util.regex.Pattern#splitAsStream(java.lang.CharSequence)}, {@link java.util.jar.JarFile#stream()}など、JDKにあるストリーム関連の多数のメソッドから入手する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Of course, such operations can be readily implemented as simple sequential loops, as in:</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T102502Z">
        <seg>もちろん、このような処理は簡単な逐次的ループとして次のように難なく実装できる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once a result is passed to the combiner or finisher function, it is never passed to the accumulator function again.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T065345Z">
        <seg>もし結果が統合関数や仕上げ関数に渡された後は決してそれ以上累積関数にに渡してはいけない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only the terminal operations {@code iterator()} and {@code spliterator()} are not; these are provided as an "escape hatch" to enable arbitrary client-controlled pipeline traversals in the event that the existing operations are not sufficient to the task.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T032658Z">
        <seg>末端処理{@code iterator()}と{@code spliterator()}のみ即時的でない。これらは既存の処理が課題に対して十分でない場合にパイプラインの利用者側でコントロールできる任意の走査を可能とするための「逃げ道」として用意されている。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optional.of(result) : Optional.empty();
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032851Z">
        <seg>Optional.of(result) : Optional.empty();
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>OptionalDouble.of(result) : OptionalDouble.empty();
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032927Z">
        <seg>OptionalDouble.of(result) : OptionalDouble.empty();
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>OptionalInt heaviest = widgets.parallelStream()</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032802Z">
        <seg>OptionalInt heaviest = widgets.parallelStream()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>OptionalInt.of(result) : OptionalInt.empty();
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032919Z">
        <seg>OptionalInt.of(result) : OptionalInt.empty();
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>OptionalLong.of(result) : OptionalLong.empty();
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032911Z">
        <seg>OptionalLong.of(result) : OptionalLong.empty();
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Or we could use a parallelizable collect form:</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T012323Z">
        <seg>あるいは、並列化可能な収集形式(collect form)で次のようにも書ける。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ordering</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T090905Z">
        <seg>順序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, {@link #doubleStream(java.util.function.Supplier, int, boolean)} should be used to reduce the scope of potential interference with the source.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T041918Z">
        <seg>そうでなければデータ源との潜在的な干渉が起きる範囲を減らすために{@link #doubleStream(java.util.function.Supplier, int, boolean)}を使うべきである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, {@link #intStream(java.util.function.Supplier, int, boolean)} should be used to reduce the scope of potential interference with the source.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T041808Z">
        <seg>そうでなければデータ源との潜在的な干渉が起きる範囲を減らすために{@link #intStream(java.util.function.Supplier, int, boolean)}を使うべきである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, {@link #longStream(java.util.function.Supplier, int, boolean)} should be used to reduce the scope of potential interference with the source.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T041742Z">
        <seg>そうでなければデータ源との潜在的な干渉が起きる範囲を減らすために{@link #longStream(java.util.function.Supplier, int, boolean)}を使うべきである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, {@link #stream(java.util.function.Supplier, int, boolean)} should be used to reduce the scope of potential interference with the source.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T032334Z">
        <seg>そうでなければデータ源との潜在的な干渉が起きる範囲を減らすために{@link #stream(java.util.function.Supplier, int, boolean)}を使うべきである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Packaging mutable reductions into a Collector has another advantage: composability.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T013236Z">
        <seg>可変な簡約をCollectorにまとめると他にも利点が得られる。合成可能性である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parallelism</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T034745Z">
        <seg>並列性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perform the final transformation from the intermediate accumulation type {@code A} to the final result type {@code R}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T072822Z">
        <seg>中間累積型{@code A}から最終結果型{@code R}への最終変換を実行する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Performing a reduction operation with a {@code Collector} should produce a result equivalent to:</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T070529Z">
        <seg>{@code Collector}を使った簡約処理の実行は次のコードと等価な結果を生成するべきである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Performing the action for one element happens-before performing the action for subsequent elements, but for any given element, the action may be performed in whatever thread the library chooses.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T073925Z">
        <seg>1つの要素へのアクションは続く要素に対するアクションの実行の前に発生(happens-before)するが、与えられた要素に対してアクションはライブラリが選択した任意のスレッドで実行される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Performs a mutable reduction operation on the elements of this stream using a {@code Collector}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T090431Z">
        <seg>{@code Collector}を使ってこのストリームの要素に可変的簡約を実行する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Performs a mutable reduction operation on the elements of this stream.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T090443Z">
        <seg>このストリームの要素に可変的簡約を実行する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Performs a reduction on the elements of this stream, using an associative accumulation function, and returns an {@code OptionalDouble} describing the reduced value, if any.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T093407Z">
        <seg>与えられた結合的な累積関数を使って、このストリームの要素に簡約処理を実行して簡約された値があればそれを表す{@code OptionalDouble}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Performs a reduction on the elements of this stream, using an associative accumulation function, and returns an {@code OptionalInt} describing the reduced value, if any.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T092416Z">
        <seg>与えられた結合的な累積関数を使って、このストリームの要素に簡約処理を実行して簡約された値があればそれを表す{@code OptionalInt}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Performs a reduction on the elements of this stream, using an associative accumulation function, and returns an {@code OptionalLong} describing the reduced value, if any.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T090331Z">
        <seg>与えられた結合的な累積関数を使って、このストリームの要素に簡約処理を実行して簡約された値があればそれを表す{@code OptionalLong}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Performs a reduction on the elements of this stream, using an associative accumulation function, and returns an {@code Optional} describing the reduced value, if any.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T093444Z">
        <seg>与えられた結合的な累積関数を使って、このストリームの要素に簡約処理を実行して簡約された値を表す{@code Optinoal}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Performs a reduction on the elements of this stream, using the provided identity value and an associative accumulation function, and returns the reduced value.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T074415Z">
        <seg>与えられた単位元と、結合的な累積関数を使って、このストリームの要素に簡約処理を実行して簡約された値を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Performs a reduction on the elements of this stream, using the provided identity, accumulation and combining functions.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T075155Z">
        <seg>与えられた単位元と、累積関数と統合関数を使って、このストリームの要素に簡約処理を実行して簡約された値を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Performs an action for each element of this stream, guaranteeing that each element is processed in encounter order for streams that have a defined encounter order.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T090055Z">
        <seg>このストリームの各要素にアクションを適用する。出現順順序が定義されているストリームに対しては各要素は出現順順序で実行されると保障する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Performs an action for each element of this stream, in the encounter order of the stream if the stream has a defined encounter order.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T073621Z">
        <seg>このストリームの各要素にアクションを適用する。もしストリームに出現順順序が定義されていればその出現順順序で実行する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Performs an action for each element of this stream.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T073220Z">
        <seg>このストリームの各要素にアクションを適用する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Person::getAddress,</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T041511Z">
        <seg>Person::getAddress,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Person[] men = people.stream()</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032842Z">
        <seg>Person[] men = people.stream()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Pipelines containing exclusively stateless intermediate operations can be processed in a single pass, whether sequential or parallel, with minimal data buffering.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T034517Z">
        <seg>状態を持たない中間処理のみを含むパイプラインは、逐次的にも並列にも最小のバッファリングで1パスで実行できる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Possibly unbounded.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T024733Z">
        <seg>上限が無い場合がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Preserving stability for {@code distinct()} in parallel pipelines is relatively expensive (requires that the operation act as a full barrier, with substantial buffering overhead), and stability is often not needed.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T070906Z">
        <seg>並列パイプラインにおいて{@code distinct()}の安定性を保つのは比較的コストが高く(この処理がフルバリアとして働き、相当なバッファリングのオーバーヘッドを伴う)、多くの場合安定性は必要ない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Processing elements with an explicit {@code for-}loop is inherently serial.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T034932Z">
        <seg>明示的な{@ for}ループによる要素の処理は本質的に逐次的である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Processing streams lazily allows for significant efficiencies; in a pipeline such as the filter-map-sum example above, filtering, mapping, and summing can be fused into a single pass on the data, with minimal intermediate state.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T034441Z">
        <seg>ストリームを遅延的に処理すると大幅な効率化が可能となる。上記の絞り込み・写像・合計の例などのパイプラインでは、絞り込み・写像・合計はデータに対する1回のパスに融合でき、中間データも最小にできる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>R container = collector.supplier().get();</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T070452Z">
        <seg>R container = collector.supplier().get();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>R r1 = finisher.apply(a1);  // result without splitting</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T015105Z">
        <seg>R r1 = finisher.apply(a1);  // 分割しない場合の結果</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>R r2 = finisher.apply(combiner.apply(a2, a3));  // result with splitting
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T053718Z">
        <seg>R r2 = finisher.apply(combiner.apply(a2, a3));  // 分割した場合の結果
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>R result = supplier.get();</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032854Z">
        <seg>R result = supplier.get();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reduction operations</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T100501Z">
        <seg>簡約処理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reduction operations can be performed either sequentially or in parallel.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T051537Z">
        <seg>簡約処理は逐次的にも並列にも処理できる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reduction parallellizes well because the implementation can operate on subsets of the data in parallel, and then combine the intermediate results to get the final correct answer.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T130037Z">
        <seg>簡約の実装はデータの各部分を並列に処理し、中間結果を統合して最終的な正しい答えを得られるため、簡約は上手く並列化できる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reduction, concurrency, and ordering</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T015347Z">
        <seg>簡約と並行性と順序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a builder for a {@code DoubleStream}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T095251Z">
        <seg>{@code DoubleStream}のビルダを返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a builder for a {@code LongStream}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T091614Z">
        <seg>{@code LongStream}のビルダを返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a builder for a {@code Stream}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T083517Z">
        <seg>{@code Stream}のビルダを返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a builder for an {@code IntStream}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T092831Z">
        <seg>{@code IntStream}のビルダを返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a concurrent {@code Collector} implementing a "group by" operation on input elements of type {@code T}, grouping elements according to a classification function.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T034327Z">
        <seg>{@code T}型である入力要素に対する"group by"処理を実装する並行{@code Collector}を返す。つまり要素を分類関数に従ってグループ化する{@code Collector}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a concurrent {@code Collector} implementing a cascaded "group by" operation on input elements of type {@code T}, grouping elements according to a classification function, and then performing a reduction operation on the values associated with a given key using the specified downstream {@code Collector}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T035713Z">
        <seg>{@code T}型である入力要素に対するカスケードされた"group by"処理を実装する並行{@code Collector}を返す。つまり要素を分類関数に従ってグループ化した後に下流の{@code Collector}を使って与えられたキーに対応する値の簡約処理を実行する{@code Collector}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a concurrent {@code Collector} that accumulates elements into a {@code ConcurrentMap} whose keys and values are the result of applying the provided mapping functions to the input elements.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T050327Z">
        <seg>写像関数の結果をキーと値として、要素を{@code ConcurrentMap}に累積する並行{@code Collector}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a new {@code Collector} described by the given {@code supplier}, {@code accumulator}, and {@code combiner} functions.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T073211Z">
        <seg>与えられた関数{@code supplier}, {@code accumulator}, {@code combiner}によって表わされる新しい{@code Collector}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a new {@code Collector} described by the given {@code supplier}, {@code accumulator}, {@code combiner}, and {@code finisher} functions.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T073827Z">
        <seg>与えられた{@code supplier}, {@code accumulator}, {@code combiner}, {@code finisher}によって表わされる新しい{@code Collector}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a sequential ordered stream whose elements are the specified values.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T083606Z">
        <seg>要素が指定された値であるような逐次的なストリームを返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a sequential ordered {@code IntStream} from {@code startInclusive} (inclusive) to {@code endExclusive} (exclusive) by an incremental step of {@code 1}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T092949Z">
        <seg>{@code startInclusive}(この値を含む)から{@code endExclusive}(この値を含まない)まで、{@code 1}ずつ増加する順序を持つ逐次的な{@code IntStream}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a sequential ordered {@code IntStream} from {@code startInclusive} (inclusive) to {@code endInclusive} (inclusive) by an incremental step of {@code 1}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T093018Z">
        <seg>{@code startInclusive}(この値を含む)から{@code endInclusive}(この値を含む)まで、{@code 1}ずつ増加する順序を持つ逐次的な{@code IntStream}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a sequential ordered {@code LongStream} from {@code startInclusive} (inclusive) to {@code endExclusive} (exclusive) by an incremental step of {@code 1}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T091830Z">
        <seg>{@code startInclusive}(この値を含む)から{@code endExclusive}(この値を含まない)まで、{@code 1}ずつ増加する順序を持つ逐次的な{@code LongStream}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a sequential ordered {@code LongStream} from {@code startInclusive} (inclusive) to {@code endInclusive} (inclusive) by an incremental step of {@code 1}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T092015Z">
        <seg>{@code startInclusive}(この値を含む)から{@code endInclusive}(この値を含む)まで、{@code 1}ずつ増加する順序を持つ逐次的な{@code LongStream}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a sequential {@code DoubleStream} containing a single element.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032929Z">
        <seg>Returns a sequential {@code DoubleStream} containing a single element.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a sequential {@code IntStream} containing a single element.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T092843Z">
        <seg>1つの要素を含む逐次的な{@code IntStream}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a sequential {@code LongStream} containing a single element.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T091626Z">
        <seg>1つの要素を含む逐次的な{@code LongStream}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a sequential {@code Stream} containing a single element.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T083546Z">
        <seg>1つの要素を含む逐次的な{@code Stream}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a spliterator for the elements of this stream.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T075505Z">
        <seg>このストリームの要素のスプリッテレータを返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a stream consisting of the distinct elements (according to {@link Object#equals(Object)}) of this stream.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T070534Z">
        <seg>このストリームの要素のうち({@link Object#equals(Object)}に従って)重複を除いた要素からなるストリームを返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a stream consisting of the distinct elements of this stream.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T085826Z">
        <seg>このストリームの要素のうち重複を除いた要素からなるストリームを返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a stream consisting of the elements of this stream in sorted order.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T085844Z">
        <seg>このストリームの要素を、整列した結果からなるストリームを返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a stream consisting of the elements of this stream that match the given predicate.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T065113Z">
        <seg>このストリームの要素のうち、与えられた述語に適合する要素からなるストリームを返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a stream consisting of the elements of this stream, additionally performing the provided action on each element as elements are consumed from the resulting stream.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T071852Z">
        <seg>このストリームの要素からなり、加えて結果のストリームから要素が消費されるごとにその要素にアクションを実行するストリームを返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a stream consisting of the elements of this stream, sorted according to natural order.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T071516Z">
        <seg>このストリームの要素を、自然順に整列した結果からなるストリームを返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a stream consisting of the elements of this stream, sorted according to the provided {@code Comparator}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T071629Z">
        <seg>このストリームの要素を、与えらえた{@code Comparator}に従って整列した結果からなるストリームを返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a stream consisting of the elements of this stream, truncated to be no longer than {@code maxSize} in length.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T072454Z">
        <seg>このストリームの要素からなり、長さが{@code maxSize}より長くならないように切り詰められたストリームを返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a stream consisting of the remaining elements of this stream after discarding the first {@code n} elements of the stream.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T072937Z">
        <seg>このストリームの{@code n}個の要素を取り除いた残りの要素からなるストリームを返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a stream consisting of the results of applying the given function to the elements of this stream.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T065309Z">
        <seg>このストリームの要素に与えられた関数を適用した結果からなるストリームを返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a stream consisting of the results of replacing each element of this stream with the contents of a mapped stream produced by applying the provided mapping function to each element.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T065547Z">
        <seg>与えられた写像関数をこのストリームの各要素に適用して生成したストリームの内容で各要素を置き換えた結果からなるストリームを返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a {@code Collector} accepting elements of type {@code T} that counts the number of input elements.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T023246Z">
        <seg>{@code T}型の要素を受け入れ、l入力要素数を数える{@code Collector}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a {@code Collector} implementing a "group by" operation on input elements of type {@code T}, grouping elements according to a classification function, and returning the results in a {@code Map}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T031850Z">
        <seg>{@code T}型である入力要素に対する"group by"処理を実装する{@code Collector}を返す。つまり要素を分類関数に従ってグループ化して結果を{@code Map}で返す{@code Collector}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a {@code Collector} implementing a cascaded "group by" operation on input elements of type {@code T}, grouping elements according to a classification function, and then performing a reduction operation on the values associated with a given key using the specified downstream {@code Collector}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032512Z">
        <seg>{@code T}型である入力要素に対するカスケードされた"group by"処理を実装する{@code Collector}を返す。つまり要素を分類関数に従ってグループ化した後に下流の{@code Collector}を使って与えられたキーに対応する値の簡約処理を実行する{@code Collector}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a {@code Collector} that accumulates elements into a {@code Map} whose keys and values are the result of applying the provided mapping functions to the input elements.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T040229Z">
        <seg>写像関数の結果をキーと値として、要素を{@code Map}に累積する{@code Collector}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a {@code Collector} that accumulates the input elements into a new {@code Collection}, in encounter order.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140213T121417Z">
        <seg>入力要素を新しい{@code Collection}に出現順に累積する{@code Collector}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a {@code Collector} that accumulates the input elements into a new {@code List}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140213T121527Z">
        <seg>入力要素を新しい{@code List}に出現順に累積する{@code Collector}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a {@code Collector} that accumulates the input elements into a new {@code Set}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140213T121616Z">
        <seg>入力要素を新しい{@code Set}に出現順に累積する{@code Collector}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a {@code Collector} that concatenates the input elements into a {@code String}, in encounter order.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140213T122116Z">
        <seg>入力要素を出現順に{@link String}に連結する{@code Collector}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a {@code Collector} that concatenates the input elements, separated by the specified delimiter, in encounter order.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140213T122214Z">
        <seg>入力要素を出現順に指定された文字列で区切って{@link String}に連結する{@code Collector}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a {@code Collector} that concatenates the input elements, separated by the specified delimiter, with the specified prefix and suffix, in encounter order.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140213T122626Z">
        <seg>入力要素を出現順に指定された文字列で区切って連結し、指定された接頭辞および接尾辞を付与する{@code Collector}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a {@code Collector} that produces the arithmetic mean of a double-valued function applied to the input elements.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T024649Z">
        <seg>double値を返す関数を入力要素に適用した結果の算術平均を返す{@code Collector}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a {@code Collector} that produces the arithmetic mean of a long-valued function applied to the input elements.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T024630Z">
        <seg>long値を返す関数を入力要素に適用した結果の算術平均を返す{@code Collector}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a {@code Collector} that produces the arithmetic mean of an integer-valued function applied to the input elements.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T024617Z">
        <seg>int値を返す関数を入力要素に適用した結果の算術平均を返す{@code Collector}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a {@code Collector} that produces the maximal element according to a given {@code Comparator}, described as an {@code Optional&lt;T&gt;}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T023609Z">
        <seg>与えられた{@code Comparator}に従って最大の要素を表す{@code Optional&lt;T&gt;}を生成する{@code Collector&lt;T, T&gt;}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a {@code Collector} that produces the minimal element according to a given {@code Comparator}, described as an {@code Optional&lt;T&gt;}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T023402Z">
        <seg>与えられた{@code Comparator}に従って最小の要素を表す{@code Optional&lt;T&gt;}を生成する{@code Collector&lt;T, T&gt;}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a {@code Collector} that produces the sum of a double-valued function applied to the input elements.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T023854Z">
        <seg>double値を返す関数を入力要素に適用した結果の和を返す{@code Collector}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a {@code Collector} that produces the sum of a integer-valued function applied to the input elements.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T023652Z">
        <seg>int値を返す関数を入力要素に適用した結果の和を返す{@code Collector}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a {@code Collector} that produces the sum of a long-valued function applied to the input elements.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T023844Z">
        <seg>long値を返す関数を入力要素に適用した結果の和を返す{@code Collector}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a {@code Collector} which applies an {@code double}-producing mapping function to each input element, and returns summary statistics for the resulting values.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T051103Z">
        <seg>各入力要素に{@code double}を返す関数を適用し、結果の値に対する要約統計量を返す{@code Collector}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a {@code Collector} which applies an {@code int}-producing mapping function to each input element, and returns summary statistics for the resulting values.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T051016Z">
        <seg>各入力要素に{@code int}を返す関数を適用し、結果の値に対する要約統計量を返す{@code Collector}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a {@code Collector} which applies an {@code long}-producing mapping function to each input element, and returns summary statistics for the resulting values.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T051053Z">
        <seg>各入力要素に{@code long}を返す関数を適用し、結果の値に対する要約統計量を返す{@code Collector}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a {@code Collector} which partitions the input elements according to a {@code Predicate}, and organizes them into a {@code Map&lt;Boolean, List&lt;T&gt;&gt;}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T035901Z">
        <seg>入力要素を{@code Predicate}に従って分割して{@code Map&lt;Boolean, List&lt;T&gt;&gt;}に編成する{@code Collector}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a {@code Collector} which partitions the input elements according to a {@code Predicate}, reduces the values in each partition according to another {@code Collector}, and organizes them into a {@code Map&lt;Boolean, D&gt;} whose values are the result of the downstream reduction.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T040057Z">
        <seg>入力要素を{@code Predicate}に従って分割した後に他の{@code Collector}を使って各パーティションの値を簡約して、簡約結果を値とする{@code Map&lt;Boolean, D&gt;}に編成する{@code Collector}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a {@code Collector} which performs a reduction of its input elements under a specified mapping function and {@code BinaryOperator}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T031310Z">
        <seg>指定された写像関数と{@code BinaryOperator}に基いて入力要素の簡約を実行する{@code Collector}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a {@code Collector} which performs a reduction of its input elements under a specified {@code BinaryOperator} using the provided identity.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T025315Z">
        <seg>与えられた単位元を使い、指定された{@code BinaryOperator}に基いて入力要素の簡約を実行する{@code Collector}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a {@code Collector} which performs a reduction of its input elements under a specified {@code BinaryOperator}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T025651Z">
        <seg>指定された{@code BinaryOperator}に基づいて入力要素の簡約を実行する{@code Collector}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a {@code DoubleStream} consisting of the elements of this stream, converted to {@code double}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T091548Z">
        <seg>このストリームの要素を{@code double}に変換した要素からなる{@code DoubleStream}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a {@code DoubleStream} consisting of the results of applying the given function to the elements of this stream.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T065451Z">
        <seg>このストリームの要素に与えられた関数を適用した結果からなる{@code DoubleStream}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a {@code DoubleSummaryStatistics} describing various summary data about the elements of this stream.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T095007Z">
        <seg>このストリームの要素の各種概要情報を表す{@code DoubleSummaryStatistics}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a {@code LongStream} consisting of the elements of this stream, converted to {@code long}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T092745Z">
        <seg>このストリームの要素を{@code long}に変換した要素からなる{@code LongStream}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a {@code LongStream} consisting of the results of applying the given function to the elements of this stream.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T065441Z">
        <seg>このストリームの要素に与えられた関数を適用した結果からなる{@code LongStream}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a {@code LongSummaryStatistics} describing various summary data about the elements of this stream.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T091355Z">
        <seg>このストリームの要素の各種概要情報を表す{@code LongSummaryStatistics}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a {@code Set} of {@code Collector.Characteristics} indicating the characteristics of this Collector.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T073044Z">
        <seg>このCollectorの特性を示す{@code Collector.Characteristics}の{@code Set}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a {@code Stream} consisting of the elements of this stream, boxed to {@code Double}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T095239Z">
        <seg>このストリームの要素を{@code Double}にボックス化した要素からなる{@code Stream}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a {@code Stream} consisting of the elements of this stream, each boxed to a {@code Long}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T091601Z">
        <seg>このストリームの要素を{@code Long}にボックス化した要素からなる{@code Stream}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a {@code Stream} consisting of the elements of this stream, each boxed to an {@code Integer}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T092814Z">
        <seg>このストリームの要素を{@code Integer}にボックス化した要素からなる{@code Stream}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns an array containing the elements of this stream, using the provided {@code generator} function to allocate the returned array, as well as any additional arrays that might be required for a partitioned execution or for resizing.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T074059Z">
        <seg>このストリームの要素からなる配列を返す。与えられた{@code generator}関数を使って返り値の配列や、分割実行やリサイズ時に必要となる配列を確保する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns an array containing the elements of this stream.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T073959Z">
        <seg>このストリームの要素からなる配列を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns an empty sequential {@code DoubleStream}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T095257Z">
        <seg>空の逐次的{@code DoubleStream}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns an empty sequential {@code IntStream}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T092837Z">
        <seg>空の逐次的{@code IntStream}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns an empty sequential {@code LongStream}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T091620Z">
        <seg>空の逐次的{@code LongStream}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns an empty sequential {@code Stream}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T083534Z">
        <seg>空の逐次的{@code Stream}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns an equivalent stream that is unordered.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T075937Z">
        <seg>順序を持たず同等なストリームを返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns an equivalent stream that is parallel.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T075805Z">
        <seg>並列であり同等なストリームを返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns an equivalent stream that is sequential.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T075705Z">
        <seg>逐次的であり同等なストリームを返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns an equivalent stream with an additional close handler.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T080120Z">
        <seg>ストリームを閉じる追加のハンドラを伴う等価なストリームを返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns an infinite sequential ordered {@code DoubleStream} produced by iterative application of a function {@code f} to an initial element {@code seed}, producing a {@code Stream} consisting of {@code seed}, {@code f(seed)}, {@code f(f(seed))}, etc.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T095308Z">
        <seg>初期要素{@code seed}に対する関数{@code f}の繰り返しの適用によって生成された無限{@code DoubleStream}を返す。{@code seed}, {@code f(seed)}, {@code f(f(seed))}などからなる{@code LongStream}を生成する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns an infinite sequential ordered {@code IntStream} produced by iterative application of a function {@code f} to an initial element {@code seed}, producing a {@code Stream} consisting of {@code seed}, {@code f(seed)}, {@code f(f(seed))}, etc.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T092853Z">
        <seg>初期要素{@code seed}に対する関数{@code f}の繰り返しの適用によって生成された無限{@code IntStream}を返す。{@code seed}, {@code f(seed)}, {@code f(f(seed))}などからなる{@code LongStream}を生成する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns an infinite sequential ordered {@code LongStream} produced by iterative application of a function {@code f} to an initial element {@code seed}, producing a {@code Stream} consisting of {@code seed}, {@code f(seed)}, {@code f(f(seed))}, etc.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T091659Z">
        <seg>初期要素{@code seed}に対する関数{@code f}の繰り返しの適用によって生成された無限{@code LongStream}を返す。{@code seed}, {@code f(seed)}, {@code f(f(seed))}などからなる{@code LongStream}を生成する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns an infinite sequential ordered {@code Stream} produced by iterative application of a function {@code f} to an initial element {@code seed}, producing a {@code Stream} consisting of {@code seed}, {@code f(seed)}, {@code f(f(seed))}, etc.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T083646Z">
        <seg>初期要素{@code seed}に対する関数{@code f}の繰り返しの適用によって生成された無限{@code Stream}を返す。{@code seed}, {@code f(seed)}, {@code f(f(seed))}などからなるストームを生成する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns an infinite sequential unordered stream where each element is generated by the provided {@code DoubleSupplier}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T095358Z">
        <seg>各要素が{@code DoubleSupplier}によって生成される、逐次的な無限{@code Stream}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns an infinite sequential unordered stream where each element is generated by the provided {@code IntSupplier}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T092921Z">
        <seg>各要素が{@code IntSupplier}によって生成される、逐次的な無限ストリームを返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns an infinite sequential unordered stream where each element is generated by the provided {@code LongSupplier}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T091742Z">
        <seg>各要素が{@code LongSupplier}によって生成される、逐次的な無限ストリームを返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns an infinite sequential unordered stream where each element is generated by the provided {@code Supplier}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T083845Z">
        <seg>各要素が{@code Supplier}によって生成される、逐次的な無限{@code Stream}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns an iterator for the elements of this stream.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T075429Z">
        <seg>このストリームの要素のイテレータを返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns an object-valued {@code Stream} consisting of the results of applying the given function to the elements of this stream.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T085740Z">
        <seg>このストリームの要素に与えられた関数を適用した結果からなる、オブジェクトを値として持つ{@code Stream}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns an {@code DoubleStream} consisting of the results of replacing each element of this stream with the contents of a mapped stream produced by applying the provided mapping function to each element.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T070439Z">
        <seg>与えられた写像関数をこのストリームの各要素に適用して生成したストリームの内容で各要素を置き換えた結果からなる{@code DoubleStream}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns an {@code IntStream} consisting of the results of applying the given function to the elements of this stream.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T065418Z">
        <seg>このストリームの要素に与えられた関数を適用した結果からなる{@code IntStream}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns an {@code IntStream} consisting of the results of replacing each element of this stream with the contents of a mapped stream produced by applying the provided mapping function to each element.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T070404Z">
        <seg>与えられた写像関数をこのストリームの各要素に適用して生成したストリームの内容で各要素を置き換えた結果からなる{@code IntStream}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns an {@code IntSummaryStatistics} describing various summary data about the elements of this stream.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T092555Z">
        <seg>このストリームの要素の各種概要情報を表す{@code IntSummaryStatistics}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns an {@code LongStream} consisting of the results of replacing each element of this stream with the contents of a mapped stream produced by applying the provided mapping function to each element.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T070425Z">
        <seg>与えられた写像関数をこのストリームの各要素に適用して生成したストリームの内容で各要素を置き換えた結果からなる{@code LongStream}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns an {@code OptionalDouble} describing the arithmetic mean of elements of this stream, or an empty optional if this stream is empty.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T091222Z">
        <seg>このストリームの算術平均を表す{@code OptionalDouble}、またはこのストリームが空ならば空の{@code OptionalDouble}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns an {@code OptionalDouble} describing the maximum element of this stream, or an empty OptionalDouble if this stream is empty.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T094447Z">
        <seg>このストリームの最大要素を表す{@code OptionalDouble}、またはこのストリームが空ならば空の{@code OptionalDouble}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns an {@code OptionalDouble} describing the minimum element of this stream, or an empty OptionalDouble if this stream is empty.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T094305Z">
        <seg>このストリームの最小要素を表す{@code OptionalDouble}、またはこのストリームが空ならば空の{@code OptionalDouble}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns an {@code OptionalInt} describing the maximum element of this stream, or an empty optional if this stream is empty.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T092522Z">
        <seg>このストリームの最大要素を表す{@code OptionalInt}、またはこのストリームが空ならば空の{@code OptionalInt}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns an {@code OptionalInt} describing the minimum element of this stream, or an empty optional if this stream is empty.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T092526Z">
        <seg>このストリームの最小要素を表す{@code OptionalInt}、またはこのストリームが空ならば空の{@code OptionalInt}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns an {@code OptionalLong} describing the maximum element of this stream, or an empty optional if this stream is empty.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T091117Z">
        <seg>このストリームの最大要素を表す{@code OptionalLong}、またはこのストリームが空ならば空の{@code OptionalLong}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns an {@code OptionalLong} describing the minimum element of this stream, or an empty optional if this stream is empty.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T091030Z">
        <seg>このストリームの最小要素を表す{@code OptionalLong}、またはこのストリームが空ならば空の{@code OptionalLong}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns an {@link OptionalDouble} describing some element of the stream, or an empty {@code OptionalDouble} if the stream is empty.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T095130Z">
        <seg>このストリームのある要素を表す{@link OptionalDouble}、もしくはストリームが空であれば空の{@code OptionalDouble}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns an {@link OptionalDouble} describing the first element of this stream, or an empty {@code OptionalDouble} if the stream is empty.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T095036Z">
        <seg>このストリームの最初の要素を表す{@link OptionalDouble}、もしくはストリームが空であれば空の{@code OptionalDouble}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns an {@link OptionalInt} describing some element of the stream, or an empty {@code OptionalInt} if the stream is empty.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T095140Z">
        <seg>このストリームのある要素を表す{@link OptionalInt}、もしくはストリームが空であれば空の{@code OptionalInt}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns an {@link OptionalInt} describing the first element of this stream, or an empty {@code OptionalInt} if the stream is empty.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T092627Z">
        <seg>このストリームの最初の要素を表す{@link OptionalInt}、もしくはストリームが空であれば空の{@code OptionalInt}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns an {@link OptionalLong} describing some element of the stream, or an empty {@code OptionalLong} if the stream is empty.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T095150Z">
        <seg>このストリームのある要素を表す{@link OptionalLong}、もしくはストリームが空であれば空の{@code OptionalLong}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns an {@link OptionalLong} describing the first element of this stream, or an empty {@code OptionalLong} if the stream is empty.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T091420Z">
        <seg>このストリームの最初の要素を表す{@link OptionalLong}、もしくはストリームが空であれば空の{@code OptionalLong}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns an {@link Optional} describing some element of the stream, or an empty {@code Optional} if the stream is empty.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T095159Z">
        <seg>このストリームのある要素を表す{@link Optional}、もしくはストリームが空であれば空の{@code Optional}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns an {@link Optional} describing the first element of this stream, or an empty {@code Optional} if the stream is empty.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T083131Z">
        <seg>このストリームの最初の要素を表す{@link Optional}、もしくはストリームが空であれば空の{@code Optional}を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the count of elements in this stream.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T081532Z">
        <seg>このストリームの要素数を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the maximum element of this stream according to the provided {@code Comparator}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T081507Z">
        <seg>このストリームの最大要素を{@code Comparator}に従って返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the minimum element of this stream according to the provided {@code Comparator}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T081347Z">
        <seg>このストリームの最小要素を{@code Comparator}に従って返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the sum of elements in this stream.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T090939Z">
        <seg>このストリームの要素の和を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns whether all elements of this stream match the provided predicate.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T082039Z">
        <seg>このストリームの全ての要素が与えられた述語に適合するか返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns whether any elements of this stream match the provided predicate.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T081644Z">
        <seg>このストリームのある要素が与えられた述語に適合するか返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns whether no elements of this stream match the provided predicate.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T082743Z">
        <seg>このストリームのどの要素も与えられた述語に適合しないか返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns whether this stream, if a terminal operation were to be executed, would execute in parallel.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T075538Z">
        <seg>このストリームが実行された際に並列に実行されるかどうかを返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See Non-Interference for more details.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T031655Z">
        <seg>詳細は非干渉性を参照せよ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See Non-Interference for more details.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T032342Z">
        <seg>詳細は非干渉性を参照せよ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the class documentation for {@link Stream} and the package documentation for java.util.stream for additional specification of streams, stream operations, stream pipelines, and parallelism, which governs the behavior of all stream types.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T075400Z">
        <seg>全てのストリーム型の挙動を規定する、更なるストリームの仕様・処理・ストリームパイプライン・並列性については{@link Stream}のクラスドキュメントとjava.util.streamのパッケージドキュメントを参照せよ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the class documentation for {@link Stream} and the package documentation for java.util.stream for additional specification of streams, stream operations, stream pipelines, and parallelism.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T085650Z">
        <seg>更なるストリームの仕様・処理・ストリームパイプライン・並列性については{@link Stream}のクラスドキュメントとjava.util.streamのパッケージドキュメントを参照せよ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Set&lt;Integer&gt; seen = Collections.synchronizedSet(new HashSet&lt;&gt;());</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032745Z">
        <seg>Set&lt;Integer&gt; seen = Collections.synchronizedSet(new HashSet&lt;&gt;());</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Set&lt;String&gt; set = people.stream().map(Person::getName).collect(Collectors.toCollection(TreeSet::new));</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032930Z">
        <seg>Set&lt;String&gt; set = people.stream().map(Person::getName).collect(Collectors.toCollection(TreeSet::new));</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Short-circuiting operations such as {@code limit(n)} or {@code findFirst()} can allow computations on infinite streams to complete in finite time.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T024811Z">
        <seg>{@code limit(n)}や{@code findFirst()}といった短絡的処理を使うと無限のストリームに対する計算が有限の時間で終わるようにできる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Side-effects</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T082318Z">
        <seg>副作用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Side-effects in behavioral parameters to stream operations are, in general, discouraged, as they can often lead to unwitting violations of the statelessness requirement, as well as other thread-safety hazards.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T083720Z">
        <seg>副作用があると状態を持たないという要件を無意識的に破ってしまいがちであり、また他のスレッド安全性に関する危険要因ともなるからである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, operations that are intrinsically tied to encounter order, such as {@code limit()}, may require buffering to ensure proper ordering, undermining the benefit of parallelism.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T100026Z">
        <seg>同様に、{@code limit()}などのように本質的に出現順と結び付けられている処理は正しい順序を保障するためにバッファリングが必要となる場合があり、並列性の利点を損なう場合がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since the list was modified before the terminal {@code collect} operation commenced the result will be a string of "one two three".</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T074703Z">
        <seg>リストは末端の{@code collect}処理が開始する前に変更されたので、結果は文字列"one two three"となる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since the supplier is only invoked after the terminal operation commences, any modifications to the source up to the start of the terminal operation are reflected in the stream result.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T040508Z">
        <seg>供給関数は末端処理が開始した後にのみ呼ばれるため、データ源に対する末端処理の開始までの全ての変更は結果のストリームに反映される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So far, all the stream examples have used methods like {@link java.util.Collection#stream()} or {@link java.util.Arrays#stream(Object[])} to obtain a stream.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T021300Z">
        <seg>これまでのストリームの全ての例ではストリームを得るのに{@link java.util.Collection#stream()}や{@link java.util.Arrays#stream(Object[])}といったメソッドを利用していた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So we can evaluate {@code (a op b)} in parallel with {@code (c op d)}, and then invoke {@code op} on the results.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T021049Z">
        <seg>つまり{@code (a op b)}を{@code (c op d)}と並列に評価し、その後その結果に{@code op}を適用できる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some examples include:</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T025624Z">
        <seg>一部の例としては、次のような方法が挙げられる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some intermediate operations, such as {@code sorted()}, may impose an encounter order on an otherwise unordered stream, and others may render an ordered stream unordered, such as {@link java.util.stream.BaseStream#unordered()}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T091208Z">
        <seg>{@code sorted()}などのある種の中間処理は順序付けられていないストリームに出現順順序を導入する場合がある。一方で別の処理は順序付けられたストリームを順序付けられていない状態にする場合がある({@link java.util.stream.BaseStream#unordered()}など)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Spliterator characteristics of the supplied {@code Spliterator.OfDouble}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T042120Z">
        <seg>供給される{@code Spliterator.OfDouble}のスプリッテレータ特性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Spliterator characteristics of the supplied {@code Spliterator.OfInt}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T041504Z">
        <seg>供給される{@code Spliterator.OfInt}のスプリッテレータ特性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Spliterator characteristics of the supplied {@code Spliterator.OfLong}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T041851Z">
        <seg>供給される{@code Spliterator.OfLong}のスプリッテレータ特性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Spliterator characteristics of the supplied {@code Spliterator}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T040632Z">
        <seg>供給される{@code Spliterator}のスプリッテレータ特性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Spliterators for mutable data sources have an additional challenge; timing of binding to the data, since the data could change between the time the spliterator is created and the time the stream pipeline is executed.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T025907Z">
        <seg>可変な情報源に対するスプリッテレータには他の課題がある。データを束縛するタイミングである。スプリッテレータが作成されてからストリームパイプラインが実行されるまでの間にデータが変化する可能性があるからだ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stateful operations may need to process the entire input before producing a result.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T034338Z">
        <seg>状態を持つ処理は結果を生成する前に全ての入力を処理する必要がある場合がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stateful operations, such as {@code distinct} and {@code sorted}, may incorporate state from previously seen elements when processing new elements.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T034313Z">
        <seg>{@code distinct}や{@code sorted}といった状態を持つ処理は、新しい要素を処理する際に前の要素に起因する状態を組み入れる場合がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stateless behaviors</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T075418Z">
        <seg>状態を持たない挙動</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stateless operations, such as {@code filter} and {@code map}, retain no state from previously seen element when processing a new element -- each element can be processed independently of operations on other elements.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T034229Z">
        <seg>{@code filter}や{@code map}といった状態を持たない処理は、新しい要素を処理する際に前の要素に起因する状態を保持しない。各要素は他の要素に対する処理とは独立して処理できる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stream</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032904Z">
        <seg>Stream</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stream operations and pipelines</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T030702Z">
        <seg>ストリーム処理とパイプライン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stream operations are divided into intermediate and terminal operations, and are combined to form stream pipelines.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T030923Z">
        <seg>ストリーム処理は中間(intermediate)処理と末端(terminal)処理に分類でき、それらは組み合わされてパイプラインを形成する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stream operations are divided into intermediate ( {@code Stream}-producing) operations and terminal (value- or side-effect-producing) operations.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T024706Z">
        <seg>ストリームに対する処理は中間処理(intermediate operation, {@code Stream}を生成する)と末端処理(terminal operation, 値か副作用生成する)に分けられる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stream pipeline results may be nondeterministic or incorrect if the behavioral parameters to the stream operations are stateful.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T075551Z">
        <seg>ストリームパイプラインの結果は挙動パラメータが状態を持つ(stateful)は非決定的なものや間違ったものとなる場合がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stream pipelines may execute either sequentially or in parallel.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T064801Z">
        <seg>ストリームパイプラインは逐次的に実行される場合と並列に実行される場合がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stream#builder()</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032900Z">
        <seg>Stream#builder()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stream#collect(Collector)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T072059Z">
        <seg>Stream#collect(Collector)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stream#collect(Supplier, BiConsumer, BiConsumer)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032911Z">
        <seg>Stream#collect(Supplier, BiConsumer, BiConsumer)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stream#flatMap(Function)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032904Z">
        <seg>Stream#flatMap(Function)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stream.of("one", "two", "three", "four")</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032840Z">
        <seg>Stream.of("one", "two", "three", "four")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stream&lt;String&gt; lines = Files.lines(path, StandardCharsets.UTF_8);</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032837Z">
        <seg>Stream&lt;String&gt; lines = Files.lines(path, StandardCharsets.UTF_8);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stream&lt;String&gt; sl = l.stream();</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032742Z">
        <seg>Stream&lt;String&gt; sl = l.stream();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stream&lt;String&gt; words = lines.flatMap(line -&gt; Stream.of(line.split(" +")));
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032839Z">
        <seg>Stream&lt;String&gt; words = lines.flatMap(line -&gt; Stream.of(line.split(" +")));
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Streams are created with an initial choice of sequential or parallel execution.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T064914Z">
        <seg>ストリームは逐次実行か並列実行か選択されて作成される</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Streams are lazy; computation on the source data is only performed when the terminal operation is initiated, and source elements are consumed only as needed.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T043601Z">
        <seg>ストリームは遅延的(lazy)である。つまり情報源のデータに対する計算は末端処理が開始された際にのみ実行され、情報源の要素は必要になったときに消費される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Streams based on spliterators with the desired characteristics, or those using the Supplier-based factory forms, are immune to modifications of the data source prior to commencement of the terminal operation (provided the behavioral parameters to the stream operations meet the required criteria for non-interference and statelessness).</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T031638Z">
        <seg>要求された特性を持つスプリッテレータに基づくストリームや、Supplierに基づくファクトリ形式を使うストリームは、末端処理を開始する前になされたデータ源の変更に影響されない(挙動パラメータがが干渉的でなく、状態を持たないという条件を満たす場合)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Streams can be obtained in a number of ways.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T025531Z">
        <seg>ストリームは複数の方法で入手できる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Streams differ from collections in several ways:</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T024051Z">
        <seg>ストリームとコレクションにはいくつか異なる点がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Streams enable you to execute possibly-parallel aggregate operations over a variety of data sources, including even non-thread-safe collections such as {@code ArrayList}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T042628Z">
        <seg>ストリームを使うと、{@code ArrayList}などのスレッド安全でないコレクションを含む様々なデータ源に対しても、並列な処理も含めた集計処理をできるようになる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Streams facilitate parallel execution by reframing the computation as a pipeline of aggregate operations, rather than as imperative operations on each individual element.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T035307Z">
        <seg>ストリームは計算を各要素に対する命令的な処理としてではなく集約処理のパイプラインとして捉え直すことで並列処理を容易にする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Streams have a {@link #close()} method and implement {@link AutoCloseable}, but nearly all stream instances do not actually need to be closed after use.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T064424Z">
        <seg>ストリームは{@link #close()}メソッドを持ち、{@link AutoCloseable}を実装するが、ほとんど全てのストリームのインスタンスは実際には利用後に閉じる必要はない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Streams may or may not have a defined encounter order.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T090937Z">
        <seg>ストリームは出現順順序(encounter order)を持っている場合と持っていない場合がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Streams of file paths can be obtained from methods in {@link java.nio.file.Files};</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T030009Z">
        <seg>ファイルパスのストリームは{@link java.nio.file.Files}の各メソッドから得られる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Streams of random numbers can be obtained from {@link java.util.Random#ints()};</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T030030Z">
        <seg>乱数のストリームは{@link java.util.Random#ints()}から得られる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>String concat = stringStream.collect(StringBuilder::new, StringBuilder::append,</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032855Z">
        <seg>String concat = stringStream.collect(StringBuilder::new, StringBuilder::append,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>String concatenated = strings.reduce("", String::concat)
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032809Z">
        <seg>String concatenated = strings.reduce("", String::concat)
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>String joined = things.stream()</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032931Z">
        <seg>String joined = things.stream()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>String s = sl.collect(joining(" "));
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032743Z">
        <seg>String s = sl.collect(joining(" "));
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>StringBuilder::append)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032856Z">
        <seg>StringBuilder::append)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such an implementation would do a great deal of string copying, and the run time would be O(n^2) in the number of characters.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T011522Z">
        <seg>このような実装は大量の文字列コピーを実行し、実行時間は要素数に対してO(n^2)となるだろう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such parameters are always instances of a functional interface such as {@link java.util.function.Function}, and are often lambda expressions or method references.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T063539Z">
        <seg>このようなパラメータは常に関数的インターフェース(functional interface)のインスタンスであり、多くの場合ラムダ式やメソッド参照である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such parameters are always instances of a functional interface such as {@link java.util.function.Function}, and are often lambda expressions or method references.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T041909Z">
        <seg>このようなパラメータは常に{@link java.util.function.Function}といった関数的インターフェース(functional interface)のインスタンスであり、λ式やメソッド参照である場合が多い。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sum, min, max, and average are all special cases of reduction.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T090148Z">
        <seg>sum, min, max, averageは全て簡約の特別な場合である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sum, min, max, average, and string concatenation are all special cases of reduction.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T090201Z">
        <seg>sum, min, max, average, 文字列連結は全て簡約の特別な場合である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Summation is a special case of a reduction.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T093533Z">
        <seg>和は簡約の特別な場合である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Summing a stream of numbers can be expressed as:</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T074539Z">
        <seg>数値のストリームの合計は次のようにできる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Suppose, however, that the result container used in this reduction was a concurrently modifiable collection -- such as a {@link java.util.concurrent.ConcurrentHashMap}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T015606Z">
        <seg>しかし、この簡約で使われる結果コンテナが{@link java.util.concurrent.ConcurrentHashMap ConcurrentHashMap}のように並行的に変更できるコレクションであったとしよう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>T result = identity;</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032843Z">
        <seg>T result = identity;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>T result = null;</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032846Z">
        <seg>T result = null;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Terminal operations, such as {@code Stream.forEach} or {@code IntStream.sum}, may traverse the stream to produce a result or a side-effect.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T031557Z">
        <seg>末端処理はストリームを走査し、成果物を生成するか、副作用を発生させる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, for a partially accumulated result {@code a} that is the result of any series of accumulator and combiner invocations, {@code a} must be equivalent to {@code combiner.apply(a, supplier.get())}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T053514Z">
        <seg>つまり、いくつかの累積と統合の結果である中間累積結果{@code a}に対して、{@code a}は{@code combiner.apply(a, supplier.get())}と等価である必要がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, for a partially accumulated result {@code p} that is the result of any series of accumulator and combiner invocations, {@code p} must be equivalent to {@code combiner.apply(p, supplier.get())}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T014903Z">
        <seg>つまり、いくつかの累積と統合の結果である{@code p}に対して、{@code p}は{@code combiner.apply(p, supplier.get())}と等価である必要がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, for any input elements {@code t1} and {@code t2}, the results {@code r1} and {@code r2} in the computation below must be equivalent:</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T053701Z">
        <seg>つまり、任意の入力{@code t1}と{@code t2}に対し、下記の計算における結果{@code r1}と{@code r2}は等価である必要がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The "widgets" examples shown earlier shows how reduction combines with other operations to replace for loops with bulk operations.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T131117Z">
        <seg>以前示した「ウィジェット」の例では、簡約を他の処理と組み合わせて、ループをバルク処理で置き換える様子を示した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The accumulator function takes a partial result and the next element, and produces a new partial result.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T131432Z">
        <seg>累積関数(accumulator)は途中結果と次の要素を受けとり、新しい途中結果を生成する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The combiner function combines two partial results to produce a new partial result.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T131515Z">
        <seg>統合関数(combiner)は2つの途中結果を統合して新しい途中結果を生成する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The above example for collecting strings into a {@code List} can be rewritten using a standard {@code Collector} as:</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T013004Z">
        <seg>文字列を{@code List}に収集する上記の例は標準の{@code Collector}を使って次のように書き換えられる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The accumulator function for the new collector</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T073623Z">
        <seg>新しいコレクタの累積関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The associativity constraint says that splitting the computation must produce an equivalent result.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T053620Z">
        <seg>結合性の制約では計算を分割しても等価な結果が生成さえることが定められている。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The average is a special case of a reduction.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T094952Z">
        <seg>平均は簡約の特別な場合である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The average returned can vary depending upon the order in which values are recorded, due to accumulated rounding error in addition of values of differing magnitudes.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T024711Z">
        <seg>返される平均値は、桁が異なる値の加算に由来する丸め誤差の累積のため、値が登録される順番によって変化する場合がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The average returned can vary depending upon the order in which values are recorded.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T094657Z">
        <seg>返される和は要素が出現する順番によって変わる場合がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The behavior of this operation is explicitly nondeterministic.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T073324Z">
        <seg>この処理の挙動は非決定的であると明示的に定められている。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The behavior of this operation is explicitly nondeterministic; it is free to select any element in the stream.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T083227Z">
        <seg>この処理の動作は明示的に非決定的であり、どの要素を選んでもよい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The best approach is to avoid stateful behavioral parameters to stream operations entirely; there is usually a way to restructure the stream pipeline to avoid statefulness.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T082311Z">
        <seg>最も良い方法はストリーム処理に対して状態を持つ挙動パラメータを完全に避けるという方法である。ストリームパイプラインにおいて状態を避けるように再編する方法が通常はある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The built phase begins begins when the {@link #build()} method is called, which creates an ordered stream whose elements are the elements that were added to the stream builder, in the order they were added.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T092059Z">
        <seg>構築済段階は{@link #build()}メソッドが呼ばれた段階で開始し、{@link #build()}メソッドはこのストリームビルダに追加された要素を追加された順序で要素として持つ、順序を持つ{@code LongStream}を作成する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The built phase begins when the {@link #build()} method is called, which creates an ordered stream whose elements are the elements that were added to the stream builder, in the order they were added.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T093101Z">
        <seg>構築済段階は{@link #build()}メソッドが呼ばれた段階で開始し、{@link #build()}メソッドはこのストリームビルダに追加された要素を追加された順序で要素として持つ、順序を持つ{@code IntStream}を作成する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The built phase begins when the {@link #build()} method is called, which creates an ordered {@code Stream} whose elements are the elements that were added to the stream builder, in the order they were added.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T085005Z">
        <seg>構築済段階は{@link #build()}メソッドが呼ばれた段階で開始し、{@link #build()}メソッドはこのストリームビルダに追加された要素を追加された順序で要素として持つ、順序を持つ{@code Stream}を作成する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The characteristics must be equal to {@code supplier.get().characteristics()}, otherwise undefined behavior may occur when terminal operation commences.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T041238Z">
        <seg>この特性は{@code supplier.get().characteristics()}と等しい必要がある。そうでなければ末端処理開始した際に未定義動作となる可能性がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The class {@link Collectors} provides implementations of many common mutable reductions.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T052129Z">
        <seg>{@link Collectors}クラスには多くの一般的な可変的簡約の実装が用意されている。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The class {@link java.util.stream.Collectors} contains a number of predefined factories for collectors, including combinators that transform one collector into another.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T013402Z">
        <seg>{@link java.util.stream.Collectors}クラスにはコレクタのファクトリがいくつか予め用意されており、コレクタを他のコレクタに変換する結合子もある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The class {@link java.util.stream.StreamSupport} has a number of low-level methods for creating a stream, all using some form of a {@link java.util.Spliterator}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T021435Z">
        <seg>{@link java.util.stream.StreamSupport}クラスはストリームを作るための低水準なメソッドを備えており、それらは全てなんらかの形の{@link java.util.Spliterator}を利用している。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The classes {@link java.util.stream.Stream}, {@link java.util.stream.IntStream}, {@link java.util.stream.LongStream}, and {@link java.util.stream.DoubleStream} are streams over objects and the primitive {@code int}, {@code long} and {@code double} types.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T024044Z">
        <seg>クラス{@code Stream}, {@link java.util.stream.IntStream}, {@link java.util.stream.LongStream}, {@link java.util.stream.DoubleStream}はオブジェクトおよびプリミティブ型{@code int}, {@code long}, {@code double}のストリームである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The classification function maps elements to some key type {@code K}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T031858Z">
        <seg>分類関数は要素を{@code K}型の何らかのキーに写像する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The collector characteristics for the new collector</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T074028Z">
        <seg>新しいコレクタが備えるコレクタ特製</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The collector has the {@link java.util.stream.Collector.Characteristics#CONCURRENT} characteristic, and;</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T020143Z">
        <seg>コレクタが{@link java.util.stream.Collector.Characteristics#CONCURRENT}特性を持つ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The collector produces a {@code ConcurrentMap&lt;K, List&lt;T&gt;&gt;} whose keys are the values resulting from applying the classification function to the input elements, and whose corresponding values are {@code List}s containing the input elements which map to the associated key under the classification function.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T034452Z">
        <seg>このコレクタは、入力要素に分類関数を適用した結果の値をキーとして持ち、そのキーに分類関数が写像するような入力要素を含む{@code List}を対応する値として持つような{@code ConcurrentMap&lt;K, List&lt;T&gt;&gt;}を生成する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The collector produces a {@code Map&lt;K, List&lt;T&gt;&gt;} whose keys are the values resulting from applying the classification function to the input elements, and whose corresponding values are {@code List}s containing the input elements which map to the associated key under the classification function.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T031937Z">
        <seg>このコレクタは、入力要素に分類関数を適用した結果の値をキーとして持ち、そのキーに分類関数が写像するような入力要素を含む{@code List}を対応する値として持つような{@code Map&lt;K, List&lt;T&gt;&gt;}を生成する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The combiner function for the new collector</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T073629Z">
        <seg>新しいコレクタの統合関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The combiner function may fold state from one argument into the other and return that, or may return a new result container.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T072631Z">
        <seg>統合関数は片方の引数をもう片方に折り畳んでそれを返してもよいし、新しい結果オブジェクトを返してもよい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The default implementation behaves as if:</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T085048Z">
        <seg>デフォルト実装は次のように振る舞う。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The downstream collector operates on elements of type {@code T} and produces a result of type {@code D}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032950Z">
        <seg>下流のコレクタは{@code T}型の要素を処理し、{@code D}型の結果を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The element type of the new stream</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T065326Z">
        <seg>新しいストリーム要素の型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The elements are compared for equality according to {@link java.lang.Double#compare(double, double)}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T093227Z">
        <seg>要素は{@link java.lang.Double#compare(double, double)}に従って比較される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The elements of a stream are only visited once during the life of a stream.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T025201Z">
        <seg>ストリームの各要素は、ストリームが有効である間にそれぞれ1回だけ処理される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The final result type of the new collector</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T074121Z">
        <seg>新しいコレクタの最終結果型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The finisher function for the new collector</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T073839Z">
        <seg>新しいコレクタの仕上げ関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first argument passed to the accumulator function, both arguments passed to the combiner function, and the argument passed to the finisher function must be the result of a previous invocation of the result supplier, accumulator, or combiner functions.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T065043Z">
        <seg>累積関数に与えられる第1引数と、統合関数に与えられる両方の引数は、供給関数や累積関数や統合関数に対する以前の呼び出しの結果である必要がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first element (position {@code 0}) in the {@code DoubleStream} will be the provided {@code seed}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T095319Z">
        <seg>{@code DoubleStream}の最初の要素(位置{@code 0})は{@code seed}によって与えられる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first element (position {@code 0}) in the {@code IntStream} will be the provided {@code seed}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T092902Z">
        <seg>{@code IntStream}の最初の要素(位置{@code 0})は{@code seed}によって与えられる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first element (position {@code 0}) in the {@code LongStream} will be the provided {@code seed}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T091711Z">
        <seg>{@code LongStream}の最初の要素(位置{@code 0})は{@code seed}によって与えられる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first element (position {@code 0}) in the {@code Stream} will be the provided {@code seed}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T083702Z">
        <seg>{@code Stream}の最初の要素(位置{@code 0})は{@code seed}によって与えられる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following are examples of using the predefined collectors to perform common mutable reduction tasks:</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140213T121134Z">
        <seg>次のコードは予め用意されたコレクタを使ってよくある可変簡約作業をする例である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example illustrates an aggregate operation using the stream types {@link Stream} and {@link IntStream}, computing the sum of the weights of the red widgets:</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T075217Z">
        <seg>次の例は{@link Stream}型と{@link IntStream}型のストリームを使った集計処理を示し、赤いウィジェットの重さの和を計算する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example illustrates an aggregate operation using {@link Stream} and {@link DoubleStream}, computing the sum of the weights of the red widgets:</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T093131Z">
        <seg>次の例は{@link Stream}と{@link DoubleStream}を使った集計処理を示し、赤いウィジェットの重さの和を計算する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example illustrates an aggregate operation using {@link Stream} and {@link IntStream}, computing the sum of the weights of the red widgets:</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T092224Z">
        <seg>次の例は{@link Stream}と{@link IntStream}を使った集計処理を示し、赤いウィジェットの重さの和を計算する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example illustrates an aggregate operation using {@link Stream} and {@link IntStream}:</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T042417Z">
        <seg>次の例は{@link Stream}と{@link IntStream}を使った集計処理を示す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example illustrates an aggregate operation using {@link Stream} and {@link LongStream}, computing the sum of the weights of the red widgets:</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T092236Z">
        <seg>次の例は{@link Stream}と{@link LongStream}を使った集計処理を示し、赤いウィジェットの重さの和を計算する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following will accumulate strings into an ArrayList:</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T081151Z">
        <seg>以下のコードは文字列をArrayListに累積する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following will classify {@code Person} objects by city:</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T081202Z">
        <seg>以下のコードは{@code Person}オブジェクトを都市によって分類する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following will classify {@code Person} objects by state and city, cascading two {@code Collector}s together:</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T081213Z">
        <seg>以下のコードは2つの{@code Collector}を共にカスケードして、{@code Person}オブジェクトを州と都市によって分類する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following will take a stream of strings and concatenates them into a single string:</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T080511Z">
        <seg>次のコードは文字列のストリームを取り、1つの文字列に連結する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The form of this is very similar to the general form of ordinary reduction:</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T012100Z">
        <seg>この形式は通常の簡約の一般的な形式とよく似ている。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The generalized form is provided for cases where significant work can be optimized away by combining mapping and reducing into a single function.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T011214Z">
        <seg>一般的な形式は写像と簡約を1つの関数へ統合すると多くの処理が最適化によって取り除ける場合のために用意されている。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The generator function takes an integer, which is the size of the desired array, and produces an array of the desired size.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T074140Z">
        <seg>生成関数は望む配列の大きさである整数を受けとり、望む大きさの配列を生成する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The identity constraint says that for any partially accumulated result, combining it with an empty result container must produce an equivalent result.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T053406Z">
        <seg>単位元の制約では中間累積結果に対して空の結果コンテナを統合しても等価な結果が生成されることが定められている。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The implementation should not do anything with the result of any of the result supplier, accumulator, or combiner functions other than to pass them again to the accumulator, combiner, or finisher functions, or return them to the caller of the reduction operation.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T065120Z">
        <seg>実装は、供給関数・累積関数・統合関数の結果に対して、累積関数や統合関数や仕上げ関数に再び渡すか簡約処理の呼び出し側へ返すか以外してはいけない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The importance of this to parallel evaluation can be seen if we expand this to four terms:</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T021023Z">
        <seg>並列評価におけるこの性質の重要性はこれを次の4つの式の場合に拡大するとわかる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The intermediate accumulation type of the new collector</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T074106Z">
        <seg>新しいコレクタの中間累積型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The key abstraction introduced in this package is stream.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T024040Z">
        <seg>このパッケージで導入するキーとなるインターフェースはストリームである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The lines of a file can be obtained from {@link java.io.BufferedReader#lines()};</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T025937Z">
        <seg>ファイルの各行は{@link java.io.BufferedReader#lines()}で得られる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The maximum element will be {@code Double.NaN} if any stream element was NaN.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T094509Z">
        <seg>もしストリームのいずれかの要素がNaNであれば、最大要素は{@code Double.NaN}となる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The minimum element will be {@code Double.NaN} if any stream element was NaN.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T094520Z">
        <seg>もしストリームのいずれかの要素がNaNであれば、最小要素は{@code Double.NaN}となる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The mutable reduction operation is called {@link java.util.stream.Stream#collect(Collector) collect()}, as it collects together the desired results into a result container such as a {@code Collection}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T011653Z">
        <seg>可変的簡約処理は{@code Collection}のような結果コンテナに望む結果を収集(collect)していくため、{@link java.util.stream.Stream#collect(Collector) collect()}と呼ばれる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The need for non-interference applies to all pipelines, not just parallel ones.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T074034Z">
        <seg>非干渉性は並列なパイプラインだけでなく、全てのパイプラインに対して求められる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The notable exception to this are streams whose sources are concurrent collections, which are specifically designed to handle concurrent modification.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T043334Z">
        <seg>これに対する重要な例外は情報源が並行的(concurrent)な変更を扱うように特別に設計された並行コレクションであるようなストリームである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The only difference between the serial and parallel versions of this example is the creation of the initial stream, using " {@code parallelStream()}" instead of " {@code stream()}".</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T035840Z">
        <seg>この例における逐次版と並列版の唯一の違いは最初のストリームを「{@code stream()}」ではなく「{@code parallelStream()}」で生成した点である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The order of addition operations of this method is intentionally not defined to allow for implementation flexibility to improve the speed and accuracy of the computed result.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T093937Z">
        <seg>このメソッドにおける加算の順序は実装が柔軟に計算結果の速度と精度を改善できるようあえて定義されていない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The other forms of {@code toConcurrentMap} simply use a merge function that throws unconditionally, but you can easily write more flexible merge policies.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T050642Z">
        <seg>他の形式の{@code toConcurrentMap}は単純に無条件に例外を投げる併合関数を使うが、より柔軟な併合方針も書ける。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The other forms of {@code toMap} simply use a merge function that throws unconditionally, but you can easily write more flexible merge policies.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T041010Z">
        <seg>他の形式の{@code toMap}は単純に無条件に例外を投げる併合関数を使うが、より柔軟な併合方針も書ける。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The reduction implementation must manage that the input is properly partitioned, that partitions are processed in isolation, and combining happens only after accumulation is complete.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T065851Z">
        <seg>簡約の実装は、入力が重なりを持たずに分割され、分割処理は他の処理から分離して進行され、統合処理は累積処理が完了した後にのみ起きるようにやりくりする必要がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The result is described as an {@code Optional&lt;T&gt;}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T025403Z">
        <seg>結果は{@code Optional&lt;T&gt;}によって表される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The resulting collector produces a {@code Map&lt;K, D&gt;}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T033034Z">
        <seg>結果のコレクタは{@code Map&lt;K, D&gt;}を生成する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The resulting stream is ordered if both of the input streams are ordered, and parallel if either of the input streams is parallel.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T084232Z">
        <seg>結果のストリームは両方の入力ストリームが順序を持ては順序を持ち、どちらかの入力ストリームが並列であれば並列である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The resulting {@code Collector} has the {@code Collector.Characteristics.IDENTITY_FINISH} characteristic.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T073554Z">
        <seg>結果となる{@code Collector}は{@code Collector.Characteristics.IDENTITY_FINISH}特性を備える。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The returned {@code Collector} is not concurrent.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032037Z">
        <seg>返される{@code Collector}は並行的ではない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The simplest, but least performant, way to create a spliterator is to create one from an iterator using {@link java.util.Spliterators#spliteratorUnknownSize(java.util.Iterator, int)}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T024845Z">
        <seg>スプリッテレータと作るのに最も簡単であるが最も非効率的な方法はイテレータから{@link java.util.Spliterators#spliteratorUnknownSize(java.util.Iterator, int)}を使って作る方法である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The spliterator is obtained from the supplier only after the terminal operation of the stream pipeline commences.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T031014Z">
        <seg>スプリッテレータはストリームパイプラインの末端処理が開始した後にのみ提供者から取得される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The spliterator is only traversed, split, or queried for estimated size after the terminal operation of the stream pipeline commences.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T032146Z">
        <seg>スプリッテレータはストリープパイプラインの末端処理が開始した後にのみ走査・分割・推定サイズの問い合わせをされる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The stream implementations in the JDK create serial streams unless parallelism is explicitly requested.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T035546Z">
        <seg>JDKで実装されている{@code Stream}は並列性が明示的に要求されない限り逐次ストリームを作成する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The stream is parallel;</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T020136Z">
        <seg>ストリームが並列である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The streams classes have multiple forms of general reduction operations, called {@link java.util.stream.Stream#reduce(java.util.function.BinaryOperator) reduce()} and {@link java.util.stream.Stream#collect(java.util.stream.Collector) collect()}, as well as multiple specialized reduction forms such as {@link java.util.stream.IntStream#sum() sum()}, {@link java.util.stream.IntStream#max() max()}, or {@link java.util.stream.IntStream#count() count()}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T101331Z">
        <seg>ストリームクラスは{@link java.util.stream.Stream#reduce(java.util.function.BinaryOperator) reduce()}および{@link java.util.stream.Stream#collect(java.util.stream.Collector) collect()}という複数の形式の汎用簡約処理を備える。また、{@link java.util.stream.IntStream#sum() sum()}, {@link java.util.stream.IntStream#max() max()}, {@link java.util.stream.IntStream#count() count()}という複数の形式の、特定の目的のための簡約処理も備える。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The sum returned can vary depending upon the order in which values are recorded, due to accumulated rounding error in addition of values of differing magnitudes.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T024340Z">
        <seg>返される和は、桁が異なる値の加算に由来する丸め誤差の累積のため、値が登録される順番によって変化する場合がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The supplier function for the new collector</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T073615Z">
        <seg>新しいコレクタの供給関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The three aspects of {@code collect} -- supplier, accumulator, and combiner -- are tightly coupled.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T065603Z">
        <seg>{@code collect}の3つの側面、つまり供給関数・累積関数・統合関数は密に結合している。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The three-argument form is a generalization of the two-argument form, incorporating a mapping step into the accumulation step.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T010807Z">
        <seg>この3引数形式は2引数形式の一般化であり、写像ステップを累積ステップに組み込んだものである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type of input elements for the new collector</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T073700Z">
        <seg>新しいコレクタの入力要素の型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type of intermediate accumulation result, and final result, for the new collector</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T073724Z">
        <seg>新しいコレクタの中間累積結果および最終結果の型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type of stream elements</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T084515Z">
        <seg>ストリーム要素の型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type of the result</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T075530Z">
        <seg>結果の型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The use of a {@code Supplier} in this form provides a level of indirection that reduces the scope of potential interference with the source.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T040432Z">
        <seg>{@code Supplier}を利用するこの形式では、データ源との潜在的な干渉の範囲を減らすための1段階の間接参照が導入される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value of a floating-point sum is a function both of the input values as well as the order of addition operations.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T093814Z">
        <seg>浮動小数点の和は入力値と加算演算子の順序の両方の関数である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The {@code Collection} is created by the provided factory.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140213T121422Z">
        <seg>{@code Collection}は与えられたファクトリによって作成される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The {@code ConcurrentMap} is created by a provided supplier function.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T050902Z">
        <seg>{@code ConcurrentMap}は与えられた供給関数によって作成される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The {@code ConcurrentMap} produced by the Collector is created with the supplied factory function.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T035755Z">
        <seg>Collectorが生成する{@code ConcurrentMap}は与えられたファクトリ関数によって作成される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The {@code Map} is created by a provided supplier function.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T041742Z">
        <seg>{@code Map}は与えられた供給関数によって作成される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The {@code Map} produced by the Collector is created with the supplied factory function.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T033526Z">
        <seg>Collectorが生成する{@code Map}は与えられたファクトリ関数によって作成される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The {@code accumulator} function acts as a fused mapper and accumulator, which can sometimes be more efficient than separate mapping and reduction, such as when knowing the previously reduced value allows you to avoid some computation.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T075523Z">
        <seg>{@code accumulator}関数は写像関数と累積関数を融合した関数として振る舞うが、以前に簡約された値がわかれば計算を省ける場合などには、写像と簡約を分けた場合よりも効率的な場合がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The {@code accumulator} function must be an associative function.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T074515Z">
        <seg>{@code accumulator}関数は結合的関数である必要がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The {@code double} format can represent all consecutive integers in the range -253 to 253.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T024839Z">
        <seg>{@code double}形式は-253から253までの全ての連続する整数を表現できる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The {@code flatMap()} operation has the effect of applying a one-to-many transformation to the elements of the stream, and then flattening the resulting elements into a new stream.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T065931Z">
        <seg>{@code flatMap()}処理は1対多変換をストリームの各要素に適用し、結果の要素を新しいストリームに平坦化する効果を持つ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The {@code identity} value must be an identity for the accumulator function.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T074437Z">
        <seg>値{@code identity}は累積関数の単位元である必要がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The {@code identity} value must be an identity for the combiner function.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T075210Z">
        <seg>値{@code identity}は統合関数の単位元である必要がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The {@code mapper} function passed to {@code flatMap} splits a line, using a simple regular expression, into an array of words, and then creates a stream of words from that array.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T070303Z">
        <seg>{@code flatMap}に与えた{@code mapper}関数は行を簡単な正規表現を使って単語の配列に分割し、その配列から単語のストリームを作成する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The {@code mapping()} collectors are most useful when used in a multi-level reduction, such as downstream of a {@code groupingBy} or {@code partitioningBy}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T022501Z">
        <seg>{@code mapping()}コレクタはマルチレベル簡約、つまり{@code groupingBy}や{@code partitioningBy}の下流で利用する際に最も有益となる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The {@code reducing()} collectors are most useful when used in a multi-level reduction, downstream of {@code groupingBy} or {@code partitioningBy}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T025100Z">
        <seg>{@code reducing()}コレクタはマルチレベル簡約、つまり{@code groupingBy}や{@code partitioningBy}の下流で利用する際に最も有益となる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The {@link Supplier#get()} method will be invoked on the supplier no more than once, and only after the terminal operation of the stream pipeline commences.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T040217Z">
        <seg>供給関数に対して{@link Supplier#get()}メソッドはストリームパイプラインの末端処理が開始した後に高々1回だけ呼ばれる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The {@link java.util.stream.Stream#collect(Collector)} implementation will only perform a concurrent reduction if</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T020126Z">
        <seg>{@link java.util.stream.Stream#collect(Collector)}の実装は次の条件が満たされるときにのみ並行簡約を実施する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then a stream is created from that list.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T074620Z">
        <seg>そしてストリームがそのリストから作成される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then this stream is summed to produce a total weight.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T042708Z">
        <seg>そして重さの総計を求めるためにこのストリームの和が求められる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are a number of implementation choices in implementing a spliterator, nearly all of which are tradeoffs between simplicity of implementation and runtime performance of streams using that spliterator.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T024755Z">
        <seg>それらのほとんどは実装の単純さとそのスプリッテレータを使うストリームの実行時のパフォーマンスとのトレードオフである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are many existing classes in the JDK whose signatures are well-suited for use with method references as arguments to {@code collect()}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T080452Z">
        <seg>JDKには{@code collect()}の引数としてメソッド参照としての利用によく適合したシグネチャを持つ既存のクラスが多くある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are multiple ways to deal with collisions between multiple elements mapping to the same key.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T040755Z">
        <seg>同じキーに写像される要素間の衝突を処理する方法は複数ある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are no guarantees on the type, mutability, or serializability of the {@code Map} or {@code List} objects returned, or of the thread-safety of the {@code List} objects returned.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T034606Z">
        <seg>返される{@code Map}や{@code List}オブジェクトに対する、型・可変性・直列化可能性の保証は無く、返される{@code List}オブジェクトに対するスレッド安全性の保障はない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are no guarantees on the type, mutability, serializability, or thread-safety of the {@code List} returned; if more control over the returned {@code List} is required, use {@link #toCollection(Supplier)}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140213T121912Z">
        <seg>返される{@code List}に対する、型・可変性・直列化可能性・スレッド安全性の保証は無い。もし返される{@code List}についての制御権が必要であれば、{@link #toCollection(Supplier)}を利用せよ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are no guarantees on the type, mutability, serializability, or thread-safety of the {@code Map} or {@code List} objects returned.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T031942Z">
        <seg>返される{@code Map}や{@code List}オブジェクトに対する、型・可変性・直列化可能性・スレッド安全性の保証は無い。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are no guarantees on the type, mutability, serializability, or thread-safety of the {@code Map} returned.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T033050Z">
        <seg>返される{@code Map}オブジェクトに対する、型・可変性・直列化可能性・スレッド安全性の保証は無い。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are no guarantees on the type, mutability, serializability, or thread-safety of the {@code Set} returned; if more control over the returned {@code Set} is required, use {@link #toCollection(Supplier)}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140213T121936Z">
        <seg>返される{@code Set}に対する、型・可変性・直列化可能性・スレッド安全性の保証は無い。もし返される{@code List}についての制御権が必要であれば、{@link #toCollection(Supplier)}を利用せよ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, even when executed in parallel with non-thread-safe data structures (such as {@code ArrayList}), no additional synchronization is needed for a parallel reduction.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T081144Z">
        <seg>そのため({@code ArrayList}などの)スレッドセーフでないデータ構造に対して並列に実行されたとしても、並列簡約のために追加の同期処理は必要ない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These reduction operations can run safely in parallel with almost no modification:</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T125601Z">
        <seg>これらの簡約演算はほとんど変更せずとも安全に並列に実行できる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These requirements significantly reduce the scope of potential interference between mutations of the stream source and execution of stream pipelines.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T031242Z">
        <seg>これらの条件はストリーム源の変更とストリームパイプラインの実行の間で潜在的な干渉が起きる範囲を大幅に低減する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They are always lazy; executing an intermediate operation such as {@code filter()} does not actually perform any filtering, but instead creates a new stream that, when traversed, contains the elements of the initial stream that match the given predicate.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T031329Z">
        <seg>それらは常に遅延的(lazy)である。{@link java.util.stream.Stream#filter Stream.filter}のような中間処理を実行しても実際の絞り込みは実行されず、代わりに最初の{@code Stream}の要素のうち与えられた{@code Predicate}にマッチする要素を(走査した際に)含む新しい{@code Stream}を作成する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They are:</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T052343Z">
        <seg>その4つの関数とは次の通りである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows the creation of a {@code Stream} by generating elements individually and adding them to the {@code Builder} (without the copying overhead that comes from using an {@code ArrayList} as a temporary buffer.)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T084914Z">
        <seg>これにより要素を個別に生成して{@code StreamBuilder}へ追加して({@code ArrayList}を一時バッファとして使った場合の複製のオーバーヘッド無しに){@code Stream}を作成できるようになる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This can be concisely expressed with an array constructor reference:</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T074239Z">
        <seg>これは配列コンストラクタへの参照を使って簡潔に表せる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This class is mostly for library writers presenting stream views of data structures; most static stream methods intended for end users are in the various {@code Stream} classes.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T032117Z">
        <seg>このクラスは専らデータ構造に対してストリームとしてのビューを提供するライブラリ作者のためにある。一般利用者向けのほとんどの静的ストリームメソッドは各種{@code Stream}クラスにある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This code unnecessarily uses side-effects.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T085536Z">
        <seg>このコードは不必要に副作用を利用している。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This enables collection to occur in parallel without the {@code Collector} needing to implement any additional synchronization.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T065817Z">
        <seg>これにより{@code Collector}が余分な同期処理を実装しなくても収集を並列に実行できるようになる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This execution mode is a property of the stream.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T064822Z">
        <seg>この実行モードはストリームの特性である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is a short-circuiting stateful intermediate operation.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T072509Z">
        <seg>これは短絡的で状態を持つ中間処理である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is a short-circuiting terminal operation.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T081735Z">
        <seg>これは短絡的で状態を持つ末端処理である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is a stateful intermediate operation.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T070705Z">
        <seg>これは状態を持つ中間処理である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is a terminal operation.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T073241Z">
        <seg>これは末端処理である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is a generalization of {@link #reducing(Object, BinaryOperator)} which allows a transformation of the elements before reduction.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T031317Z">
        <seg>これは{@link #reducing(Object, BinaryOperator)}の一般化であり、簡約の前に要素の変換を許す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is a special case of a reduction and is equivalent to:</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T081545Z">
        <seg>これは簡約の特殊な場合であり、次のコードと等しい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is a special case of a reduction.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T081358Z">
        <seg>これは簡約の特別な場合である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is a {@link Collector.Characteristics#CONCURRENT concurrent} and {@link Collector.Characteristics#UNORDERED unordered} Collector.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T034405Z">
        <seg>これは{@link Collector.Characteristics#CONCURRENT 並行}で{@link Collector.Characteristics#UNORDERED 順序を持たない}Collectorである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is an  intermediate operation.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T065429Z">
        <seg>これは中間処理である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is an intermediate operation.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T065132Z">
        <seg>これは中間処理である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is an {@link Collector.Characteristics#UNORDERED unordered} Collector.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140213T122004Z">
        <seg>これは{@link Collector.Characteristics#UNORDERED 順序を持たない}Collectorである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is because the combining step (merging one {@code Map} into another by key) can be expensive for some {@code Map} implementations.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T015555Z">
        <seg>これは統合段階({@code Map}をキーに従って他のマップに統合する)の処理はある種の{@code Map}の実装では高価となるためである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is equivalent to:</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T074418Z">
        <seg>これは次と等しい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is possible only if we can prevent interference with the data source during the execution of a stream pipeline.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T042728Z">
        <seg>これはストリームパイプラインを実行している間、情報源に対する&lt;em&gt;干渉(interference)&lt;/em&gt;を防げる場合のみ可能となる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is suitable for generating constant streams, streams of random elements, etc.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T083849Z">
        <seg>定数のストリームや乱数のストリームなどを生成するのに向いている。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the {@code double} primitive specialization of {@link Stream}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T093123Z">
        <seg>これはプリミティブの{@code double}に特化した{@link Stream}である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the {@code int} primitive specialization of {@link Stream}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T092124Z">
        <seg>これはプリミティブの{@code int}に特化した{@link Stream}である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the {@code long} primitive specialization of {@link Stream}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T085516Z">
        <seg>これはプリミティブの{@code long}に特化した{@link Stream}である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is to allow for maximal performance in parallel operations; the cost is that multiple invocations on the same source may not return the same result.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T083448Z">
        <seg>これにより並列実行時の性能を最大化できる。その際のコストは同じ情報源に対する複数回の呼び出しが同じ値を返さないことである</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that for all {@code t}, {@code accumulator.apply(identity, t)} is equal to {@code t}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T074444Z">
        <seg>つまり、任意の{@code t}に対して{@code accumulator.apply(identity, t)}は{@code t}と等しい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that for all {@code u}, {@code combiner(identity, u)} is equal to {@code u}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T075251Z">
        <seg>つまり任意の{@code u}に対して、{@code combiner.apply(identity, u)}が{@code u}に等しいということである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that for all {@code u}, {@code combiner.apply(identity, u)} is equal to {@code u}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T010344Z">
        <seg>つまり任意の{@code u}に対して、{@code combiner.apply(identity, u)}が{@code u}に等しいということである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that for all {@code x}, {@code accumulator.apply(identity, x)} is equal to {@code x}.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T090118Z">
        <seg>つまり、任意の{@code x}に対して{@code accumulator.apply(identity, x)}は{@code x}と等しい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method evaluates the existential quantification of the predicate over the elements of the stream (for some x P(x)).</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T081901Z">
        <seg>このメソッドはこのストリームの要素に対して述語の存在限量子(あるxについてP(x))を評価する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method evaluates the universal quantification of the negated predicate over the elements of the stream (for all x ~P(x)).</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T082804Z">
        <seg>このメソッドはこのストリームの要素に対して述語の否定の全称限量子(全てのxについて~P(x))を評価する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method evaluates the universal quantification of the predicate over the elements of the stream (for all x P(x)).</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T082128Z">
        <seg>このメソッドはこのストリームの要素に対して述語の全称限量子(全てのxについてP(x))を評価する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method exists mainly to support debugging, where you want to see the elements as they flow past a certain point in a pipeline:</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T072156Z">
        <seg>このメソッドは主にデバッグの補助のために、パイプラインのある点を通過する要素を調べたいときのために存在する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method may be implemented using compensated summation or other technique to reduce the error bound in the {@link #sum numerical sum} used to compute the average.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T094941Z">
        <seg>特に、このメソッドは平均を計算するために使われる{@link #sum 数値和}の誤差の限度を減らすための補償付き和や他の技術を使って実装される場合がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This operation processes the elements one at a time, in encounter order if one exists.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T073719Z">
        <seg>この処理では出現順順序がある場合、出現順に従って要素を一度に1つずつ処理する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This potentially provides a boost to the parallel execution performance.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T015709Z">
        <seg>これを並行簡約と呼ぶ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This produces a result equivalent to:</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T075849Z">
        <seg>これは次のコードと同じ結果を生成する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This produces a result similar to:</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T031956Z">
        <seg>これは次のコードと似た結果を生成する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This rules out, for example, "forked" streams, where the same source feeds two or more pipelines, or multiple traversals of the same stream.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T064117Z">
        <seg>これは例えば「分岐」したストリームを認めない、つまり同じ情報源から複数のパイプラインに要素を供給したり、同じストリームを複数回走査するといったことを認めないということである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This set should be immutable.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T073101Z">
        <seg>この集合は不変であるべきである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To ensure that sequential and parallel executions produce equivalent results, the collector functions must satisfy an identity and an associativity constraints.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T053242Z">
        <seg>逐次的な実行と並列実行が等価な結果を作成するよう保障するためには、集約関数は単位元と結合性に関する制約を満たす必要がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To execute the prior "sum of weights of widgets" query in parallel, we would do:</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T040130Z">
        <seg>前述の「ウィジェットの重さの合計」を問い合わせる処理を並列にするには次のようにする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To perform a computation, stream operations are composed into a stream pipeline.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T043055Z">
        <seg>計算を実行するために、ストリーム処理は組み立てられて1つのストリームパイプラインへと合成される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To perform a simple map-reduce on a stream, use {@link Stream#map(Function)} and {@link Stream#reduce(Object, BinaryOperator)} instead.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T031355Z">
        <seg>ストリームに対して単純な写像・簡約を実行する場合は代わりに{@link Stream#map(Function)}と{@link Stream#reduce(Object, BinaryOperator)}を使用せよ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To perform a simple reduction on a stream, use {@link Stream#reduce(BinaryOperator)} instead.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T025413Z">
        <seg>ストリームに対して単純な簡約を実行する場合は代わりに{@link Stream#reduce(BinaryOperator)}を使用せよ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To perform a simple reduction on a stream, use {@link Stream#reduce(Object, BinaryOperator)}} instead.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T025119Z">
        <seg>ストリームに対して単純な簡約を実行する場合は代わりに{@link Stream#reduce(Object, BinaryOperator)}を使用せよ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To preserve correct behavior, these behavioral parameters must be non-interfering, and in most cases must be stateless.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T041552Z">
        <seg>挙動の正しさを維持するためには、それらの挙動パラメータ(behavioral parameter)は非干渉的(non-interfering)である必要があり、さらに多くの場合は状態を持たない(stateless)必要がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To preserve correct behavior, these behavioral parameters:</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T062644Z">
        <seg>正しい動作を保つため、それらの挙動パラメータ(behavioral parameters)は次の条件を満たす必要がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Traversal of the pipeline source does not begin until the terminal operation of the pipeline is executed.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T031440Z">
        <seg>パイプラインの末端処理が実行されるまでパイプラインのデータ源の走査は始まらない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>U result = identity;</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032853Z">
        <seg>U result = identity;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unless otherwise specified these parameters must be non-null.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T063621Z">
        <seg>特に別記されてない限り、それらのパラメータはnullではいけない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unless the source was explicitly designed for concurrent modification (such as a {@link ConcurrentHashMap}), unpredictable or erroneous behavior may result from modifying the stream source while it is being queried.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T044936Z">
        <seg>情報源が({@link ConcurrentHashMap}などのように)並行的な変更のために特別に設計されている場合を除き、問い合わせ中にストリーム源を変更すると予測できない挙動や誤った挙動となる場合がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unless the stream source is concurrent, modifying a stream's data source during execution of a stream pipeline can cause exceptions, incorrect answers, or nonconformant behavior.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T074218Z">
        <seg>ストリームの情報源が並行でない限り、ストリームパイプラインの実行中にストリームの情報源を変更すると例外・不正な答え・一般的でない結果を引き起こす。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike the numerical comparison operators, this method considers negative zero to be strictly smaller than positive zero.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T094351Z">
        <seg>数値比較演算子と異なり、このメソッドは負の零は正の零よりも真に小さいとみなす。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use caution when constructing streams from repeated concatenation.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T084416Z">
        <seg>連結の繰り返しによりストリームを構築する際には注意が必要である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using an unordered stream source (such as {@link #generate(DoubleSupplier)}) or removing the ordering constraint with {@link #unordered()} may result in significant speedups of {@code limit()} in parallel pipelines, if the semantics of your situation permit.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T093258Z">
        <seg>メソッドを使う状況が許すならば、順序を持たないストリーム源({@link #generate(DoubleSupplier)}など)を使うか、{@link #unordered()}により順序の制約を外すと並列パイプラインにおいて{@code limit()}の実行を大幅に効率化できる場合がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using an unordered stream source (such as {@link #generate(DoubleSupplier)}) or removing the ordering constraint with {@link #unordered()} may result in significant speedups of {@code skip()} in parallel pipelines, if the semantics of your situation permit.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T093311Z">
        <seg>メソッドを使う状況が許すならば、順序を持たないストリーム源({@link #generate(DoubleSupplier)}など)を使うか、{@link #unordered()}により順序の制約を外すと並列パイプラインにおいて{@code skip()}の実行を大幅に効率化できる場合がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using an unordered stream source (such as {@link #generate(IntSupplier)}) or removing the ordering constraint with {@link #unordered()} may result in significant speedups of {@code limit()} in parallel pipelines, if the semantics of your situation permit.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T092313Z">
        <seg>メソッドを使う状況が許すならば、順序を持たないストリーム源({@link #generate(IntSupplier)}など)を使うか、{@link #unordered()}により順序の制約を外すと並列パイプラインにおいて{@code limit()}の実行を大幅に効率化できる場合がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using an unordered stream source (such as {@link #generate(IntSupplier)}) or removing the ordering constraint with {@link #unordered()} may result in significant speedups of {@code skip()} in parallel pipelines, if the semantics of your situation permit.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T092321Z">
        <seg>メソッドを使う状況が許すならば、順序を持たないストリーム源({@link #generate(IntSupplier)}など)を使うか、{@link #unordered()}により順序の制約を外すと並列パイプラインにおいて{@code skip()}の実行を大幅に効率化できる場合がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using an unordered stream source (such as {@link #generate(LongSupplier)}) or removing the ordering constraint with {@link #unordered()} may result in significant speedups of {@code limit()} in parallel pipelines, if the semantics of your situation permit.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T085925Z">
        <seg>メソッドを使う状況が許すならば、順序を持たないストリーム源({@link #generate(LongSupplier)}など)を使うか、{@link #unordered()}により順序の制約を外すと並列パイプラインにおいて{@code limit()}の実行を大幅に効率化できる場合がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using an unordered stream source (such as {@link #generate(LongSupplier)}) or removing the ordering constraint with {@link #unordered()} may result in significant speedups of {@code skip()} in parallel pipelines, if the semantics of your situation permit.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T085936Z">
        <seg>メソッドを使う状況が許すならば、順序を持たないストリーム源({@link #generate(LongSupplier)}など)を使うか、{@link #unordered()}により順序の制約を外すと並列パイプラインにおいて{@code skip()}の実行を大幅に効率化できる場合がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using an unordered stream source (such as {@link #generate(Supplier)}) or removing the ordering constraint with {@link #unordered()} may result in significant speedups of {@code limit()} in parallel pipelines, if the semantics of your situation permit.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T072810Z">
        <seg>メソッドを使う状況が許すならば、順序を持たないストリーム源({@link #generate(Supplier)}など)を使うか、{@link #unordered()}により順序の制約を外すと並列パイプラインにおいて{@code limit()}の実行を大幅に効率化できる場合がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using an unordered stream source (such as {@link #generate(Supplier)}) or removing the ordering constraint with {@link #unordered()} may result in significant speedups of {@code skip()} in parallel pipelines, if the semantics of your situation permit.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T073137Z">
        <seg>メソッドを使う状況が許すならば、順序を持たないストリーム源({@link #generate(Supplier)}など)を使うか、{@link #unordered()}により順序の制約を外すと並列パイプラインにおいて{@code skip()}の実行を大幅に効率化できる場合がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using an unordered stream source (such as {@link #generate(Supplier)}) or removing the ordering constraint with {@link #unordered()} may result in significantly more efficient execution for {@code distinct()} in parallel pipelines, if the semantics of your situation permit.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T071201Z">
        <seg>メソッドを使う状況が許すならば、順序を持たないストリーム源({@link #generate(Supplier)}など)を使うか、{@link #unordered()}により順序の制約を外すと並列パイプラインにおいて{@code distinct()}の実行を大幅に効率化できる場合がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Values sorted by increasing absolute magnitude tend to yield more accurate results.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T024256Z">
        <seg>絶対値が小さい順に整列するとより正確な値を出す傾向がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We call this a concurrent reduction.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032831Z">
        <seg>We call this a concurrent reduction.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We can use the abstraction of a {@link java.util.stream.Collector} to capture all three aspects.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T012947Z">
        <seg>{@link java.util.stream.Collector}という概念を使うとこの3つの側面を全て捉えられる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We can use the same technique to parallelize mutable reduction as we do with ordinary reduction.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T011610Z">
        <seg>可変的簡約の並列化には通常の簡約の際と同じ手法が使える。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We could re-cast the simple sum-of-weights example using the more general form as follows:</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T011024Z">
        <seg>単純な重量の合計の例はより一般的な形式を使い次のように再構成できる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We create a stream of {@code Widget} objects via {@link Collection#stream Collection.stream()}, filter it to produce a stream containing only the red widgets, and then transform it into a stream of {@code int} values representing the weight of each red widget.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T042634Z">
        <seg>ここでは{@code Widget}オブジェクトのストリームを{@link Collection#stream Collection.stream()}で作成し、赤いウィジェットのみを含むストリームを作成するために絞り込み、それを赤い各ウィジェットの重さを表す{@code int}のストリームに変換する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We would get the desired result, and it would even work in parallel.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T011501Z">
        <seg>これでも望む結果は得られるし、並列にも動作できる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We would then be constrained to implement either a sequential reduction or a merge-based parallel reduction.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T020903Z">
        <seg>その場合、逐次簡約か統合ベースの並列簡約に制限される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When executed in parallel, multiple intermediate results may be instantiated, populated, and merged so as to maintain isolation of mutable data structures.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T081134Z">
        <seg>並列に実行された場合、可変なデータ構造の隔離を維持するために複数の中間結果がインスタンス化され、満たされ、併合される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the resulting stream is closed, the close handlers for both input streams are invoked.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T084331Z">
        <seg>結果のストリームが閉じられた場合、両方の入力ストリームを閉じるハンドラが呼び出される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the terminal operation is initiated, the stream pipeline is executed sequentially or in parallel depending on the mode of the stream on which it is invoked.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T040849Z">
        <seg>末端処理が開始した場合、ストリームパイプラインは末端処理が呼び出されたストリームのモードに従って逐次的または並列に実行される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the terminal operation is initiated, the stream pipeline is executed sequentially or in parallel depending on the orientation of the stream on which it is invoked.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T040217Z">
        <seg>末端処理が開始した場合、ストリームパイプラインは末端処理が呼び出されたストリームの方針に従って逐次的または並列に実行される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whether a stream will execute in serial or parallel can be determined with the {@code isParallel()} method, and the orientation of a stream can be modified with the {@link java.util.stream.BaseStream#sequential()} and {@link java.util.stream.BaseStream#parallel()} operations.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T040315Z">
        <seg>{@code Stream}が逐次的に実行されるか並列に実行されるかは{@code Stream#isParallel}によって決定でき、ストリームの方針は{@code sequential()}処理や{@code parallel()}処理によって変更できる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whether or not a stream has an encounter order depends on the source and the intermediate operations.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T091052Z">
        <seg>出現順順序の有無は情報源と中間処理によって決まる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While collections have a finite size, streams need not.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T024750Z">
        <seg>コレクションは有限の大きさを持つが、ストリームはその必要はない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While such a spliterator will work, it will likely offer poor parallel performance, since we have lost sizing information (how big is the underlying data set), as well as being constrained to a simplistic splitting algorithm.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T025205Z">
        <seg>このようなスプリッテレータは動作するものの、貧弱な並列演算性能を示すだろう。なぜなら大きさに関する情報(元となるデータセットがどの程度大きいのか)を失なってしまうし、単純な分割アルゴリスムしか使えないためである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While this may seem a more roundabout way to perform an aggregation compared to simply mutating a running total in a loop, reduction operations parallelize more gracefully, without needing additional synchronization and with greatly reduced risk of data races.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T074606Z">
        <seg>単純に累計量をループで変更させていく方法と比べて、集計の方法としては回りくどいやりかたのように見えるが、簡約処理は余分な同期処理を必要とせずにうまく並列化でき、データ競合の危険を大幅に減らせる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While {@code limit()} is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of {@code maxSize}, since {@code limit(n)} is constrained to return not just any n elements, but the first n elements in the encounter order.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T072734Z">
        <seg>{@code limit()}は一般的に逐次ストリームパイプラインにおいては安価な処理であるが、順序を持つ並列パイプラインにおいては、特に{@code maxSize}が大きい場合は非常に高価な処理となる場合がある。{@code limit(n)}は単にn要素を返すというだけでなく最初のn要素を返す必要があるためである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While {@code skip()} is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of {@code n}, since {@code skip(n)} is constrained to skip not just any n elements, but the first n elements in the encounter order.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T073127Z">
        <seg>{@code skip()}は一般的に逐次ストリームパイプラインにおいては安価な処理であるが、順序を持つ並列パイプラインにおいては、特に{@code n}が大きい場合は非常に高価な処理となる場合がある。{@code skip(n)}は単にn要素以外を返すというだけでなく最初のn要素以外を返す必要があるためである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With some complex reduction operations, for example a {@code collect()} that produces a {@code Map}, such as:</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T015518Z">
        <seg>例えば次のような{@code Map}を生成する{@code collect()}のように、複雑な簡約処理について考える。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can ensure the stream is unordered by using the {@link java.util.stream.BaseStream#unordered()} method.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T020230Z">
        <seg>{@link java.util.stream.BaseStream#unordered()}メソッドを使うとストリームが順序を持たないことを保障できる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a  non-interfering action to perform on the elements</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T073517Z">
        <seg>各要素に適用する非干渉的アクション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a  non-interfering action to perform on the elements as they are consumed from the stream</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T072436Z">
        <seg>このストリームから要素が消費される際にその要素に適用される、非干渉的なアクション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a non-interfering, stateless function to apply to each element</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T065356Z">
        <seg>各要素に適用する非干渉的で状態を持たない関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a non-interfering, stateless function to apply to each element which produces a stream of new values</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T070335Z">
        <seg>各要素に適用する非干渉的で状態を持たず新しい値のストリームを生成する関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a non-interfering, stateless function to apply to each element which produces a {@code DoubleStream} of new values</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T093151Z">
        <seg>各要素に適用する非干渉的で状態を持たず新しい値の{@code DoubleStream}を生成する関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a non-interfering, stateless function to apply to each element which produces a {@code LongStream} of new values</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T085815Z">
        <seg>各要素に適用する非干渉的で状態を持たず新しい値の{@code LongStream}を生成する関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a non-interfering, stateless function to apply to each element which produces an {@code IntStream} of new values</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T092255Z">
        <seg>各要素に適用する非干渉的で状態を持たず新しい値の{@code IntStream}を生成する関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a non-interfering, stateless predicate to apply to each element to determine if it should be included</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T065228Z">
        <seg>各要素に適用して、要素を含むべきかどうか決めるための非干渉的で状態を持たない述語</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a non-interfering, stateless predicate to apply to elements of this stream</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T081945Z">
        <seg>このストリームの要素に適用する、非干渉的で状態を持たない述語</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a non-interfering, stateless {@code Comparator} to be used to compare stream elements</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T071718Z">
        <seg>ストリームの要素を比較するのに使う非干渉的で状態を持たない{@code Comparator}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a non-interfering, stateless {@code Comparator} to compare elements of this stream</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T081427Z">
        <seg>このストリームの要素を比較するための、非干渉的で状態を持たない{@code Comparator}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a classifier function mapping input elements to keys</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T033310Z">
        <seg>入力要素をキーに写像する分類関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a collector</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T023033Z">
        <seg>コレクタ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a collector which applies the mapping function to the input elements and provides the mapped results to the downstream collector</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T022735Z">
        <seg>入力要素に写像関数を適用して写像した結果を下流のコレクタに提供するコレクタ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a collector which performs the action of the downstream collector, followed by an additional finishing step</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T023158Z">
        <seg>下流のコレクタによるアクションと、追加で仕上げ段階を実行するコレクタ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a collector which will accept mapped values</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T022719Z">
        <seg>写像された値を受理するコレクタ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a concurrent, unordered {@code Collector} implementing the cascaded group-by operation</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T035733Z">
        <seg>カスケードされたgroup-by処理を実装した並行で順序を持たない{@code Collector}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a concurrent, unordered {@code Collector} implementing the group-by operation</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T035016Z">
        <seg>group-by処理を実装した並行で順序を持たない{@code Collector}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a concurrent, unordered {@code Collector} which collects elements into a {@code ConcurrentMap} whose keys are the result of applying a key mapping function to the input elements, and whose values are the result of applying a value mapping function to all input elements equal to the key and combining them using the merge function</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T050713Z">
        <seg>キーに写像する関数の結果をキーとし、値に写像する関数の値の結果を、キーが同じになる値全てを併合関数で併合した結果を値として、要素を{@code ConcurrentMap}に集める並行で順序を持たない{@code Collector}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a concurrent, unordered {@code Collector} which collects elements into a {@code ConcurrentMap} whose keys are the result of applying a key mapping function to the input elements, and whose values are the result of applying a value mapping function to the input elements</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T050619Z">
        <seg>キーに写像する関数を入力要素に適用した結果をキーとし、値に写像する関数を入力要素に適用した結果を値として、要素を{@code ConcurrentMap}に集める並行で順序を持たない{@code Collector}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a function extracting the property to be summed</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T023831Z">
        <seg>和を計算する特性を抽出する関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a function that creates a new result container.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T080532Z">
        <seg>新しい結果コンテナを作成する関数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a function to be applied to the final result of the downstream collector</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T023111Z">
        <seg>下流のコレクタの最終結果に適用される関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a function to be applied to the input elements</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T022713Z">
        <seg>入力要素に適用される関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a function to be applied to to the previous element to produce a new element</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T083750Z">
        <seg>新しい要素を生成するために以前の値に適用される関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a function which combines two partial results into a combined result</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T072710Z">
        <seg>部分的な結果を2つ取ってそれらを統合結果に併合する関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a function which folds a value into a mutable result container</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T072508Z">
        <seg>値を可変な結果コンテナに折り畳む関数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a function which produces a new array of the desired type and the provided length</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T074319Z">
        <seg>与えられた長さの要求された型の配列を生成する関数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a function which returns a new, empty {@code Map} into which the results will be inserted</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T050259Z">
        <seg>結果を挿入するための、新しい空の{@code Map}を返す関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a function which returns a new, mutable result container</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T072433Z">
        <seg>新しい可変な結果コンテナを返す関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a function which transforms the intermediate result to the final result</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T073015Z">
        <seg>中間結果を最終結果に変換する関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a function which, when called, produces a new empty {@code ConcurrentMap} of the desired type</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T035823Z">
        <seg>呼ばれた際に新しく適切な型の空の{@code ConcurrentMap}を返す関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a function which, when called, produces a new empty {@code Map} of the desired type</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T033659Z">
        <seg>呼ばれた際に新しく適切な型の空の{@code Map}を返す関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a mapping function to apply to each element</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T051031Z">
        <seg>各要素に適用する写像関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a mapping function to apply to each input value</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T031553Z">
        <seg>各入力要素に適用される写像関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a mapping function to produce keys</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T040556Z">
        <seg>キーを生成する写像関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a mapping function to produce values</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T040604Z">
        <seg>値を生成する写像関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a merge function, used to resolve collisions between values associated with the same key, as supplied to {@link Map#merge(Object, Object, BiFunction)}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T041630Z">
        <seg>{@link Map#merge(Object, Object, BiFunction)}に与えられる関数と同様に、同じキーに割り当てられた値の衝突を解決する併合関数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a new infinite sequential unordered {@code DoubleStream}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T095412Z">
        <seg>新しい逐次的で順序を持たない無限{@code DoubleStream}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a new infinite sequential unordered {@code IntStream}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T092937Z">
        <seg>新しい逐次的で順序を持たない無限{@code IntStream}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a new infinite sequential unordered {@code LongStream}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T091758Z">
        <seg>新しい逐次的で順序を持たない無限{@code LongStream}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a new infinite sequential unordered {@code Stream}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T083926Z">
        <seg>新しい逐次的で順序を持たない無限{@code Stream}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a new sequential or parallel {@code DoubleStream}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T041932Z">
        <seg>新しい逐次あるいは並列{@code DoubleStream}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a new sequential or parallel {@code IntStream}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T041346Z">
        <seg>新しい逐次あるいは並列{@code IntStream}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a new sequential or parallel {@code LongStream}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T041625Z">
        <seg>新しい逐次あるいは並列{@code LongStream}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a new sequential or parallel {@code Stream}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T040050Z">
        <seg>新しい逐次あるいは並列{@code Stream}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a new sequential {@code DoubleStream}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T095348Z">
        <seg>新しい逐次的な{@code DoubleStream}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a new sequential {@code LongStream}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T091724Z">
        <seg>新しい逐次的な{@code LongStream}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a new sequential {@code Stream}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T083754Z">
        <seg>新しい逐次的な{@code Stream}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a op b op c op d == (a op b) op (c op d)
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032833Z">
        <seg>a op b op c op d == (a op b) op (c op d)
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a parallel stream</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T075911Z">
        <seg>並列ストリーム</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a predicate used for classifying input elements</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T035910Z">
        <seg>入力要素を分類する述語</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a sequential stream</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T075741Z">
        <seg>逐次的なストリーム</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a sequential {@code IntStream} for the range of {@code int} elements</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T093008Z">
        <seg>{@code int}要素の範囲に対する逐次的な{@code IntStream}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a sequential {@code LongStream} for the range of {@code long} elements</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T091932Z">
        <seg>{@code long}要素の範囲に対する逐次的な{@code LongStream}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a singleton sequential stream</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T083556Z">
        <seg>1つの要素を含む逐次的なストリーム</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a stream builder</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T083527Z">
        <seg>ストリームのビルダ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a stream with a handler that is run if the stream is closed</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T080632Z">
        <seg>ストリームが閉じられた際に実行されるハンドラを伴なうストリーム</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a {@code BinaryOperator&lt;T&gt;} used to reduce the input elements</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T025149Z">
        <seg>入力要素を簡約するために使う{@code BinaryOperator&lt;T&gt;}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a {@code BinaryOperator&lt;U&gt;} used to reduce the mapped values</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T031633Z">
        <seg>写像後の値を簡約するために使う{@code BinaryOperator&lt;U&gt;}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a {@code Collector} implementing the cascaded group-by operation</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T033426Z">
        <seg>カスケードされた"group by"処理を実装する{@code Collector}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a {@code Collector} implementing the cascaded partitioning operation</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T040114Z">
        <seg>カスケードされた分割処理を実装する{@code Collector}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a {@code Collector} implementing the downstream reduction</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T033344Z">
        <seg>下流の簡約を実装する{@code Collector}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a {@code Collector} implementing the group-by operation</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032346Z">
        <seg>group-by処理を実装した{@code Collector}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a {@code Collector} implementing the map-reduce operation</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T031645Z">
        <seg>写像・簡約操作を実装する{@code Collector}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a {@code Collector} implementing the partitioning operation</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T035914Z">
        <seg>分割処理を実装した{@code Collector}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a {@code Collector} implementing the summary-statistics reduction</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T051041Z">
        <seg>要約統計簡約を実装する{@code Collector}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a {@code Collector} that concatenates the input elements into a {@code String}, in encounter order</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140213T122128Z">
        <seg>入力要素を出現順に{@link String}に連結する{@code Collector}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a {@code Collector} that counts the input elements</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T023305Z">
        <seg>入力要素数を数える{@code Collector}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a {@code Collector} that produces the maximal value</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T023618Z">
        <seg>最大値を生成する{@code Collector}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a {@code Collector} that produces the minimal value</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T023558Z">
        <seg>最小値を生成する{@code Collector}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a {@code Collector} that produces the sum of a derived property</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T023836Z">
        <seg>得られた特性の和を計算する{@code Collector}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a {@code Collector} which collects all the input elements into a {@code Collection}, in encounter order</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140213T121515Z">
        <seg>全ての入力要素を出現順に{@code Collection}に収集する{@code Collector}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a {@code Collector} which collects all the input elements into a {@code List}, in encounter order</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140213T121605Z">
        <seg>全ての入力要素を出現順に{@code List}に収集する{@code Collector}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a {@code Collector} which collects all the input elements into a {@code Set}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140213T122018Z">
        <seg>全ての入力要素を{@code Set}に収集する{@code Collector}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a {@code Collector} which collects elements into a {@code Map} whose keys and values are the result of applying mapping functions to the input elements</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T040638Z">
        <seg>写像関数の結果をキーと値として、入力要素を{@code Map}に累積する{@code Collector}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a {@code Collector} which collects elements into a {@code Map} whose keys are the result of applying a key mapping function to the input elements, and whose values are the result of applying a value mapping function to all input elements equal to the key and combining them using the merge function</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T041647Z">
        <seg>キーに写像する関数の結果をキーとし、値に写像する関数の値の結果を、キーが同じになる値全てを併合関数で併合した結果を値として、要素を{@code Map}に集める{@code Collector}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a {@code Collector} which implements the reduction operation</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T025156Z">
        <seg>簡約操作を実装する{@code Collector}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a {@code Comparator} for comparing elements</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T023542Z">
        <seg>要素を比較するための{@code Comparator}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a {@code DoubleStream} consisting of the elements of this stream, converted to {@code double}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T091554Z">
        <seg>このストリームの要素を{@code double}に変換した要素からなる{@code DoubleStream}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a {@code DoubleSummaryStatistics} describing various summary data about the elements of this stream</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T095020Z">
        <seg>このストリームの要素の各種概要情報を表す{@code DoubleSummaryStatistics}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a {@code LongStream} consisting of the elements of this stream, converted to {@code long}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T092803Z">
        <seg>このストリームの要素を{@code long}に変換した要素からなる{@code LongStream}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a {@code LongSummaryStatistics} describing various summary data about the elements of this stream</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T091403Z">
        <seg>このストリームの要素の各種概要情報を表す{@code LongSummaryStatistics}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a {@code Spliterator.OfInt} describing the stream elements</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T041336Z">
        <seg>ストリーム要素を表す{@code Spliterator.OfInt}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a {@code Spliterator.OfLong} describing the stream elements</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T041619Z">
        <seg>ストリーム要素を表す{@code Spliterator.OfLong}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a {@code Spliterator} describing the stream elements</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T035932Z">
        <seg>ストリーム要素を表す{@code Spliterator}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a {@code Stream} consistent of the elements of this stream, each boxed to a {@code Double}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T095245Z">
        <seg>このストリームの要素を{@code Double}にボックス化した要素からなる{@code Stream}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a {@code Stream} consistent of the elements of this stream, each boxed to an {@code Integer}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T092825Z">
        <seg>このストリームの要素を{@code Integer}にボックス化した要素からなる{@code Stream}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a {@code Stream} consistent of the elements of this stream, each boxed to {@code Long}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T091605Z">
        <seg>このストリームの要素を{@code Long}にボックス化した要素からなる{@code Stream}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a {@code Supplier} of a {@code Spliterator.OfInt}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T042049Z">
        <seg>{@code Spliterator.OfInt}の{@code Supplier}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a {@code Supplier} of a {@code Spliterator.OfLong}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T042106Z">
        <seg>{@code Spliterator.OfLong}の{@code Supplier}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a {@code Supplier} of a {@code Spliterator}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T040519Z">
        <seg>{@code Spliterator}の{@code Supplier}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a {@code Supplier} which returns a new, empty {@code Collection} of the appropriate type</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140213T121504Z">
        <seg>新しく適切な型の空の{@code Collection}を返す{@code Supplier}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>accept(t)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032901Z">
        <seg>accept(t)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>accumulator.accept(a1, t1);</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032825Z">
        <seg>accumulator.accept(a1, t1);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>accumulator.accept(a1, t2);</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032826Z">
        <seg>accumulator.accept(a1, t2);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>accumulator.accept(a2, t1);</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032827Z">
        <seg>accumulator.accept(a2, t1);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>accumulator.accept(a3, t2);</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032828Z">
        <seg>accumulator.accept(a3, t2);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>accumulator.accept(result, element);</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032854Z">
        <seg>accumulator.accept(result, element);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>an associative, non-interfering, stateless function for combining two values</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T074654Z">
        <seg>2つの値を統合するための、結合的で非干渉的で状態を持たない関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>an associative, non-interfering, stateless function for combining two values, which must be compatible with the accumulator function</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T075620Z">
        <seg>2つの値を統合するための、結合的で非干渉的で状態を持たない関数。累積関数と整合する必要がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>an associative, non-interfering, stateless function for incorporating an additional element into a result</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T075559Z">
        <seg>結果に追加の要素を組み入れるための、結合的で非干渉的で状態を持たない関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>an array containing the elements in this stream</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T074325Z">
        <seg>このストリームの要素からなる配列</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>an array containing the elements of this stream</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T074004Z">
        <seg>このストリームの要素からなる配列</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>an empty sequential stream</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T083540Z">
        <seg>空の逐次的ストリーム</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>an immutable set of collector characteristics</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T073116Z">
        <seg>コレクタの特性の不変な集合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>an unordered stream</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T080024Z">
        <seg>順序を持たないストリーム</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>an {@code IntSummaryStatistics} describing various summary data about the elements of this stream</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T092610Z">
        <seg>このストリームの要素の各種概要情報を表す{@code IntSummaryStatistics}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>an {@code OptionalDouble} containing the average element of this stream, or an empty optional if the stream is empty</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T091259Z">
        <seg>このストリームの算術平均を含む{@code Optional}Double、またはこのストリームが空ならば空の{@code OptionalDouble}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>an {@code OptionalDouble} containing the maximum element of this stream, or an empty optional if the stream is empty</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T094611Z">
        <seg>このストリームの最大要素を含む{@code OptionalDouble}、またはこのストリームが空ならば空の{@code OptionalDouble}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>an {@code OptionalDouble} containing the minimum element of this stream, or an empty optional if the stream is empty</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T094422Z">
        <seg>このストリームの最小要素を含む{@code OptionalDouble}、またはこのストリームが空ならば空の{@code OptionalDouble}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>an {@code OptionalDouble} describing some element of this stream, or an empty {@code OptionalDouble} if the stream is empty</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T095222Z">
        <seg>このストリームのある要素を表す{@code OptionalDouble}、またはこのストリームが空ならば空の{@code OptionalDouble}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>an {@code OptionalDouble} describing the first element of this stream, or an empty {@code OptionalDouble} if the stream is empty</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T095104Z">
        <seg>このストリームの最初の要素を表す{@code OptionalDouble}、またはこのストリームが空ならば空の{@code OptionalDouble}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>an {@code OptionalInt} containing the maximum element of this stream, or an empty {@code OptionalInt} if the stream is empty</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T092542Z">
        <seg>このストリームの最大要素を含む{@code OptionalInt}、またはこのストリームが空ならば空の{@code OptionalInt}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>an {@code OptionalInt} containing the minimum element of this stream, or an empty {@code OptionalInt} if the stream is empty</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T092508Z">
        <seg>このストリームの最小要素を含む{@code OptionalInt}、またはこのストリームが空ならば空の{@code OptionalInt}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>an {@code OptionalInt} describing some element of this stream, or an empty {@code OptionalInt} if the stream is empty</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T092729Z">
        <seg>このストリームのある要素を表す{@code OptionalInt}、またはこのストリームが空ならば空の{@code OptionalInt}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>an {@code OptionalInt} describing the first element of this stream, or an empty {@code OptionalInt} if the stream is empty</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T092655Z">
        <seg>このストリームの最初の要素を表す{@code OptionalInt}、またはこのストリームが空ならば空の{@code OptionalInt}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>an {@code OptionalLong} containing the maximum element of this stream, or an empty {@code OptionalLong} if the stream is empty</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T091125Z">
        <seg>このストリームの最大要素を含む{@code OptionalLong}、またはこのストリームが空ならば空の{@code OptionalLong}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>an {@code OptionalLong} containing the minimum element of this stream, or an empty {@code OptionalLong} if the stream is empty</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T091100Z">
        <seg>このストリームの最小要素を含む{@code OptionalLong}、またはこのストリームが空ならば空の{@code OptionalLong}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>an {@code OptionalLong} describing some element of this stream, or an empty {@code OptionalLong} if the stream is empty</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T091458Z">
        <seg>このストリームのある要素を表す{@code OptionalLong}、またはこのストリームが空ならば空の{@code OptionalLong}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>an {@code OptionalLong} describing the first element of this stream, or an empty {@code OptionalLong} if the stream is empty</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T091432Z">
        <seg>このストリームの最初の要素を表す{@code OptionalLong}、またはこのストリームが空ならば空の{@code OptionalLong}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>an {@code Optional} describing some element of this stream, or an empty {@code Optional} if the stream is empty</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T083509Z">
        <seg>このストリームのある要素を表す{@code Optional}、またはこのストリームが空ならば空の{@code Optional}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>an {@code Optional} describing the first element of this stream, or an empty {@code Optional} if the stream is empty</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T083143Z">
        <seg>このストリームの最初の要素を表す{@code Optional}、またはこのストリームが空ならば空の{@code Optional}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>an {@code Optional} describing the maximum element of this stream, or an empty {@code Optional} if the stream is empty</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T081516Z">
        <seg>このストリームの最大要素を表す{@code Optional}、またはこのストリームが空ならば空の{@code Optional}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>an {@code Optional} describing the minimum element of this stream, or an empty {@code Optional} if the stream is empty</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T081442Z">
        <seg>このストリームの最小要素を表す{@code Optional}、またはこのストリームが空ならば空の{@code Optional}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>an {@link Optional} describing the result of the reduction</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T074837Z">
        <seg>簡約の結果を表す{@link Optional}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>boolean foundAny = false;</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032846Z">
        <seg>boolean foundAny = false;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>but in some cases equivalence may be relaxed to account for differences in order.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T015311Z">
        <seg>ただし、ある場合には等価性は順序の違いを考慮するように緩めることもある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>but is not constrained to execute sequentially.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T074428Z">
        <seg>ただし逐次的に実行されるとは制約されていない。 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>collector.accumulator().accept(container, t);</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T070455Z">
        <seg>collector.accumulator().accept(container, t);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>combiner.apply(u, accumulator.apply(identity, t)) == accumulator.apply(u, t)
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032853Z">
        <seg>combiner.apply(u, accumulator.apply(identity, t)) == accumulator.apply(u, t)
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>combining two result containers into one ( {@link #combiner()})</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T052557Z">
        <seg>2つの結果コンテナの1つの結果コンテナへの統合({@link #combiner()})</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>creation of a new result container ( {@link #supplier()})</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T052406Z">
        <seg>新しい結果コンテナの作成({@link #supplier()})</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>double result = identity;</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032924Z">
        <seg>double result = identity;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>double result = null;</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032926Z">
        <seg>double result = null;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>double sum = numbers.reduce(0, (a, b) -&gt; a+b);
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032925Z">
        <seg>double sum = numbers.reduce(0, (a, b) -&gt; a+b);
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>double sum = numbers.reduce(0, Double::sum);
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032925Z">
        <seg>double sum = numbers.reduce(0, Double::sum);
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>double sum = widgets.stream()</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032922Z">
        <seg>double sum = widgets.stream()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>element type for the input and output of the reduction</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T025136Z">
        <seg>簡約の入力と出力の要素型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>else</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032849Z">
        <seg>else</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for (T element : stream) {</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032815Z">
        <seg>for (T element : stream) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for (T element : this stream)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032844Z">
        <seg>for (T element : this stream)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for (T element : this stream) {</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032847Z">
        <seg>for (T element : this stream) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for (T t : data)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T070453Z">
        <seg>for (T t : data)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for (double element : this stream)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032924Z">
        <seg>for (double element : this stream)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for (double element : this stream) {</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032926Z">
        <seg>for (double element : this stream) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for (int element : this stream)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032916Z">
        <seg>for (int element : this stream)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for (int element : this stream) {</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032918Z">
        <seg>for (int element : this stream) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for (int i = startInclusive; i &lt; endExclusive ; i++) { ... }
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032921Z">
        <seg>for (int i = startInclusive; i &lt; endExclusive ; i++) { ... }
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for (int i = startInclusive; i &lt;= endInclusive ; i++) { ... }
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032922Z">
        <seg>for (int i = startInclusive; i &lt;= endInclusive ; i++) { ... }
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for (int x : numbers) {</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032753Z">
        <seg>for (int x : numbers) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for (long element : this stream)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032906Z">
        <seg>for (long element : this stream)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for (long element : this stream) {</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032910Z">
        <seg>for (long element : this stream) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for (long i = startInclusive; i &lt; endExclusive ; i++) { ... }
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032913Z">
        <seg>for (long i = startInclusive; i &lt; endExclusive ; i++) { ... }
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for (long i = startInclusive; i &lt;= endInclusive ; i++) { ... }
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032914Z">
        <seg>for (long i = startInclusive; i &lt;= endInclusive ; i++) { ... }
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>foundAny = true;</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032848Z">
        <seg>foundAny = true;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>groupingBy(classifier, toList());
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032003Z">
        <seg>groupingBy(classifier, toList());
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>groupingByConcurrent(classifier, toList());
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T034955Z">
        <seg>groupingByConcurrent(classifier, toList());
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (!foundAny) {</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032847Z">
        <seg>if (!foundAny) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if any argument is null</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T073751Z">
        <seg>いずれかの引数がnullの場合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if the builder has already transitioned to the built state</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T085200Z">
        <seg>ビルダが既に構築済状態に移行している場合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if the element selected is null</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T083207Z">
        <seg>選択された要素がnullの場合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if the maximum element is null</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T081523Z">
        <seg>最大要素がnullの場合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if the minimum element is null</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T081458Z">
        <seg>最小要素がnullの場合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if the result of the reduction is null</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T074855Z">
        <seg>簡約の結果がnullの場合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if the runtime type of the array returned from the array generator is not a supertype of the runtime type of every element in this stream</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T074332Z">
        <seg>配列生成関数から返された配列の実行時型がこのストリームの全ての要素の部分型でない場合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if {@code maxSize} is negative</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T072907Z">
        <seg>{@code maxSize}が負の場合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if {@code n} is negative</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T073207Z">
        <seg>{@code n}が負の場合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if {@code true} then the returned stream is a parallel stream; if {@code false} the returned stream is a sequential stream.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T040020Z">
        <seg>もし{@code true}であれば、返されるストリームは並列ストリームである。もし{@code false}であれば、返されるストリームは逐次ストリームである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>in most cases must be stateless (their result should not depend on any state that might change during execution of the stream pipeline).</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T063458Z">
        <seg>ほとんどの場合状態を持たない必要がある (結果がそのストリームパイプラインの実行中に変化する可能性がある状態に依存してはならない)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>incorporating a new data element into a result container ( {@link #accumulator()})</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T052545Z">
        <seg>新しいデータ要素の結果コンテナへの組み入れ({@link #accumulator()})</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>int result = identity;</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032916Z">
        <seg>int result = identity;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>int result = null;</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032918Z">
        <seg>int result = null;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>int sum = 0;</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032753Z">
        <seg>int sum = 0;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>int sum = integers.reduce(0, (a, b) -&gt; a+b);
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032917Z">
        <seg>int sum = integers.reduce(0, (a, b) -&gt; a+b);
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>int sum = integers.reduce(0, Integer::sum);
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032917Z">
        <seg>int sum = integers.reduce(0, Integer::sum);
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>int sum = numbers.parallelStream().reduce(0, Integer::sum);
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032800Z">
        <seg>int sum = numbers.parallelStream().reduce(0, Integer::sum);
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>int sum = numbers.stream().reduce(0, (x,y) -&gt; x+y);
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032756Z">
        <seg>int sum = numbers.stream().reduce(0, (x,y) -&gt; x+y);
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>int sum = numbers.stream().reduce(0, Integer::sum);
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032759Z">
        <seg>int sum = numbers.stream().reduce(0, Integer::sum);
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>int sum = widgets.stream()</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032734Z">
        <seg>int sum = widgets.stream()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>int sumOfWeights = widgets.stream()</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032807Z">
        <seg>int sumOfWeights = widgets.stream()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>int sumOfWeights = widgets.}parallelStream() {@code</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032739Z">
        <seg>int sumOfWeights = widgets.}parallelStream() {@code</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>int total = employees.stream()</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032932Z">
        <seg>int total = employees.stream()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>intermediate accumulation type of the downstream collector</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T022627Z">
        <seg>下流のコレクタが中間的に累積する値の型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>it may actually be counterproductive to perform the operation in parallel.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T015535Z">
        <seg>この処理を並列に実行するのは実際には逆効果である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>java.util.stream</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032836Z">
        <seg>java.util.stream</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>l.add("three");</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032743Z">
        <seg>l.add("three");</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>long result = identity;</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032906Z">
        <seg>long result = identity;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>long result = null;</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032909Z">
        <seg>long result = null;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>long sum = integers.reduce(0, (a, b) -&gt; a+b);
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032907Z">
        <seg>long sum = integers.reduce(0, (a, b) -&gt; a+b);
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>long sum = integers.reduce(0, Long::sum);
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032907Z">
        <seg>long sum = integers.reduce(0, Long::sum);
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>long sum = widgets.stream()</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032902Z">
        <seg>long sum = widgets.stream()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>mapping(Person::getLastName, toSet())));
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032937Z">
        <seg>mapping(Person::getLastName, toSet())));
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>must be non-interfering (they do not modify the stream source); and</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T062722Z">
        <seg>非干渉的(non-interfering)である (情報源を変更しない)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or more compactly:</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T090231Z">
        <seg>もしくはより簡潔に次のようにできる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or, pulling the mapping operation out of the accumulator function, we could express it more succinctly as:</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T012446Z">
        <seg>もしくは、写像処理を累積関数から抜き出すとさらに簡潔に次のように書ける。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or:</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140210T125446Z">
        <seg>あるいは次のようにも書ける。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>orders.flatMap(order -&gt; order.getLineItems().stream())...
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032837Z">
        <seg>orders.flatMap(order -&gt; order.getLineItems().stream())...
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>people.stream().collect(toConcurrentMap(Person::getName,</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T050644Z">
        <seg>people.stream().collect(toConcurrentMap(Person::getName,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>people.stream().collect(toMap(Person::getName,</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T041511Z">
        <seg>people.stream().collect(toMap(Person::getName,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>performing an optional final transform on the container ( {@link #finisher()})</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T052629Z">
        <seg>コンテナに対する追加可能な最終的な変換({@link #finisher()})</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>reducing(0L, e -&gt; 1L, Long::sum)
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032938Z">
        <seg>reducing(0L, e -&gt; 1L, Long::sum)
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>reducing(BinaryOperator.maxBy(comparator))
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032939Z">
        <seg>reducing(BinaryOperator.maxBy(comparator))
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>reducing(BinaryOperator.minBy(comparator))
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032938Z">
        <seg>reducing(BinaryOperator.minBy(comparator))
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>reducing(Person::getLastName, BinaryOperator.maxBy(byLength))));
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T031507Z">
        <seg>reducing(Person::getLastName, BinaryOperator.maxBy(byLength))));
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>result = accumulator.apply(result, element)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032844Z">
        <seg>result = accumulator.apply(result, element)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>result = accumulator.apply(result, element);</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032850Z">
        <seg>result = accumulator.apply(result, element);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>result = accumulator.applyAsDouble(result, element)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032925Z">
        <seg>result = accumulator.applyAsDouble(result, element)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>result = accumulator.applyAsDouble(result, element);</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032927Z">
        <seg>result = accumulator.applyAsDouble(result, element);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>result = accumulator.applyAsInt(result, element)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032917Z">
        <seg>result = accumulator.applyAsInt(result, element)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>result = accumulator.applyAsInt(result, element);</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032919Z">
        <seg>result = accumulator.applyAsInt(result, element);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>result = accumulator.applyAsLong(result, element)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032906Z">
        <seg>result = accumulator.applyAsLong(result, element)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>result = accumulator.applyAsLong(result, element);</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032910Z">
        <seg>result = accumulator.applyAsLong(result, element);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>result = element;</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032848Z">
        <seg>result = element;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>result type of collector</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T022659Z">
        <seg>コレクタの結果型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>result type of the downstream collector</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T023012Z">
        <seg>下流のコレクタの結果型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>result type of the resulting collector</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T023027Z">
        <seg>返されるコレクタの結果型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return collector.finisher().apply(container);
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T070458Z">
        <seg>return collector.finisher().apply(container);
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return foundAny ?</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032850Z">
        <seg>return foundAny ?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return map(e -&gt; 1L).sum();
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032913Z">
        <seg>return map(e -&gt; 1L).sum();
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return mapToLong(e -&gt; 1L).sum();
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032859Z">
        <seg>return mapToLong(e -&gt; 1L).sum();
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return reduce(0, Double::sum);
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032928Z">
        <seg>return reduce(0, Double::sum);
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return reduce(0, Integer::sum);
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032920Z">
        <seg>return reduce(0, Integer::sum);
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return reduce(0, Long::sum);
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032912Z">
        <seg>return reduce(0, Long::sum);
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return reduce(Double::max);
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032928Z">
        <seg>return reduce(Double::max);
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return reduce(Double::min);
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032928Z">
        <seg>return reduce(Double::min);
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return reduce(Integer::max);
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032921Z">
        <seg>return reduce(Integer::max);
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return reduce(Integer::min);
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032920Z">
        <seg>return reduce(Integer::min);
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return reduce(Long::max);
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032913Z">
        <seg>return reduce(Long::max);
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return reduce(Long::min);
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032912Z">
        <seg>return reduce(Long::min);
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return result;
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032844Z">
        <seg>return result;
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return this;
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032901Z">
        <seg>return this;
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>stream.filter(s -&gt; pattern.matcher(s).matches())</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032747Z">
        <seg>stream.filter(s -&gt; pattern.matcher(s).matches())</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>stream.parallel().map(e -&gt; { if (seen.add(e)) return 0; else return e; })...
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032745Z">
        <seg>stream.parallel().map(e -&gt; { if (seen.add(e)) return 0; else return e; })...
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>strings.add(element.toString());</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032815Z">
        <seg>strings.add(element.toString());</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>student -&gt; computeGPA(student)));
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T040334Z">
        <seg>student -&gt; computeGPA(student)));
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>students.stream()</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032936Z">
        <seg>students.stream()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>students.stream().collect(toConcurrentMap(Student::getId,</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T050443Z">
        <seg>students.stream().collect(toConcurrentMap(Student::getId,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>students.stream().collect(toMap(Functions.identity(),</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T040334Z">
        <seg>students.stream().collect(toMap(Functions.identity(),</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>students.stream().collect(toMap(Student::getId,</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T040345Z">
        <seg>students.stream().collect(toMap(Student::getId,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sum += x;</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032753Z">
        <seg>sum += x;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>summingSalaries));
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032824Z">
        <seg>summingSalaries));
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>super T, U&gt; accumulator,</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032804Z">
        <seg>super T, U&gt; accumulator,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>super T&gt; accumulator,</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032811Z">
        <seg>super T&gt; accumulator,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the (inclusive) initial value</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T091850Z">
        <seg>初期値(この値を含む)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the built stream</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T085227Z">
        <seg>構築されたストリーム</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the classifier function mapping input elements to keys</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032340Z">
        <seg>入力要素をキーに写像する分類関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the concatenation of the two input streams</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T084609Z">
        <seg>2つのストリームの連結</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the count of elements in this stream</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T081606Z">
        <seg>このストリームの要素数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the delimiter to be used between each element</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140213T122250Z">
        <seg>各要素の間に使われる区切り文字列</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the element iterator for this stream</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T075500Z">
        <seg>このストリームの要素イテレータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the element spliterator for this stream</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T075511Z">
        <seg>このストリームの要素スプリッテレータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the element to add</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T085111Z">
        <seg>追加する要素</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the element type of the new stream</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T085751Z">
        <seg>新しいストリーム要素の型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the element type of the resulting array</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T074303Z">
        <seg>結果の配列の要素型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the elements of the new stream</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T083614Z">
        <seg>新しいストリームの要素</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the exclusive upper bound</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T091858Z">
        <seg>この値を含まない上界</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the first stream</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T084544Z">
        <seg>1つ目のストリーム</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the identity value for the accumulating function</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T074617Z">
        <seg>累積関数の単位元</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the identity value for the combiner function</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T075536Z">
        <seg>統合関数の単位元</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the identity value for the reduction (also, the value that is returned when there are no input elements)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T025143Z">
        <seg>簡約の単位元(また、入力要素が無い場合に返される値)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the inclusive upper bound</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T092029Z">
        <seg>この値を含む上界</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the initial element</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T083740Z">
        <seg>初期要素</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the intermediate accumulation type of the downstream collector</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T033253Z">
        <seg>下流のコレクタが中間的に累積する値の型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the intermediate accumulation type of the {@code Collector}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T081316Z">
        <seg>{@code Collector}の中間的な累積の型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the mapping function to apply to each element</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T051057Z">
        <seg>各要素に適用する写像関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the mapping function to produce keys</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T050451Z">
        <seg>キーを生成する写像関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the mapping function to produce values</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T050457Z">
        <seg>値を生成する写像関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the mutable accumulation type of the reduction operation (often hidden as an implementation detail)</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T072321Z">
        <seg>簡約処理の可変な累積型(実装の詳細として隠される場合が多い)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the new stream</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T065237Z">
        <seg>新しいストリーム</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the new {@code Collector}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T073800Z">
        <seg>新しい{@code Collector}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the number of elements the stream should be limited to</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T072828Z">
        <seg>ストリームを制限する要素数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the number of leading elements to skip</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T073156Z">
        <seg>スキップする先頭の要素数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the output type of the key mapping function</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T040527Z">
        <seg>キーに写像する関数の出力型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the output type of the value mapping function</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T040545Z">
        <seg>値に写像する関数の出力型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the result of the reduction</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T074702Z">
        <seg>簡約の結果</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the result stream</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T093242Z">
        <seg>結果のストリーム</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the result type of the downstream reduction</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T033306Z">
        <seg>下流の簡約の結果型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the result type of the reduction operation</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T072330Z">
        <seg>簡約処理の結果型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the second stream</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T084539Z">
        <seg>2つ目のストリーム</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the sequence of characters to be used at the beginning of the joined result</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140213T122656Z">
        <seg>連結した結果の先頭に使われる文字の列</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the sequence of characters to be used at the end of the joined result</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140213T122705Z">
        <seg>連結した結果の末尾に使われる文字の列</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the single element</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T083551Z">
        <seg>1つの要素</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the sum of elements in this stream</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T090953Z">
        <seg>このストリームの要素の和</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the type of input elements to the reduction operation</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T072243Z">
        <seg>簡約処理の入力要素の型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the type of of the stream implementing {@code BaseStream}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T075419Z">
        <seg>{@code BaseStream}を実装したストリームの型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the type of stream elements</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T035918Z">
        <seg>ストリーム要素の型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the type of the input elements</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140213T121427Z">
        <seg>入力要素の型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the type of the keys</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032330Z">
        <seg>キーの型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the type of the mapped values</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T031520Z">
        <seg>写像後の値の型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the type of the result</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T081223Z">
        <seg>結果の型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the type of the resulting {@code Collection}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140213T121437Z">
        <seg>結果の{@code Collection}の型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the type of the resulting {@code ConcurrentMap}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T035811Z">
        <seg>結果の{@code ConcurrentMap}の型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the type of the resulting {@code Map}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T033630Z">
        <seg>結果の{@code Map}の型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the type of the stream elements</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T065043Z">
        <seg>ストリーム要素の型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the {@code Collector} describing the reduction</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T081321Z">
        <seg>簡約を表現する{@code Collector}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the {@code DoubleSupplier} for generated elements</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T095406Z">
        <seg>生成される要素の{@code DoubleSupplier}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the {@code IntSupplier} for generated elements</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T092928Z">
        <seg>生成される要素の{@code IntSupplier}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the {@code LongSupplier} for generated elements</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T091749Z">
        <seg>生成される要素の{@code LongSupplier}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the {@code Supplier} of generated elements</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T083905Z">
        <seg>生成される要素の{@code Supplier}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>though the explicit map-reduce form is more readable and therefore should usually be preferred.</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T011157Z">
        <seg>ただし明示的な写像・簡約(map-reduce)構成(訳註: {@code map}メソッドと{@code reduce}メソッドに分けて書く形式)の方がより読みやすく、したがって通常はそちらの方が好ましい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>type of elements</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T083523Z">
        <seg>要素の型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>type of elements accepted by downstream collector</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T022523Z">
        <seg>下流のコレクタによって受理される要素の型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>type of the result</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T080520Z">
        <seg>結果の型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{@code</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T031113Z">
        <seg>{@code</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{@code
&lt;R&gt; R collect(Supplier&lt;R&gt; supplier,</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032811Z">
        <seg>{@code
&lt;R&gt; R collect(Supplier&lt;R&gt; supplier,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{@code
&lt;U&gt; U reduce(U identity,</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032804Z">
        <seg>{@code
&lt;U&gt; U reduce(U identity,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{@code this} builder</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T085121Z">
        <seg>ビルダである{@code this}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{@code true} if any elements of the stream match the provided predicate, otherwise {@code false}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T082030Z">
        <seg>このストリームのある要素が与えられた述語に適合するならば{@code true}でそうでなければ{@code false}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{@code true} if either all elements of the stream match the provided predicate or the stream is empty, otherwise {@code false}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T082723Z">
        <seg>このストリームの全ての要素が与えられた述語に適合するならば{@code true}でそうでなければ{@code false}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{@code true} if either no elements of the stream match the provided predicate or the stream is empty, otherwise {@code false}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140211T083031Z">
        <seg>このストリームのど要素も与えられた述語に適合しないならば{@code true}でそうでなければ{@code false}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{@code true} if this stream would execute in parallel if executed</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T075658Z">
        <seg>もしこのストリームが実行された場合に並列に実行されるならば{@code true}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032748Z">
        <seg>}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>}
}</seg>
      </tuv>
      <tuv lang="JA" changeid="taku0" changedate="20140215T032754Z">
        <seg>}
}</seg>
      </tuv>
    </tu>
<!-- Alternative translations -->
  </body>
</tmx>
