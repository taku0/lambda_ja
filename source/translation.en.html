<!DOCTYPE html SYSTEM "about:legacy-compat">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="UTF-8"/>
    <title>Documents</title>
  </head>
  <body>
    <div data-type="documents" data-name="">
      <div data-type="package" data-name="java.util.stream">
        <div data-type="text">Classes to support functional-style operations on streams of elements, such as map-reduce transformations on collections.  For example: <pre> {@code
    int sum = widgets.stream()
                     .filter(b -&gt; b.getColor() == RED)
                     .mapToInt(b -&gt; b.getWeight())
                     .sum();
}</pre> <p>Here we use  {@code widgets}, a  {@code Collection&lt;Widget&gt;}, as a source for a stream, and then perform a filter-map-reduce on the stream to obtain the sum of the weights of the red widgets.  (Summation is an example of a <a href="package-summary.html#Reduction">reduction</a> operation.) </p><p>The key abstraction introduced in this package is <em>stream</em>.  The classes  {@link java.util.stream.Stream},  {@link java.util.stream.IntStream}, {@link java.util.stream.LongStream}, and  {@link java.util.stream.DoubleStream} are streams over objects and the primitive  {@code int},  {@code long} and {@code double} types.  Streams differ from collections in several ways: </p><ul> <li>No storage.  A stream is not a data structure that stores elements; instead, it conveys elements from a source such as a data structure, an array, a generator function, or an I/O channel, through a pipeline of computational operations.</li> <li>Functional in nature.  An operation on a stream produces a result, but does not modify its source.  For example, filtering a  {@code Stream} obtained from a collection produces a new  {@code Stream} without the filtered elements, rather than removing elements from the source collection.</li> <li>Laziness-seeking.  Many stream operations, such as filtering, mapping, or duplicate removal, can be implemented lazily, exposing opportunities for optimization.  For example, "find the first  {@code String} with three consecutive vowels" need not examine all the input strings. Stream operations are divided into intermediate ( {@code Stream}-producing) operations and terminal (value- or side-effect-producing) operations. Intermediate operations are always lazy.</li> <li>Possibly unbounded.  While collections have a finite size, streams need not.  Short-circuiting operations such as  {@code limit(n)} or {@code findFirst()} can allow computations on infinite streams to complete in finite time.</li> <li>Consumable. The elements of a stream are only visited once during the life of a stream. Like an  {@link java.util.Iterator}, a new stream must be generated to revisit the same elements of the source. </li> </ul> Streams can be obtained in a number of ways. Some examples include: <ul> <li>From a  {@link java.util.Collection} via the  {@code stream()} and {@code parallelStream()} methods;</li> <li>From an array via  {@link java.util.Arrays#stream(Object[])};</li> <li>From static factory methods on the stream classes, such as {@link java.util.stream.Stream#of(Object[])}, {@link java.util.stream.IntStream#range(int, int)} or  {@link java.util.stream.Stream#iterate(Object, UnaryOperator)};</li> <li>The lines of a file can be obtained from  {@link java.io.BufferedReader#lines()};</li> <li>Streams of file paths can be obtained from methods in  {@link java.nio.file.Files};</li> <li>Streams of random numbers can be obtained from  {@link java.util.Random#ints()};</li> <li>Numerous other stream-bearing methods in the JDK, including {@link java.util.BitSet#stream()}, {@link java.util.regex.Pattern#splitAsStream(java.lang.CharSequence)}, and  {@link java.util.jar.JarFile#stream()}.</li> </ul> <p>Additional stream sources can be provided by third-party libraries using <a href="package-summary.html#StreamSources">these techniques</a>. </p><h2><a name="StreamOps">Stream operations and pipelines</a></h2> <p>Stream operations are divided into <em>intermediate</em> and <em>terminal</em> operations, and are combined to form <em>stream pipelines</em>.  A stream pipeline consists of a source (such as a {@code Collection}, an array, a generator function, or an I/O channel); followed by zero or more intermediate operations such as {@code Stream.filter} or  {@code Stream.map}; and a terminal operation such as  {@code Stream.forEach} or  {@code Stream.reduce}. </p><p>Intermediate operations return a new stream.  They are always <em>lazy</em>; executing an intermediate operation such as {@code filter()} does not actually perform any filtering, but instead creates a new stream that, when traversed, contains the elements of the initial stream that match the given predicate.  Traversal of the pipeline source does not begin until the terminal operation of the pipeline is executed. </p><p>Terminal operations, such as  {@code Stream.forEach} or {@code IntStream.sum}, may traverse the stream to produce a result or a side-effect. After the terminal operation is performed, the stream pipeline is considered consumed, and can no longer be used; if you need to traverse the same data source again, you must return to the data source to get a new stream.  In almost all cases, terminal operations are <em>eager</em>, completing their traversal of the data source and processing of the pipeline before returning.  Only the terminal operations  {@code iterator()} and {@code spliterator()} are not; these are provided as an "escape hatch" to enable arbitrary client-controlled pipeline traversals in the event that the existing operations are not sufficient to the task. </p><p> Processing streams lazily allows for significant efficiencies; in a pipeline such as the filter-map-sum example above, filtering, mapping, and summing can be fused into a single pass on the data, with minimal intermediate state. Laziness also allows avoiding examining all the data when it is not necessary; for operations such as "find the first string longer than 1000 characters", it is only necessary to examine just enough strings to find one that has the desired characteristics without examining all of the strings available from the source. (This behavior becomes even more important when the input stream is infinite and not merely large.) </p><p>Intermediate operations are further divided into <em>stateless</em> and <em>stateful</em> operations. Stateless operations, such as  {@code filter} and  {@code map}, retain no state from previously seen element when processing a new element -- each element can be processed independently of operations on other elements.  Stateful operations, such as {@code distinct} and  {@code sorted}, may incorporate state from previously seen elements when processing new elements. </p><p>Stateful operations may need to process the entire input before producing a result.  For example, one cannot produce any results from sorting a stream until one has seen all elements of the stream.  As a result, under parallel computation, some pipelines containing stateful intermediate operations may require multiple passes on the data or may need to buffer significant data.  Pipelines containing exclusively stateless intermediate operations can be processed in a single pass, whether sequential or parallel, with minimal data buffering. </p><p>Further, some operations are deemed <em>short-circuiting</em> operations. An intermediate operation is short-circuiting if, when presented with infinite input, it may produce a finite stream as a result.  A terminal operation is short-circuiting if, when presented with infinite input, it may terminate in finite time.  Having a short-circuiting operation in the pipeline is a necessary, but not sufficient, condition for the processing of an infinite stream to terminate normally in finite time. </p><h3>Parallelism</h3> <p>Processing elements with an explicit  {@code for-}loop is inherently serial. Streams facilitate parallel execution by reframing the computation as a pipeline of aggregate operations, rather than as imperative operations on each individual element.  All streams operations can execute either in serial or in parallel. The stream implementations in the JDK create serial streams unless parallelism is explicitly requested.  For example,  {@code Collection} has methods {@link java.util.Collection#stream} and  {@link java.util.Collection#parallelStream}, which produce sequential and parallel streams respectively; other stream-bearing methods such as  {@link java.util.stream.IntStream#range(int, int)} produce sequential streams but these streams can be efficiently parallelized by invoking their  {@link java.util.stream.BaseStream#parallel()} method. To execute the prior "sum of weights of widgets" query in parallel, we would do: </p><pre> {@code
    int sumOfWeights = widgets.}<code><b>parallelStream()</b></code> {@code 
                              .filter(b -&gt; b.getColor() == RED)
                              .mapToInt(b -&gt; b.getWeight())
                              .sum();
}</pre> <p>The only difference between the serial and parallel versions of this example is the creation of the initial stream, using " {@code parallelStream()}" instead of " {@code stream()}".  When the terminal operation is initiated, the stream pipeline is executed sequentially or in parallel depending on the orientation of the stream on which it is invoked.  Whether a stream will execute in serial or parallel can be determined with the  {@code isParallel()} method, and the orientation of a stream can be modified with the {@link java.util.stream.BaseStream#sequential()} and {@link java.util.stream.BaseStream#parallel()} operations.  When the terminal operation is initiated, the stream pipeline is executed sequentially or in parallel depending on the mode of the stream on which it is invoked. </p><p>Except for operations identified as explicitly nondeterministic, such as  {@code findAny()}, whether a stream executes sequentially or in parallel should not change the result of the computation. </p><p>Most stream operations accept parameters that describe user-specified behavior, which are often lambda expressions.  To preserve correct behavior, these <em>behavioral parameters</em> must be <em>non-interfering</em>, and in most cases must be <em>stateless</em>.  Such parameters are always instances of a <a href="../function/package-summary.html">functional interface</a> such as  {@link java.util.function.Function}, and are often lambda expressions or method references. </p><h3><a name="NonInterference">Non-interference</a></h3> Streams enable you to execute possibly-parallel aggregate operations over a variety of data sources, including even non-thread-safe collections such as {@code ArrayList}. This is possible only if we can prevent <em>interference</em> with the data source during the execution of a stream pipeline.  Except for the escape-hatch operations  {@code iterator()} and {@code spliterator()}, execution begins when the terminal operation is invoked, and ends when the terminal operation completes.  For most data sources, preventing interference means ensuring that the data source is <em>not modified at all</em> during the execution of the stream pipeline. The notable exception to this are streams whose sources are concurrent collections, which are specifically designed to handle concurrent modification. Concurrent stream sources are those whose  {@code Spliterator} reports the {@code CONCURRENT} characteristic. <p>Accordingly, behavioral parameters in stream pipelines whose source might not be concurrent should never modify the stream's data source. A behavioral parameter is said to <em>interfere</em> with a non-concurrent data source if it modifies, or causes to be modified, the stream's data source.  The need for non-interference applies to all pipelines, not just parallel ones.  Unless the stream source is concurrent, modifying a stream's data source during execution of a stream pipeline can cause exceptions, incorrect answers, or nonconformant behavior. For well-behaved stream sources, the source can be modified before the terminal operation commences and those modifications will be reflected in the covered elements.  For example, consider the following code: </p><pre> {@code
    List&lt;String&gt; l = new ArrayList(Arrays.asList("one", "two"));
    Stream&lt;String&gt; sl = l.stream();
    l.add("three");
    String s = sl.collect(joining(" "));
}</pre> First a list is created consisting of two strings: "one"; and "two". Then a stream is created from that list. Next the list is modified by adding a third string: "three". Finally the elements of the stream are collected and joined together. Since the list was modified before the terminal  {@code collect} operation commenced the result will be a string of "one two three". All the streams returned from JDK collections, and most other JDK classes, are well-behaved in this manner; for streams generated by other libraries, see <a href="package-summary.html#StreamSources">Low-level stream construction</a> for requirements for building well-behaved streams. <h3><a name="Statelessness">Stateless behaviors</a></h3> Stream pipeline results may be nondeterministic or incorrect if the behavioral parameters to the stream operations are <em>stateful</em>.  A stateful lambda (or other object implementing the appropriate functional interface) is one whose result depends on any state which might change during the execution of the stream pipeline.  An example of a stateful lambda is the parameter to  {@code map()} in: <pre> {@code
    Set&lt;Integer&gt; seen = Collections.synchronizedSet(new HashSet&lt;&gt;());
    stream.parallel().map(e -&gt; { if (seen.add(e)) return 0; else return e; })...
}</pre> Here, if the mapping operation is performed in parallel, the results for the same input could vary from run to run, due to thread scheduling differences, whereas, with a stateless lambda expression the results would always be the same. <p>Note also that attempting to access mutable state from behavioral parameters presents you with a bad choice with respect to safety and performance; if you do not synchronize access to that state, you have a data race and therefore your code is broken, but if you do synchronize access to that state, you risk having contention undermine the parallelism you are seeking to benefit from.  The best approach is to avoid stateful behavioral parameters to stream operations entirely; there is usually a way to restructure the stream pipeline to avoid statefulness. </p><h3>Side-effects</h3> Side-effects in behavioral parameters to stream operations are, in general, discouraged, as they can often lead to unwitting violations of the statelessness requirement, as well as other thread-safety hazards. <p>If the behavioral parameters do have side-effects, unless explicitly stated, there are no guarantees as to the <a href="../concurrent/package-summary.html#MemoryVisibility"><i>visibility</i></a> of those side-effects to other threads, nor are there any guarantees that different operations on the "same" element within the same stream pipeline are executed in the same thread.  Further, the ordering of those effects may be surprising.  Even when a pipeline is constrained to produce a <em>result</em> that is consistent with the encounter order of the stream source (for example,  {@code IntStream.range(0,5).parallel().map(x -&gt; x*2).toArray()} must produce  {@code [0, 2, 4, 6, 8]}), no guarantees are made as to the order in which the mapper function is applied to individual elements, or in what thread any behavioral parameter is executed for a given element. </p><p>Many computations where one might be tempted to use side effects can be more safely and efficiently expressed without side-effects, such as using <a href="package-summary.html#Reduction">reduction</a> instead of mutable accumulators. However, side-effects such as using  {@code println()} for debugging purposes are usually harmless.  A small number of stream operations, such as {@code forEach()} and  {@code peek()}, can operate only via side-effects; these should be used with care. </p><p>As an example of how to transform a stream pipeline that inappropriately uses side-effects to one that does not, the following code searches a stream of strings for those matching a given regular expression, and puts the matches in a list. </p><pre> {@code
    ArrayList&lt;String&gt; results = new ArrayList&lt;&gt;();
    stream.filter(s -&gt; pattern.matcher(s).matches())
          .forEach(s -&gt; results.add(s));  // Unnecessary use of side-effects!
}</pre> This code unnecessarily uses side-effects.  If executed in parallel, the non-thread-safety of  {@code ArrayList} would cause incorrect results, and adding needed synchronization would cause contention, undermining the benefit of parallelism.  Furthermore, using side-effects here is completely unnecessary; the  {@code forEach()} can simply be replaced with a reduction operation that is safer, more efficient, and more amenable to parallelization: <pre> {@code
    List&lt;String&gt;results =
        stream.filter(s -&gt; pattern.matcher(s).matches())
              .collect(Collectors.toList());  // No side-effects!
}</pre> <h3><a name="Ordering">Ordering</a></h3> <p>Streams may or may not have a defined <em>encounter order</em>.  Whether or not a stream has an encounter order depends on the source and the intermediate operations.  Certain stream sources (such as  {@code List} or arrays) are intrinsically ordered, whereas others (such as  {@code HashSet}) are not.  Some intermediate operations, such as  {@code sorted()}, may impose an encounter order on an otherwise unordered stream, and others may render an ordered stream unordered, such as  {@link java.util.stream.BaseStream#unordered()}. Further, some terminal operations may ignore encounter order, such as {@code forEach()}. </p><p>If a stream is ordered, most operations are constrained to operate on the elements in their encounter order; if the source of a stream is a  {@code List} containing  {@code [1, 2, 3]}, then the result of executing  {@code map(x -&gt; x*2)} must be  {@code [2, 4, 6]}.  However, if the source has no defined encounter order, then any permutation of the values  {@code [2, 4, 6]} would be a valid result. </p><p>For sequential streams, the presence or absence of an encounter order does not affect performance, only determinism.  If a stream is ordered, repeated execution of identical stream pipelines on an identical source will produce an identical result; if it is not ordered, repeated execution might produce different results. </p><p>For parallel streams, relaxing the ordering constraint can sometimes enable more efficient execution.  Certain aggregate operations, such as filtering duplicates ( {@code distinct()}) or grouped reductions ( {@code Collectors.groupingBy()}) can be implemented more efficiently if ordering of elements is not relevant.  Similarly, operations that are intrinsically tied to encounter order, such as  {@code limit()}, may require buffering to ensure proper ordering, undermining the benefit of parallelism. In cases where the stream has an encounter order, but the user does not particularly <em>care</em> about that encounter order, explicitly de-ordering the stream with  {@link java.util.stream.BaseStream#unordered() unordered()} may improve parallel performance for some stateful or terminal operations. However, most stream pipelines, such as the "sum of weight of blocks" example above, still parallelize efficiently even under ordering constraints. </p><h2><a name="Reduction">Reduction operations</a></h2> A <em>reduction</em> operation (also called a <em>fold</em>) takes a sequence of input elements and combines them into a single summary result by repeated application of a combining operation, such as finding the sum or maximum of a set of numbers, or accumulating elements into a list.  The streams classes have multiple forms of general reduction operations, called {@link java.util.stream.Stream#reduce(java.util.function.BinaryOperator) reduce()} and  {@link java.util.stream.Stream#collect(java.util.stream.Collector) collect()}, as well as multiple specialized reduction forms such as {@link java.util.stream.IntStream#sum() sum()},  {@link java.util.stream.IntStream#max() max()}, or  {@link java.util.stream.IntStream#count() count()}. <p>Of course, such operations can be readily implemented as simple sequential loops, as in: </p><pre> {@code
   int sum = 0;
   for (int x : numbers) {
      sum += x;
   }
}</pre> However, there are good reasons to prefer a reduce operation over a mutative accumulation such as the above.  Not only is a reduction "more abstract" -- it operates on the stream as a whole rather than individual elements -- but a properly constructed reduce operation is inherently parallelizable, so long as the function(s) used to process the elements are <a href="package-summary.html#Associativity">associative</a> and <a href="package-summary.html#NonInterfering">stateless</a>. For example, given a stream of numbers for which we want to find the sum, we can write: <pre> {@code
   int sum = numbers.stream().reduce(0, (x,y) -&gt; x+y);
}</pre> or: <pre> {@code
   int sum = numbers.stream().reduce(0, Integer::sum);
}</pre> <p>These reduction operations can run safely in parallel with almost no modification: </p><pre> {@code
   int sum = numbers.parallelStream().reduce(0, Integer::sum);
}</pre> <p>Reduction parallellizes well because the implementation can operate on subsets of the data in parallel, and then combine the intermediate results to get the final correct answer.  (Even if the language had a "parallel for-each" construct, the mutative accumulation approach would still required the developer to provide thread-safe updates to the shared accumulating variable  {@code sum}, and the required synchronization would then likely eliminate any performance gain from parallelism.)  Using  {@code reduce()} instead removes all of the burden of parallelizing the reduction operation, and the library can provide an efficient parallel implementation with no additional synchronization required. </p><p>The "widgets" examples shown earlier shows how reduction combines with other operations to replace for loops with bulk operations.  If  {@code widgets} is a collection of  {@code Widget} objects, which have a  {@code getWeight} method, we can find the heaviest widget with: </p><pre> {@code
    OptionalInt heaviest = widgets.parallelStream()
                                  .mapToInt(Widget::getWeight)
                                  .max();
}</pre> <p>In its more general form, a  {@code reduce} operation on elements of type {@code &lt;T&gt;} yielding a result of type  {@code &lt;U&gt;} requires three parameters: </p><pre> {@code
&lt;U&gt; U reduce(U identity,
             BiFunction&lt;U, ? super T, U&gt; accumulator,
             BinaryOperator&lt;U&gt; combiner);
}</pre> Here, the <em>identity</em> element is both an initial seed value for the reduction and a default result if there are no input elements. The <em>accumulator</em> function takes a partial result and the next element, and produces a new partial result. The <em>combiner</em> function combines two partial results to produce a new partial result.  (The combiner is necessary in parallel reductions, where the input is partitioned, a partial accumulation computed for each partition, and then the partial results are combined to produce a final result.) <p>More formally, the  {@code identity} value must be an <em>identity</em> for the combiner function. This means that for all  {@code u}, {@code combiner.apply(identity, u)} is equal to  {@code u}. Additionally, the {@code combiner} function must be <a href="package-summary.html#Associativity">associative</a> and must be compatible with the  {@code accumulator} function: for all  {@code u} and  {@code t},  {@code combiner.apply(u, accumulator.apply(identity, t))} must be  {@code equals()} to  {@code accumulator.apply(u, t)}. </p><p>The three-argument form is a generalization of the two-argument form, incorporating a mapping step into the accumulation step.  We could re-cast the simple sum-of-weights example using the more general form as follows: </p><pre> {@code
    int sumOfWeights = widgets.stream()
                              .reduce(0,
                                      (sum, b) -&gt; sum + b.getWeight())
                                      Integer::sum);
}</pre> though the explicit map-reduce form is more readable and therefore should usually be preferred. The generalized form is provided for cases where significant work can be optimized away by combining mapping and reducing into a single function. <h3><a name="MutableReduction">Mutable reduction</a></h3> A <em>mutable reduction operation</em> accumulates input elements into a mutable result container, such as a  {@code Collection} or  {@code StringBuilder}, as it processes the elements in the stream. <p>If we wanted to take a stream of strings and concatenate them into a single long string, we <em>could</em> achieve this with ordinary reduction: </p><pre> {@code
    String concatenated = strings.reduce("", String::concat)
}</pre> <p>We would get the desired result, and it would even work in parallel.  However, we might not be happy about the performance!  Such an implementation would do a great deal of string copying, and the run time would be <em>O(n^2)</em> in the number of characters.  A more performant approach would be to accumulate the results into a  {@link java.lang.StringBuilder}, which is a mutable container for accumulating strings.  We can use the same technique to parallelize mutable reduction as we do with ordinary reduction. </p><p>The mutable reduction operation is called {@link java.util.stream.Stream#collect(Collector) collect()}, as it collects together the desired results into a result container such as a  {@code Collection}. A  {@code collect} operation requires three functions: a supplier function to construct new instances of the result container, an accumulator function to incorporate an input element into a result container, and a combining function to merge the contents of one result container into another.  The form of this is very similar to the general form of ordinary reduction: </p><pre> {@code
&lt;R&gt; R collect(Supplier&lt;R&gt; supplier,
              BiConsumer&lt;R, ? super T&gt; accumulator,
              BiConsumer&lt;R, R&gt; combiner);
}</pre> <p>As with  {@code reduce()}, a benefit of expressing  {@code collect} in this abstract way is that it is directly amenable to parallelization: we can accumulate partial results in parallel and then combine them, so long as the accumulation and combining functions satisfy the appropriate requirements. For example, to collect the String representations of the elements in a stream into an  {@code ArrayList}, we could write the obvious sequential for-each form: </p><pre> {@code
    ArrayList&lt;String&gt; strings = new ArrayList&lt;&gt;();
    for (T element : stream) {
        strings.add(element.toString());
    }
}</pre> Or we could use a parallelizable collect form: <pre> {@code
    ArrayList&lt;String&gt; strings = stream.collect(() -&gt; new ArrayList&lt;&gt;(),
                                               (c, e) -&gt; c.add(e.toString()),
                                               (c1, c2) -&gt; c1.addAll(c2));
}</pre> or, pulling the mapping operation out of the accumulator function, we could express it more succinctly as: <pre> {@code
    List&lt;String&gt; strings = stream.map(Object::toString)
                                 .collect(ArrayList::new, ArrayList::add, ArrayList::addAll);
}</pre> Here, our supplier is just the  {@link java.util.ArrayList#ArrayList() ArrayList constructor}, the accumulator adds the stringified element to an {@code ArrayList}, and the combiner simply uses  {@link java.util.ArrayList#addAll addAll} to copy the strings from one container into the other. <p>The three aspects of  {@code collect} -- supplier, accumulator, and combiner -- are tightly coupled.  We can use the abstraction of a {@link java.util.stream.Collector} to capture all three aspects.  The above example for collecting strings into a  {@code List} can be rewritten using a standard  {@code Collector} as: </p><pre> {@code
    List&lt;String&gt; strings = stream.map(Object::toString)
                                 .collect(Collectors.toList());
}</pre> <p>Packaging mutable reductions into a Collector has another advantage: composability.  The class  {@link java.util.stream.Collectors} contains a number of predefined factories for collectors, including combinators that transform one collector into another.  For example, suppose we have a collector that computes the sum of the salaries of a stream of employees, as follows: </p><pre> {@code
    Collector&lt;Employee, ?, Integer&gt; summingSalaries
        = Collectors.summingInt(Employee::getSalary);
}</pre> (The  {@code ?} for the second type parameter merely indicates that we don't care about the intermediate representation used by this collector.) If we wanted to create a collector to tabulate the sum of salaries by department, we could reuse  {@code summingSalaries} using {@link java.util.stream.Collectors#groupingBy(java.util.function.Function, java.util.stream.Collector) groupingBy}: <pre> {@code
    Map&lt;Department, Integer&gt; salariesByDept
        = employees.stream().collect(Collectors.groupingBy(Employee::getDepartment,
                                                           summingSalaries));
}</pre> <p>As with the regular reduction operation,  {@code collect()} operations can only be parallelized if appropriate conditions are met.  For any partially accumulated result, combining it with an empty result container must produce an equivalent result.  That is, for a partially accumulated result {@code p} that is the result of any series of accumulator and combiner invocations,  {@code p} must be equivalent to {@code combiner.apply(p, supplier.get())}. </p><p>Further, however the computation is split, it must produce an equivalent result.  For any input elements  {@code t1} and  {@code t2}, the results {@code r1} and  {@code r2} in the computation below must be equivalent: </p><pre> {@code
    A a1 = supplier.get();
    accumulator.accept(a1, t1);
    accumulator.accept(a1, t2);
    R r1 = finisher.apply(a1);  // result without splitting

    A a2 = supplier.get();
    accumulator.accept(a2, t1);
    A a3 = supplier.get();
    accumulator.accept(a3, t2);
    R r2 = finisher.apply(combiner.apply(a2, a3));  // result with splitting
}</pre> <p>Here, equivalence generally means according to  {@link java.lang.Object#equals(Object)}. but in some cases equivalence may be relaxed to account for differences in order. </p><h3><a name="ConcurrentReduction">Reduction, concurrency, and ordering</a></h3> With some complex reduction operations, for example a  {@code collect()} that produces a  {@code Map}, such as: <pre> {@code
    Map&lt;Buyer, List&lt;Transaction&gt;&gt; salesByBuyer
        = txns.parallelStream()
              .collect(Collectors.groupingBy(Transaction::getBuyer));
}</pre> it may actually be counterproductive to perform the operation in parallel. This is because the combining step (merging one  {@code Map} into another by key) can be expensive for some  {@code Map} implementations. <p>Suppose, however, that the result container used in this reduction was a concurrently modifiable collection -- such as a {@link java.util.concurrent.ConcurrentHashMap}. In that case, the parallel invocations of the accumulator could actually deposit their results concurrently into the same shared result container, eliminating the need for the combiner to merge distinct result containers. This potentially provides a boost to the parallel execution performance. We call this a <em>concurrent</em> reduction. </p><p>A  {@link java.util.stream.Collector} that supports concurrent reduction is marked with the  {@link java.util.stream.Collector.Characteristics#CONCURRENT} characteristic.  However, a concurrent collection also has a downside.  If multiple threads are depositing results concurrently into a shared container, the order in which results are deposited is non-deterministic. Consequently, a concurrent reduction is only possible if ordering is not important for the stream being processed. The  {@link java.util.stream.Stream#collect(Collector)} implementation will only perform a concurrent reduction if </p><ul> <li>The stream is parallel;</li> <li>The collector has the {@link java.util.stream.Collector.Characteristics#CONCURRENT} characteristic, and;</li> <li>Either the stream is unordered, or the collector has the {@link java.util.stream.Collector.Characteristics#UNORDERED} characteristic. </li></ul> You can ensure the stream is unordered by using the {@link java.util.stream.BaseStream#unordered()} method.  For example: <pre> {@code
    Map&lt;Buyer, List&lt;Transaction&gt;&gt; salesByBuyer
        = txns.parallelStream()
              .unordered()
              .collect(groupingByConcurrent(Transaction::getBuyer));
}</pre> (where  {@link java.util.stream.Collectors#groupingByConcurrent} is the concurrent equivalent of  {@code groupingBy}). <p>Note that if it is important that the elements for a given key appear in the order they appear in the source, then we cannot use a concurrent reduction, as ordering is one of the casualties of concurrent insertion. We would then be constrained to implement either a sequential reduction or a merge-based parallel reduction. </p><h3><a name="Associativity">Associativity</a></h3> An operator or function  {@code op} is <em>associative</em> if the following holds: <pre> {@code
    (a op b) op c == a op (b op c)
}</pre> The importance of this to parallel evaluation can be seen if we expand this to four terms: <pre> {@code
    a op b op c op d == (a op b) op (c op d)
}</pre> So we can evaluate  {@code (a op b)} in parallel with  {@code (c op d)}, and then invoke  {@code op} on the results. <p>Examples of associative operations include numeric addition, min, and max, and string concatenation. </p><h2><a name="StreamSources">Low-level stream construction</a></h2> So far, all the stream examples have used methods like {@link java.util.Collection#stream()} or  {@link java.util.Arrays#stream(Object[])} to obtain a stream.  How are those stream-bearing methods implemented? <p>The class  {@link java.util.stream.StreamSupport} has a number of low-level methods for creating a stream, all using some form of a {@link java.util.Spliterator}. A spliterator is the parallel analogue of an {@link java.util.Iterator}; it describes a (possibly infinite) collection of elements, with support for sequentially advancing, bulk traversal, and splitting off some portion of the input into another spliterator which can be processed in parallel.  At the lowest level, all streams are driven by a spliterator. </p><p>There are a number of implementation choices in implementing a spliterator, nearly all of which are tradeoffs between simplicity of implementation and runtime performance of streams using that spliterator. The simplest, but least performant, way to create a spliterator is to create one from an iterator using {@link java.util.Spliterators#spliteratorUnknownSize(java.util.Iterator, int)}. While such a spliterator will work, it will likely offer poor parallel performance, since we have lost sizing information (how big is the underlying data set), as well as being constrained to a simplistic splitting algorithm. </p><p>A higher-quality spliterator will provide balanced and known-size splits, accurate sizing information, and a number of other {@link java.util.Spliterator#characteristics() characteristics} of the spliterator or data that can be used by implementations to optimize execution. </p><p>Spliterators for mutable data sources have an additional challenge; timing of binding to the data, since the data could change between the time the spliterator is created and the time the stream pipeline is executed. Ideally, a spliterator for a stream would report a characteristic of {@code IMMUTABLE} or  {@code CONCURRENT}; if not it should be <a href="../Spliterator.html#binding"><em>late-binding</em></a>. If a source cannot directly supply a recommended spliterator, it may indirectly supply a spliterator using a  {@code Supplier}, and construct a stream via the {@code Supplier}-accepting versions of {@link java.util.stream.StreamSupport#stream(Supplier, int, boolean) stream()}. The spliterator is obtained from the supplier only after the terminal operation of the stream pipeline commences. </p><p>These requirements significantly reduce the scope of potential interference between mutations of the stream source and execution of stream pipelines. Streams based on spliterators with the desired characteristics, or those using the Supplier-based factory forms, are immune to modifications of the data source prior to commencement of the terminal operation (provided the behavioral parameters to the stream operations meet the required criteria for non-interference and statelessness).  See <a href="package-summary.html#NonInterference">Non-Interference</a> for more details.</p></div>
        <div data-type="tag">1.8</div>
        <div data-type="class" data-name="java.util.stream.StreamSupport">
          <div data-type="text">Low-level utility methods for creating and manipulating streams. <p>This class is mostly for library writers presenting stream views of data structures; most static stream methods intended for end users are in the various  {@code Stream} classes.</p></div>
          <div data-type="tag">1.8</div>
          <div data-type="method" data-name="stream(java.util.Spliterator&lt;T&gt;, boolean)">
            <div data-type="text">Creates a new sequential or parallel  {@code Stream} from a {@code Spliterator}. <p>The spliterator is only traversed, split, or queried for estimated size after the terminal operation of the stream pipeline commences. </p><p>It is strongly recommended the spliterator report a characteristic of {@code IMMUTABLE} or  {@code CONCURRENT}, or be <a href="../Spliterator.html#binding">late-binding</a>.  Otherwise, {@link #stream(java.util.function.Supplier, int, boolean)} should be used to reduce the scope of potential interference with the source.  See <a href="package-summary.html#NonInterference">Non-Interference</a> for more details.</p></div>
            <div data-type="tag" data-parameter-name="T" data-is-type-parameter="data-is-type-parameter">the type of stream elements</div>
            <div data-type="tag" data-parameter-name="spliterator">a  {@code Spliterator} describing the stream elements</div>
            <div data-type="tag" data-parameter-name="parallel">if  {@code true} then the returned stream is a parallel stream; if  {@code false} the returned stream is a sequential stream.</div>
            <div data-type="tag">a new sequential or parallel  {@code Stream}</div>
          </div>
          <div data-type="method" data-name="stream(java.util.function.Supplier&lt;? extends java.util.Spliterator&lt;T&gt;&gt;, int, boolean)">
            <div data-type="text">Creates a new sequential or parallel  {@code Stream} from a {@code Supplier} of  {@code Spliterator}. <p>The  {@link Supplier#get()} method will be invoked on the supplier no more than once, and only after the terminal operation of the stream pipeline commences. </p><p>For spliterators that report a characteristic of  {@code IMMUTABLE} or  {@code CONCURRENT}, or that are <a href="../Spliterator.html#binding">late-binding</a>, it is likely more efficient to use  {@link #stream(java.util.Spliterator, boolean)} instead. </p><p>The use of a  {@code Supplier} in this form provides a level of indirection that reduces the scope of potential interference with the source.  Since the supplier is only invoked after the terminal operation commences, any modifications to the source up to the start of the terminal operation are reflected in the stream result.  See <a href="package-summary.html#NonInterference">Non-Interference</a> for more details.</p></div>
            <div data-type="tag" data-parameter-name="T" data-is-type-parameter="data-is-type-parameter">the type of stream elements</div>
            <div data-type="tag" data-parameter-name="supplier">a  {@code Supplier} of a  {@code Spliterator}</div>
            <div data-type="tag" data-parameter-name="characteristics">Spliterator characteristics of the supplied {@code Spliterator}.  The characteristics must be equal to {@code supplier.get().characteristics()}, otherwise undefined behavior may occur when terminal operation commences.</div>
            <div data-type="tag" data-parameter-name="parallel">if  {@code true} then the returned stream is a parallel stream; if  {@code false} the returned stream is a sequential stream.</div>
            <div data-type="tag">a new sequential or parallel  {@code Stream}</div>
            <div data-type="tag">#stream(java.util.Spliterator, boolean)</div>
          </div>
          <div data-type="method" data-name="intStream(java.util.Spliterator.OfInt, boolean)">
            <div data-type="text">Creates a new sequential or parallel  {@code IntStream} from a {@code Spliterator.OfInt}. <p>The spliterator is only traversed, split, or queried for estimated size after the terminal operation of the stream pipeline commences. </p><p>It is strongly recommended the spliterator report a characteristic of {@code IMMUTABLE} or  {@code CONCURRENT}, or be <a href="../Spliterator.html#binding">late-binding</a>.  Otherwise, {@link #intStream(java.util.function.Supplier, int, boolean)} should be used to reduce the scope of potential interference with the source.  See <a href="package-summary.html#NonInterference">Non-Interference</a> for more details.</p></div>
            <div data-type="tag" data-parameter-name="spliterator">a  {@code Spliterator.OfInt} describing the stream elements</div>
            <div data-type="tag" data-parameter-name="parallel">if  {@code true} then the returned stream is a parallel stream; if  {@code false} the returned stream is a sequential stream.</div>
            <div data-type="tag">a new sequential or parallel  {@code IntStream}</div>
          </div>
          <div data-type="method" data-name="intStream(java.util.function.Supplier&lt;? extends java.util.Spliterator.OfInt&gt;, int, boolean)">
            <div data-type="text">Creates a new sequential or parallel  {@code IntStream} from a {@code Supplier} of  {@code Spliterator.OfInt}. <p>The  {@link Supplier#get()} method will be invoked on the supplier no more than once, and only after the terminal operation of the stream pipeline commences. </p><p>For spliterators that report a characteristic of  {@code IMMUTABLE} or  {@code CONCURRENT}, or that are <a href="../Spliterator.html#binding">late-binding</a>, it is likely more efficient to use  {@link #intStream(java.util.Spliterator.OfInt, boolean)} instead. </p><p>The use of a  {@code Supplier} in this form provides a level of indirection that reduces the scope of potential interference with the source.  Since the supplier is only invoked after the terminal operation commences, any modifications to the source up to the start of the terminal operation are reflected in the stream result.  See <a href="package-summary.html#NonInterference">Non-Interference</a> for more details.</p></div>
            <div data-type="tag" data-parameter-name="supplier">a  {@code Supplier} of a  {@code Spliterator.OfInt}</div>
            <div data-type="tag" data-parameter-name="characteristics">Spliterator characteristics of the supplied {@code Spliterator.OfInt}.  The characteristics must be equal to {@code supplier.get().characteristics()}, otherwise undefined behavior may occur when terminal operation commences.</div>
            <div data-type="tag" data-parameter-name="parallel">if  {@code true} then the returned stream is a parallel stream; if  {@code false} the returned stream is a sequential stream.</div>
            <div data-type="tag">a new sequential or parallel  {@code IntStream}</div>
            <div data-type="tag">#intStream(java.util.Spliterator.OfInt, boolean)</div>
          </div>
          <div data-type="method" data-name="longStream(java.util.Spliterator.OfLong, boolean)">
            <div data-type="text">Creates a new sequential or parallel  {@code LongStream} from a {@code Spliterator.OfLong}. <p>The spliterator is only traversed, split, or queried for estimated size after the terminal operation of the stream pipeline commences. </p><p>It is strongly recommended the spliterator report a characteristic of {@code IMMUTABLE} or  {@code CONCURRENT}, or be <a href="../Spliterator.html#binding">late-binding</a>.  Otherwise, {@link #longStream(java.util.function.Supplier, int, boolean)} should be used to reduce the scope of potential interference with the source.  See <a href="package-summary.html#NonInterference">Non-Interference</a> for more details.</p></div>
            <div data-type="tag" data-parameter-name="spliterator">a  {@code Spliterator.OfLong} describing the stream elements</div>
            <div data-type="tag" data-parameter-name="parallel">if  {@code true} then the returned stream is a parallel stream; if  {@code false} the returned stream is a sequential stream.</div>
            <div data-type="tag">a new sequential or parallel  {@code LongStream}</div>
          </div>
          <div data-type="method" data-name="longStream(java.util.function.Supplier&lt;? extends java.util.Spliterator.OfLong&gt;, int, boolean)">
            <div data-type="text">Creates a new sequential or parallel  {@code LongStream} from a {@code Supplier} of  {@code Spliterator.OfLong}. <p>The  {@link Supplier#get()} method will be invoked on the supplier no more than once, and only after the terminal operation of the stream pipeline commences. </p><p>For spliterators that report a characteristic of  {@code IMMUTABLE} or  {@code CONCURRENT}, or that are <a href="../Spliterator.html#binding">late-binding</a>, it is likely more efficient to use  {@link #longStream(java.util.Spliterator.OfLong, boolean)} instead. </p><p>The use of a  {@code Supplier} in this form provides a level of indirection that reduces the scope of potential interference with the source.  Since the supplier is only invoked after the terminal operation commences, any modifications to the source up to the start of the terminal operation are reflected in the stream result.  See <a href="package-summary.html#NonInterference">Non-Interference</a> for more details.</p></div>
            <div data-type="tag" data-parameter-name="supplier">a  {@code Supplier} of a  {@code Spliterator.OfLong}</div>
            <div data-type="tag" data-parameter-name="characteristics">Spliterator characteristics of the supplied {@code Spliterator.OfLong}.  The characteristics must be equal to {@code supplier.get().characteristics()}, otherwise undefined behavior may occur when terminal operation commences.</div>
            <div data-type="tag" data-parameter-name="parallel">if  {@code true} then the returned stream is a parallel stream; if  {@code false} the returned stream is a sequential stream.</div>
            <div data-type="tag">a new sequential or parallel  {@code LongStream}</div>
            <div data-type="tag">#longStream(java.util.Spliterator.OfLong, boolean)</div>
          </div>
          <div data-type="method" data-name="doubleStream(java.util.Spliterator.OfDouble, boolean)">
            <div data-type="text">Creates a new sequential or parallel  {@code DoubleStream} from a {@code Spliterator.OfDouble}. <p>The spliterator is only traversed, split, or queried for estimated size after the terminal operation of the stream pipeline commences. </p><p>It is strongly recommended the spliterator report a characteristic of {@code IMMUTABLE} or  {@code CONCURRENT}, or be <a href="../Spliterator.html#binding">late-binding</a>.  Otherwise, {@link #doubleStream(java.util.function.Supplier, int, boolean)} should be used to reduce the scope of potential interference with the source.  See <a href="package-summary.html#NonInterference">Non-Interference</a> for more details.</p></div>
            <div data-type="tag" data-parameter-name="spliterator">A  {@code Spliterator.OfDouble} describing the stream elements</div>
            <div data-type="tag" data-parameter-name="parallel">if  {@code true} then the returned stream is a parallel stream; if  {@code false} the returned stream is a sequential stream.</div>
            <div data-type="tag">a new sequential or parallel  {@code DoubleStream}</div>
          </div>
          <div data-type="method" data-name="doubleStream(java.util.function.Supplier&lt;? extends java.util.Spliterator.OfDouble&gt;, int, boolean)">
            <div data-type="text">Creates a new sequential or parallel  {@code DoubleStream} from a {@code Supplier} of  {@code Spliterator.OfDouble}. <p>The  {@link Supplier#get()} method will be invoked on the supplier no more than once, and only after the terminal operation of the stream pipeline commences. </p><p>For spliterators that report a characteristic of  {@code IMMUTABLE} or  {@code CONCURRENT}, or that are <a href="../Spliterator.html#binding">late-binding</a>, it is likely more efficient to use  {@link #doubleStream(java.util.Spliterator.OfDouble, boolean)} instead. </p><p>The use of a  {@code Supplier} in this form provides a level of indirection that reduces the scope of potential interference with the source.  Since the supplier is only invoked after the terminal operation commences, any modifications to the source up to the start of the terminal operation are reflected in the stream result.  See <a href="package-summary.html#NonInterference">Non-Interference</a> for more details.</p></div>
            <div data-type="tag" data-parameter-name="supplier">A  {@code Supplier} of a  {@code Spliterator.OfDouble}</div>
            <div data-type="tag" data-parameter-name="characteristics">Spliterator characteristics of the supplied {@code Spliterator.OfDouble}.  The characteristics must be equal to {@code supplier.get().characteristics()}, otherwise undefined behavior may occur when terminal operation commences.</div>
            <div data-type="tag" data-parameter-name="parallel">if  {@code true} then the returned stream is a parallel stream; if  {@code false} the returned stream is a sequential stream.</div>
            <div data-type="tag">a new sequential or parallel  {@code DoubleStream}</div>
            <div data-type="tag">#doubleStream(java.util.Spliterator.OfDouble, boolean)</div>
          </div>
        </div>
        <div data-type="class" data-name="java.util.stream.Stream">
          <div data-type="text">A sequence of elements supporting sequential and parallel aggregate operations.  The following example illustrates an aggregate operation using {@link Stream} and  {@link IntStream}: <pre> {@code
    int sum = widgets.stream()
                     .filter(w -&gt; w.getColor() == RED)
                     .mapToInt(w -&gt; w.getWeight())
                     .sum();
}</pre> In this example,  {@code widgets} is a  {@code Collection&lt;Widget&gt;}.  We create a stream of  {@code Widget} objects via  {@link Collection#stream Collection.stream()}, filter it to produce a stream containing only the red widgets, and then transform it into a stream of  {@code int} values representing the weight of each red widget. Then this stream is summed to produce a total weight. <p>In addition to  {@code Stream}, which is a stream of object references, there are primitive specializations for  {@link IntStream},  {@link LongStream}, and  {@link DoubleStream}, all of which are referred to as "streams" and conform to the characteristics and restrictions described here. </p><p>To perform a computation, stream <a href="package-summary.html#StreamOps">operations</a> are composed into a <em>stream pipeline</em>.  A stream pipeline consists of a source (which might be an array, a collection, a generator function, an I/O channel, etc), zero or more <em>intermediate operations</em> (which transform a stream into another stream, such as  {@link Stream#filter(Predicate)}), and a <em>terminal operation</em> (which produces a result or side-effect, such as  {@link Stream#count()} or  {@link Stream#forEach(Consumer)}). Streams are lazy; computation on the source data is only performed when the terminal operation is initiated, and source elements are consumed only as needed. </p><p>Collections and streams, while bearing some superficial similarities, have different goals.  Collections are primarily concerned with the efficient management of, and access to, their elements.  By contrast, streams do not provide a means to directly access or manipulate their elements, and are instead concerned with declaratively describing their source and the computational operations which will be performed in aggregate on that source. However, if the provided stream operations do not offer the desired functionality, the  {@link #iterator()} and  {@link #spliterator()} operations can be used to perform a controlled traversal. </p><p>A stream pipeline, like the "widgets" example above, can be viewed as a <em>query</em> on the stream source.  Unless the source was explicitly designed for concurrent modification (such as a  {@link ConcurrentHashMap}), unpredictable or erroneous behavior may result from modifying the stream source while it is being queried. </p><p>Most stream operations accept parameters that describe user-specified behavior, such as the lambda expression  {@code w -&gt; w.getWeight()} passed to {@code mapToInt} in the example above.  To preserve correct behavior, these <em>behavioral parameters</em>: </p><ul> <li>must be <a href="package-summary.html#NonInterference">non-interfering</a> (they do not modify the stream source); and</li> <li>in most cases must be <a href="package-summary.html#Statelessness">stateless</a> (their result should not depend on any state that might change during execution of the stream pipeline).</li> </ul> <p>Such parameters are always instances of a <a href="../function/package-summary.html">functional interface</a> such as  {@link java.util.function.Function}, and are often lambda expressions or method references.  Unless otherwise specified these parameters must be <em>non-null</em>. </p><p>A stream should be operated on (invoking an intermediate or terminal stream operation) only once.  This rules out, for example, "forked" streams, where the same source feeds two or more pipelines, or multiple traversals of the same stream.  A stream implementation may throw  {@link IllegalStateException} if it detects that the stream is being reused. However, since some stream operations may return their receiver rather than a new stream object, it may not be possible to detect reuse in all cases. </p><p>Streams have a  {@link #close()} method and implement  {@link AutoCloseable}, but nearly all stream instances do not actually need to be closed after use. Generally, only streams whose source is an IO channel (such as those returned by  {@link Files#lines(Path, Charset)}) will require closing.  Most streams are backed by collections, arrays, or generating functions, which require no special resource management.  (If a stream does require closing, it can be declared as a resource in a  {@code try}-with-resources statement.) </p><p>Stream pipelines may execute either sequentially or in <a href="package-summary.html#Parallelism">parallel</a>.  This execution mode is a property of the stream.  Streams are created with an initial choice of sequential or parallel execution.  (For example, {@link Collection#stream() Collection.stream()} creates a sequential stream, and  {@link Collection#parallelStream() Collection.parallelStream()} creates a parallel one.)  This choice of execution mode may be modified by the {@link #sequential()} or  {@link #parallel()} methods, and may be queried with the  {@link #isParallel()} method.</p></div>
          <div data-type="tag" data-parameter-name="T" data-is-type-parameter="data-is-type-parameter">the type of the stream elements</div>
          <div data-type="tag">1.8</div>
          <div data-type="tag">IntStream</div>
          <div data-type="tag">LongStream</div>
          <div data-type="tag">DoubleStream</div>
          <div data-type="tag">
            <a href="package-summary.html">java.util.stream</a>
          </div>
          <div data-type="method" data-name="filter(java.util.function.Predicate&lt;? super T&gt;)">
            <div data-type="text">Returns a stream consisting of the elements of this stream that match the given predicate. <p>This is an <a href="package-summary.html#StreamOps">intermediate operation</a>.</p></div>
            <div data-type="tag" data-parameter-name="predicate">a <a href="package-summary.html#NonInterference">non-interfering</a>, <a href="package-summary.html#Statelessness">stateless</a> predicate to apply to each element to determine if it should be included</div>
            <div data-type="tag">the new stream</div>
          </div>
          <div data-type="method" data-name="map(java.util.function.Function&lt;? super T, ? extends R&gt;)">
            <div data-type="text">Returns a stream consisting of the results of applying the given function to the elements of this stream. <p>This is an <a href="package-summary.html#StreamOps">intermediate operation</a>.</p></div>
            <div data-type="tag" data-parameter-name="R" data-is-type-parameter="data-is-type-parameter">The element type of the new stream</div>
            <div data-type="tag" data-parameter-name="mapper">a <a href="package-summary.html#NonInterference">non-interfering</a>, <a href="package-summary.html#Statelessness">stateless</a> function to apply to each element</div>
            <div data-type="tag">the new stream</div>
          </div>
          <div data-type="method" data-name="mapToInt(java.util.function.ToIntFunction&lt;? super T&gt;)">
            <div data-type="text">Returns an  {@code IntStream} consisting of the results of applying the given function to the elements of this stream. <p>This is an <a href="package-summary.html#StreamOps"> intermediate operation</a>.</p></div>
            <div data-type="tag" data-parameter-name="mapper">a <a href="package-summary.html#NonInterference">non-interfering</a>, <a href="package-summary.html#Statelessness">stateless</a> function to apply to each element</div>
            <div data-type="tag">the new stream</div>
          </div>
          <div data-type="method" data-name="mapToLong(java.util.function.ToLongFunction&lt;? super T&gt;)">
            <div data-type="text">Returns a  {@code LongStream} consisting of the results of applying the given function to the elements of this stream. <p>This is an <a href="package-summary.html#StreamOps">intermediate operation</a>.</p></div>
            <div data-type="tag" data-parameter-name="mapper">a <a href="package-summary.html#NonInterference">non-interfering</a>, <a href="package-summary.html#Statelessness">stateless</a> function to apply to each element</div>
            <div data-type="tag">the new stream</div>
          </div>
          <div data-type="method" data-name="mapToDouble(java.util.function.ToDoubleFunction&lt;? super T&gt;)">
            <div data-type="text">Returns a  {@code DoubleStream} consisting of the results of applying the given function to the elements of this stream. <p>This is an <a href="package-summary.html#StreamOps">intermediate operation</a>.</p></div>
            <div data-type="tag" data-parameter-name="mapper">a <a href="package-summary.html#NonInterference">non-interfering</a>, <a href="package-summary.html#Statelessness">stateless</a> function to apply to each element</div>
            <div data-type="tag">the new stream</div>
          </div>
          <div data-type="method" data-name="flatMap(java.util.function.Function&lt;? super T, ? extends java.util.stream.Stream&lt;? extends R&gt;&gt;)">
            <div data-type="text">Returns a stream consisting of the results of replacing each element of this stream with the contents of a mapped stream produced by applying the provided mapping function to each element.  Each mapped stream is {@link java.util.stream.BaseStream#close() closed} after its contents have been placed into this stream.  (If a mapped stream is  {@code null} an empty stream is used, instead.) <p>This is an <a href="package-summary.html#StreamOps">intermediate operation</a>.</p></div>
            <div data-type="tag">The  {@code flatMap()} operation has the effect of applying a one-to-many transformation to the elements of the stream, and then flattening the resulting elements into a new stream. <p><b>Examples.</b> </p><p>If  {@code orders} is a stream of purchase orders, and each purchase order contains a collection of line items, then the following produces a stream containing all the line items in all the orders: </p><pre> {@code
    orders.flatMap(order -&gt; order.getLineItems().stream())...
}</pre> <p>If  {@code path} is the path to a file, then the following produces a stream of the  {@code words} contained in that file: </p><pre> {@code
    Stream&lt;String&gt; lines = Files.lines(path, StandardCharsets.UTF_8);
    Stream&lt;String&gt; words = lines.flatMap(line -&gt; Stream.of(line.split(" +")));
}</pre> The  {@code mapper} function passed to  {@code flatMap} splits a line, using a simple regular expression, into an array of words, and then creates a stream of words from that array.</div>
            <div data-type="tag" data-parameter-name="R" data-is-type-parameter="data-is-type-parameter">The element type of the new stream</div>
            <div data-type="tag" data-parameter-name="mapper">a <a href="package-summary.html#NonInterference">non-interfering</a>, <a href="package-summary.html#Statelessness">stateless</a> function to apply to each element which produces a stream of new values</div>
            <div data-type="tag">the new stream</div>
          </div>
          <div data-type="method" data-name="flatMapToInt(java.util.function.Function&lt;? super T, ? extends java.util.stream.IntStream&gt;)">
            <div data-type="text">Returns an  {@code IntStream} consisting of the results of replacing each element of this stream with the contents of a mapped stream produced by applying the provided mapping function to each element.  Each mapped stream is  {@link java.util.stream.BaseStream#close() closed} after its contents have been placed into this stream.  (If a mapped stream is {@code null} an empty stream is used, instead.) <p>This is an <a href="package-summary.html#StreamOps">intermediate operation</a>.</p></div>
            <div data-type="tag" data-parameter-name="mapper">a <a href="package-summary.html#NonInterference">non-interfering</a>, <a href="package-summary.html#Statelessness">stateless</a> function to apply to each element which produces a stream of new values</div>
            <div data-type="tag">the new stream</div>
            <div data-type="tag">#flatMap(Function)</div>
          </div>
          <div data-type="method" data-name="flatMapToLong(java.util.function.Function&lt;? super T, ? extends java.util.stream.LongStream&gt;)">
            <div data-type="text">Returns an  {@code LongStream} consisting of the results of replacing each element of this stream with the contents of a mapped stream produced by applying the provided mapping function to each element.  Each mapped stream is  {@link java.util.stream.BaseStream#close() closed} after its contents have been placed into this stream.  (If a mapped stream is {@code null} an empty stream is used, instead.) <p>This is an <a href="package-summary.html#StreamOps">intermediate operation</a>.</p></div>
            <div data-type="tag" data-parameter-name="mapper">a <a href="package-summary.html#NonInterference">non-interfering</a>, <a href="package-summary.html#Statelessness">stateless</a> function to apply to each element which produces a stream of new values</div>
            <div data-type="tag">the new stream</div>
            <div data-type="tag">#flatMap(Function)</div>
          </div>
          <div data-type="method" data-name="flatMapToDouble(java.util.function.Function&lt;? super T, ? extends java.util.stream.DoubleStream&gt;)">
            <div data-type="text">Returns an  {@code DoubleStream} consisting of the results of replacing each element of this stream with the contents of a mapped stream produced by applying the provided mapping function to each element.  Each mapped stream is  {@link java.util.stream.BaseStream#close() closed} after its contents have placed been into this stream.  (If a mapped stream is {@code null} an empty stream is used, instead.) <p>This is an <a href="package-summary.html#StreamOps">intermediate operation</a>.</p></div>
            <div data-type="tag" data-parameter-name="mapper">a <a href="package-summary.html#NonInterference">non-interfering</a>, <a href="package-summary.html#Statelessness">stateless</a> function to apply to each element which produces a stream of new values</div>
            <div data-type="tag">the new stream</div>
            <div data-type="tag">#flatMap(Function)</div>
          </div>
          <div data-type="method" data-name="distinct()">
            <div data-type="text">Returns a stream consisting of the distinct elements (according to {@link Object#equals(Object)}) of this stream. <p>For ordered streams, the selection of distinct elements is stable (for duplicated elements, the element appearing first in the encounter order is preserved.)  For unordered streams, no stability guarantees are made. </p><p>This is a <a href="package-summary.html#StreamOps">stateful intermediate operation</a>.</p></div>
            <div data-type="tag">Preserving stability for  {@code distinct()} in parallel pipelines is relatively expensive (requires that the operation act as a full barrier, with substantial buffering overhead), and stability is often not needed. Using an unordered stream source (such as  {@link #generate(Supplier)}) or removing the ordering constraint with  {@link #unordered()} may result in significantly more efficient execution for  {@code distinct()} in parallel pipelines, if the semantics of your situation permit.  If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with  {@code distinct()} in parallel pipelines, switching to sequential execution with  {@link #sequential()} may improve performance.</div>
            <div data-type="tag">the new stream</div>
          </div>
          <div data-type="method" data-name="sorted()">
            <div data-type="text">Returns a stream consisting of the elements of this stream, sorted according to natural order.  If the elements of this stream are not {@code Comparable}, a  {@code java.lang.ClassCastException} may be thrown when the terminal operation is executed. <p>For ordered streams, the sort is stable.  For unordered streams, no stability guarantees are made. </p><p>This is a <a href="package-summary.html#StreamOps">stateful intermediate operation</a>.</p></div>
            <div data-type="tag">the new stream</div>
          </div>
          <div data-type="method" data-name="sorted(java.util.Comparator&lt;? super T&gt;)">
            <div data-type="text">Returns a stream consisting of the elements of this stream, sorted according to the provided  {@code Comparator}. <p>For ordered streams, the sort is stable.  For unordered streams, no stability guarantees are made. </p><p>This is a <a href="package-summary.html#StreamOps">stateful intermediate operation</a>.</p></div>
            <div data-type="tag" data-parameter-name="comparator">a <a href="package-summary.html#NonInterference">non-interfering</a>, <a href="package-summary.html#Statelessness">stateless</a> {@code Comparator} to be used to compare stream elements</div>
            <div data-type="tag">the new stream</div>
          </div>
          <div data-type="method" data-name="peek(java.util.function.Consumer&lt;? super T&gt;)">
            <div data-type="text">Returns a stream consisting of the elements of this stream, additionally performing the provided action on each element as elements are consumed from the resulting stream. <p>This is an <a href="package-summary.html#StreamOps">intermediate operation</a>. </p><p>For parallel stream pipelines, the action may be called at whatever time and in whatever thread the element is made available by the upstream operation.  If the action modifies shared state, it is responsible for providing the required synchronization.</p></div>
            <div data-type="tag">This method exists mainly to support debugging, where you want to see the elements as they flow past a certain point in a pipeline: <pre> {@code
    Stream.of("one", "two", "three", "four")
        .filter(e -&gt; e.length() &gt; 3)
        .peek(e -&gt; System.out.println("Filtered value: " + e))
        .map(String::toUpperCase)
        .peek(e -&gt; System.out.println("Mapped value: " + e))
        .collect(Collectors.toList());
}</pre></div>
            <div data-type="tag" data-parameter-name="action">a <a href="package-summary.html#NonInterference"> non-interfering</a> action to perform on the elements as they are consumed from the stream</div>
            <div data-type="tag">the new stream</div>
          </div>
          <div data-type="method" data-name="limit(long)">
            <div data-type="text">Returns a stream consisting of the elements of this stream, truncated to be no longer than  {@code maxSize} in length. <p>This is a <a href="package-summary.html#StreamOps">short-circuiting stateful intermediate operation</a>.</p></div>
            <div data-type="tag">While  {@code limit()} is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of  {@code maxSize}, since  {@code limit(n)} is constrained to return not just any <em>n</em> elements, but the <em>first n</em> elements in the encounter order.  Using an unordered stream source (such as  {@link #generate(Supplier)}) or removing the ordering constraint with  {@link #unordered()} may result in significant speedups of  {@code limit()} in parallel pipelines, if the semantics of your situation permit.  If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with {@code limit()} in parallel pipelines, switching to sequential execution with  {@link #sequential()} may improve performance.</div>
            <div data-type="tag" data-parameter-name="maxSize">the number of elements the stream should be limited to</div>
            <div data-type="tag">the new stream</div>
            <div data-type="tag" data-exception-name="IllegalArgumentException">if  {@code maxSize} is negative</div>
          </div>
          <div data-type="method" data-name="skip(long)">
            <div data-type="text">Returns a stream consisting of the remaining elements of this stream after discarding the first  {@code n} elements of the stream. If this stream contains fewer than  {@code n} elements then an empty stream will be returned. <p>This is a <a href="package-summary.html#StreamOps">stateful intermediate operation</a>.</p></div>
            <div data-type="tag">While  {@code skip()} is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of  {@code n}, since  {@code skip(n)} is constrained to skip not just any <em>n</em> elements, but the <em>first n</em> elements in the encounter order.  Using an unordered stream source (such as  {@link #generate(Supplier)}) or removing the ordering constraint with  {@link #unordered()} may result in significant speedups of  {@code skip()} in parallel pipelines, if the semantics of your situation permit.  If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with {@code skip()} in parallel pipelines, switching to sequential execution with  {@link #sequential()} may improve performance.</div>
            <div data-type="tag" data-parameter-name="n">the number of leading elements to skip</div>
            <div data-type="tag">the new stream</div>
            <div data-type="tag" data-exception-name="IllegalArgumentException">if  {@code n} is negative</div>
          </div>
          <div data-type="method" data-name="forEach(java.util.function.Consumer&lt;? super T&gt;)">
            <div data-type="text">Performs an action for each element of this stream. <p>This is a <a href="package-summary.html#StreamOps">terminal operation</a>. </p><p>The behavior of this operation is explicitly nondeterministic. For parallel stream pipelines, this operation does <em>not</em> guarantee to respect the encounter order of the stream, as doing so would sacrifice the benefit of parallelism.  For any given element, the action may be performed at whatever time and in whatever thread the library chooses.  If the action accesses shared state, it is responsible for providing the required synchronization.</p></div>
            <div data-type="tag" data-parameter-name="action">a <a href="package-summary.html#NonInterference"> non-interfering</a> action to perform on the elements</div>
          </div>
          <div data-type="method" data-name="forEachOrdered(java.util.function.Consumer&lt;? super T&gt;)">
            <div data-type="text">Performs an action for each element of this stream, in the encounter order of the stream if the stream has a defined encounter order. <p>This is a <a href="package-summary.html#StreamOps">terminal operation</a>. </p><p>This operation processes the elements one at a time, in encounter order if one exists.  Performing the action for one element <a href="../concurrent/package-summary.html#MemoryVisibility"><i>happens-before</i></a> performing the action for subsequent elements, but for any given element, the action may be performed in whatever thread the library chooses.</p></div>
            <div data-type="tag" data-parameter-name="action">a <a href="package-summary.html#NonInterference"> non-interfering</a> action to perform on the elements</div>
            <div data-type="tag">#forEach(Consumer)</div>
          </div>
          <div data-type="method" data-name="toArray()">
            <div data-type="text">Returns an array containing the elements of this stream. <p>This is a <a href="package-summary.html#StreamOps">terminal operation</a>.</p></div>
            <div data-type="tag">an array containing the elements of this stream</div>
          </div>
          <div data-type="method" data-name="toArray(java.util.function.IntFunction&lt;A[]&gt;)">
            <div data-type="text">Returns an array containing the elements of this stream, using the provided  {@code generator} function to allocate the returned array, as well as any additional arrays that might be required for a partitioned execution or for resizing. <p>This is a <a href="package-summary.html#StreamOps">terminal operation</a>.</p></div>
            <div data-type="tag">The generator function takes an integer, which is the size of the desired array, and produces an array of the desired size.  This can be concisely expressed with an array constructor reference: <pre> {@code
    Person[] men = people.stream()
                         .filter(p -&gt; p.getGender() == MALE)
                         .toArray(Person[]::new);
}</pre></div>
            <div data-type="tag" data-parameter-name="A" data-is-type-parameter="data-is-type-parameter">the element type of the resulting array</div>
            <div data-type="tag" data-parameter-name="generator">a function which produces a new array of the desired type and the provided length</div>
            <div data-type="tag">an array containing the elements in this stream</div>
            <div data-type="tag" data-exception-name="ArrayStoreException">if the runtime type of the array returned from the array generator is not a supertype of the runtime type of every element in this stream</div>
          </div>
          <div data-type="method" data-name="reduce(T, java.util.function.BinaryOperator&lt;T&gt;)">
            <div data-type="text">Performs a <a href="package-summary.html#Reduction">reduction</a> on the elements of this stream, using the provided identity value and an <a href="package-summary.html#Associativity">associative</a> accumulation function, and returns the reduced value.  This is equivalent to: <pre> {@code
    T result = identity;
    for (T element : this stream)
        result = accumulator.apply(result, element)
    return result;
}</pre> but is not constrained to execute sequentially. <p>The  {@code identity} value must be an identity for the accumulator function. This means that for all  {@code t}, {@code accumulator.apply(identity, t)} is equal to  {@code t}. The  {@code accumulator} function must be an <a href="package-summary.html#Associativity">associative</a> function. </p><p>This is a <a href="package-summary.html#StreamOps">terminal operation</a>.</p></div>
            <div data-type="tag">Sum, min, max, average, and string concatenation are all special cases of reduction. Summing a stream of numbers can be expressed as: <pre> {@code
    Integer sum = integers.reduce(0, (a, b) -&gt; a+b);
}</pre> or: <pre> {@code
    Integer sum = integers.reduce(0, Integer::sum);
}</pre> <p>While this may seem a more roundabout way to perform an aggregation compared to simply mutating a running total in a loop, reduction operations parallelize more gracefully, without needing additional synchronization and with greatly reduced risk of data races.</p></div>
            <div data-type="tag" data-parameter-name="identity">the identity value for the accumulating function</div>
            <div data-type="tag" data-parameter-name="accumulator">an <a href="package-summary.html#Associativity">associative</a>, <a href="package-summary.html#NonInterference">non-interfering</a>, <a href="package-summary.html#Statelessness">stateless</a> function for combining two values</div>
            <div data-type="tag">the result of the reduction</div>
          </div>
          <div data-type="method" data-name="reduce(java.util.function.BinaryOperator&lt;T&gt;)">
            <div data-type="text">Performs a <a href="package-summary.html#Reduction">reduction</a> on the elements of this stream, using an <a href="package-summary.html#Associativity">associative</a> accumulation function, and returns an  {@code Optional} describing the reduced value, if any. This is equivalent to: <pre> {@code
    boolean foundAny = false;
    T result = null;
    for (T element : this stream) {
        if (!foundAny) {
            foundAny = true;
            result = element;
        }
        else
            result = accumulator.apply(result, element);
    }
    return foundAny ? Optional.of(result) : Optional.empty();
}</pre> but is not constrained to execute sequentially. <p>The  {@code accumulator} function must be an <a href="package-summary.html#Associativity">associative</a> function. </p><p>This is a <a href="package-summary.html#StreamOps">terminal operation</a>.</p></div>
            <div data-type="tag" data-parameter-name="accumulator">an <a href="package-summary.html#Associativity">associative</a>, <a href="package-summary.html#NonInterference">non-interfering</a>, <a href="package-summary.html#Statelessness">stateless</a> function for combining two values</div>
            <div data-type="tag">an  {@link Optional} describing the result of the reduction</div>
            <div data-type="tag" data-exception-name="NullPointerException">if the result of the reduction is null</div>
            <div data-type="tag">#reduce(Object, BinaryOperator)</div>
            <div data-type="tag">#min(Comparator)</div>
            <div data-type="tag">#max(Comparator)</div>
          </div>
          <div data-type="method" data-name="reduce(U, java.util.function.BiFunction&lt;U, ? super T, U&gt;, java.util.function.BinaryOperator&lt;U&gt;)">
            <div data-type="text">Performs a <a href="package-summary.html#Reduction">reduction</a> on the elements of this stream, using the provided identity, accumulation and combining functions.  This is equivalent to: <pre> {@code
    U result = identity;
    for (T element : this stream)
        result = accumulator.apply(result, element)
    return result;
}</pre> but is not constrained to execute sequentially. <p>The  {@code identity} value must be an identity for the combiner function.  This means that for all  {@code u},  {@code combiner(identity, u)} is equal to  {@code u}.  Additionally, the  {@code combiner} function must be compatible with the  {@code accumulator} function; for all {@code u} and  {@code t}, the following must hold: </p><pre> {@code
    combiner.apply(u, accumulator.apply(identity, t)) == accumulator.apply(u, t)
}</pre> <p>This is a <a href="package-summary.html#StreamOps">terminal operation</a>.</p></div>
            <div data-type="tag">Many reductions using this form can be represented more simply by an explicit combination of  {@code map} and  {@code reduce} operations. The  {@code accumulator} function acts as a fused mapper and accumulator, which can sometimes be more efficient than separate mapping and reduction, such as when knowing the previously reduced value allows you to avoid some computation.</div>
            <div data-type="tag" data-parameter-name="U" data-is-type-parameter="data-is-type-parameter">The type of the result</div>
            <div data-type="tag" data-parameter-name="identity">the identity value for the combiner function</div>
            <div data-type="tag" data-parameter-name="accumulator">an <a href="package-summary.html#Associativity">associative</a>, <a href="package-summary.html#NonInterference">non-interfering</a>, <a href="package-summary.html#Statelessness">stateless</a> function for incorporating an additional element into a result</div>
            <div data-type="tag" data-parameter-name="combiner">an <a href="package-summary.html#Associativity">associative</a>, <a href="package-summary.html#NonInterference">non-interfering</a>, <a href="package-summary.html#Statelessness">stateless</a> function for combining two values, which must be compatible with the accumulator function</div>
            <div data-type="tag">the result of the reduction</div>
            <div data-type="tag">#reduce(BinaryOperator)</div>
            <div data-type="tag">#reduce(Object, BinaryOperator)</div>
          </div>
          <div data-type="method" data-name="collect(java.util.function.Supplier&lt;R&gt;, java.util.function.BiConsumer&lt;R, ? super T&gt;, java.util.function.BiConsumer&lt;R, R&gt;)">
            <div data-type="text">Performs a <a href="package-summary.html#MutableReduction">mutable reduction</a> operation on the elements of this stream.  A mutable reduction is one in which the reduced value is a mutable result container, such as an  {@code ArrayList}, and elements are incorporated by updating the state of the result rather than by replacing the result.  This produces a result equivalent to: <pre> {@code
    R result = supplier.get();
    for (T element : this stream)
        accumulator.accept(result, element);
    return result;
}</pre> <p>Like  {@link #reduce(Object, BinaryOperator)},  {@code collect} operations can be parallelized without requiring additional synchronization. </p><p>This is a <a href="package-summary.html#StreamOps">terminal operation</a>.</p></div>
            <div data-type="tag">There are many existing classes in the JDK whose signatures are well-suited for use with method references as arguments to  {@code collect()}. For example, the following will accumulate strings into an  {@code ArrayList}: <pre> {@code
    List&lt;String&gt; asList = stringStream.collect(ArrayList::new, ArrayList::add,
                                               ArrayList::addAll);
}</pre> <p>The following will take a stream of strings and concatenates them into a single string: </p><pre> {@code
    String concat = stringStream.collect(StringBuilder::new, StringBuilder::append,
                                         StringBuilder::append)
                                .toString();
}</pre></div>
            <div data-type="tag" data-parameter-name="R" data-is-type-parameter="data-is-type-parameter">type of the result</div>
            <div data-type="tag" data-parameter-name="supplier">a function that creates a new result container. For a parallel execution, this function may be called multiple times and must return a fresh value each time.</div>
            <div data-type="tag" data-parameter-name="accumulator">an <a href="package-summary.html#Associativity">associative</a>, <a href="package-summary.html#NonInterference">non-interfering</a>, <a href="package-summary.html#Statelessness">stateless</a> function for incorporating an additional element into a result</div>
            <div data-type="tag" data-parameter-name="combiner">an <a href="package-summary.html#Associativity">associative</a>, <a href="package-summary.html#NonInterference">non-interfering</a>, <a href="package-summary.html#Statelessness">stateless</a> function for combining two values, which must be compatible with the accumulator function</div>
            <div data-type="tag">the result of the reduction</div>
          </div>
          <div data-type="method" data-name="collect(java.util.stream.Collector&lt;? super T, A, R&gt;)">
            <div data-type="text">Performs a <a href="package-summary.html#MutableReduction">mutable reduction</a> operation on the elements of this stream using a {@code Collector}.  A  {@code Collector} encapsulates the functions used as arguments to {@link #collect(Supplier, BiConsumer, BiConsumer)}, allowing for reuse of collection strategies and composition of collect operations such as multiple-level grouping or partitioning. <p>If the stream is parallel, and the  {@code Collector} is  {@link Collector.Characteristics#CONCURRENT concurrent}, and either the stream is unordered or the collector is {@link Collector.Characteristics#UNORDERED unordered}, then a concurrent reduction will be performed (see  {@link Collector} for details on concurrent reduction.) </p><p>This is a <a href="package-summary.html#StreamOps">terminal operation</a>. </p><p>When executed in parallel, multiple intermediate results may be instantiated, populated, and merged so as to maintain isolation of mutable data structures.  Therefore, even when executed in parallel with non-thread-safe data structures (such as  {@code ArrayList}), no additional synchronization is needed for a parallel reduction.</p></div>
            <div data-type="tag">The following will accumulate strings into an ArrayList: <pre> {@code
    List&lt;String&gt; asList = stringStream.collect(Collectors.toList());
}</pre> <p>The following will classify  {@code Person} objects by city: </p><pre> {@code
    Map&lt;String, List&lt;Person&gt;&gt; peopleByCity
        = personStream.collect(Collectors.groupingBy(Person::getCity));
}</pre> <p>The following will classify  {@code Person} objects by state and city, cascading two  {@code Collector}s together: </p><pre> {@code
    Map&lt;String, Map&lt;String, List&lt;Person&gt;&gt;&gt; peopleByStateAndCity
        = personStream.collect(Collectors.groupingBy(Person::getState,
                                                     Collectors.groupingBy(Person::getCity)));
}</pre></div>
            <div data-type="tag" data-parameter-name="R" data-is-type-parameter="data-is-type-parameter">the type of the result</div>
            <div data-type="tag" data-parameter-name="A" data-is-type-parameter="data-is-type-parameter">the intermediate accumulation type of the  {@code Collector}</div>
            <div data-type="tag" data-parameter-name="collector">the  {@code Collector} describing the reduction</div>
            <div data-type="tag">the result of the reduction</div>
            <div data-type="tag">#collect(Supplier, BiConsumer, BiConsumer)</div>
            <div data-type="tag">Collectors</div>
          </div>
          <div data-type="method" data-name="min(java.util.Comparator&lt;? super T&gt;)">
            <div data-type="text">Returns the minimum element of this stream according to the provided {@code Comparator}.  This is a special case of a <a href="package-summary.html#Reduction">reduction</a>. <p>This is a <a href="package-summary.html#StreamOps">terminal operation</a>.</p></div>
            <div data-type="tag" data-parameter-name="comparator">a <a href="package-summary.html#NonInterference">non-interfering</a>, <a href="package-summary.html#Statelessness">stateless</a> {@code Comparator} to compare elements of this stream</div>
            <div data-type="tag">an  {@code Optional} describing the minimum element of this stream, or an empty  {@code Optional} if the stream is empty</div>
            <div data-type="tag" data-exception-name="NullPointerException">if the minimum element is null</div>
          </div>
          <div data-type="method" data-name="max(java.util.Comparator&lt;? super T&gt;)">
            <div data-type="text">Returns the maximum element of this stream according to the provided {@code Comparator}.  This is a special case of a <a href="package-summary.html#Reduction">reduction</a>. <p>This is a <a href="package-summary.html#StreamOps">terminal operation</a>.</p></div>
            <div data-type="tag" data-parameter-name="comparator">a <a href="package-summary.html#NonInterference">non-interfering</a>, <a href="package-summary.html#Statelessness">stateless</a> {@code Comparator} to compare elements of this stream</div>
            <div data-type="tag">an  {@code Optional} describing the maximum element of this stream, or an empty  {@code Optional} if the stream is empty</div>
            <div data-type="tag" data-exception-name="NullPointerException">if the maximum element is null</div>
          </div>
          <div data-type="method" data-name="count()">
            <div data-type="text">Returns the count of elements in this stream.  This is a special case of a <a href="package-summary.html#Reduction">reduction</a> and is equivalent to: <pre> {@code
    return mapToLong(e -&gt; 1L).sum();
}</pre> <p>This is a <a href="package-summary.html#StreamOps">terminal operation</a>.</p></div>
            <div data-type="tag">the count of elements in this stream</div>
          </div>
          <div data-type="method" data-name="anyMatch(java.util.function.Predicate&lt;? super T&gt;)">
            <div data-type="text">Returns whether any elements of this stream match the provided predicate.  May not evaluate the predicate on all elements if not necessary for determining the result.  If the stream is empty then {@code false} is returned and the predicate is not evaluated. <p>This is a <a href="package-summary.html#StreamOps">short-circuiting terminal operation</a>.</p></div>
            <div data-type="tag">This method evaluates the <em>existential quantification</em> of the predicate over the elements of the stream (for some x P(x)).</div>
            <div data-type="tag" data-parameter-name="predicate">a <a href="package-summary.html#NonInterference">non-interfering</a>, <a href="package-summary.html#Statelessness">stateless</a> predicate to apply to elements of this stream</div>
            <div data-type="tag"> {@code true} if any elements of the stream match the provided predicate, otherwise  {@code false}</div>
          </div>
          <div data-type="method" data-name="allMatch(java.util.function.Predicate&lt;? super T&gt;)">
            <div data-type="text">Returns whether all elements of this stream match the provided predicate. May not evaluate the predicate on all elements if not necessary for determining the result.  If the stream is empty then  {@code true} is returned and the predicate is not evaluated. <p>This is a <a href="package-summary.html#StreamOps">short-circuiting terminal operation</a>.</p></div>
            <div data-type="tag">This method evaluates the <em>universal quantification</em> of the predicate over the elements of the stream (for all x P(x)).  If the stream is empty, the quantification is said to be <em>vacuously satisfied</em> and is always  {@code true} (regardless of P(x)).</div>
            <div data-type="tag" data-parameter-name="predicate">a <a href="package-summary.html#NonInterference">non-interfering</a>, <a href="package-summary.html#Statelessness">stateless</a> predicate to apply to elements of this stream</div>
            <div data-type="tag"> {@code true} if either all elements of the stream match the provided predicate or the stream is empty, otherwise  {@code false}</div>
          </div>
          <div data-type="method" data-name="noneMatch(java.util.function.Predicate&lt;? super T&gt;)">
            <div data-type="text">Returns whether no elements of this stream match the provided predicate. May not evaluate the predicate on all elements if not necessary for determining the result.  If the stream is empty then  {@code true} is returned and the predicate is not evaluated. <p>This is a <a href="package-summary.html#StreamOps">short-circuiting terminal operation</a>.</p></div>
            <div data-type="tag">This method evaluates the <em>universal quantification</em> of the negated predicate over the elements of the stream (for all x ~P(x)).  If the stream is empty, the quantification is said to be vacuously satisfied and is always  {@code true}, regardless of P(x).</div>
            <div data-type="tag" data-parameter-name="predicate">a <a href="package-summary.html#NonInterference">non-interfering</a>, <a href="package-summary.html#Statelessness">stateless</a> predicate to apply to elements of this stream</div>
            <div data-type="tag"> {@code true} if either no elements of the stream match the provided predicate or the stream is empty, otherwise  {@code false}</div>
          </div>
          <div data-type="method" data-name="findFirst()">
            <div data-type="text">Returns an  {@link Optional} describing the first element of this stream, or an empty  {@code Optional} if the stream is empty.  If the stream has no encounter order, then any element may be returned. <p>This is a <a href="package-summary.html#StreamOps">short-circuiting terminal operation</a>.</p></div>
            <div data-type="tag">an  {@code Optional} describing the first element of this stream, or an empty  {@code Optional} if the stream is empty</div>
            <div data-type="tag" data-exception-name="NullPointerException">if the element selected is null</div>
          </div>
          <div data-type="method" data-name="findAny()">
            <div data-type="text">Returns an  {@link Optional} describing some element of the stream, or an empty  {@code Optional} if the stream is empty. <p>This is a <a href="package-summary.html#StreamOps">short-circuiting terminal operation</a>. </p><p>The behavior of this operation is explicitly nondeterministic; it is free to select any element in the stream.  This is to allow for maximal performance in parallel operations; the cost is that multiple invocations on the same source may not return the same result.  (If a stable result is desired, use  {@link #findFirst()} instead.)</p></div>
            <div data-type="tag">an  {@code Optional} describing some element of this stream, or an empty  {@code Optional} if the stream is empty</div>
            <div data-type="tag" data-exception-name="NullPointerException">if the element selected is null</div>
            <div data-type="tag">#findFirst()</div>
          </div>
          <div data-type="method" data-name="builder()">
            <div data-type="text">Returns a builder for a  {@code Stream}.</div>
            <div data-type="tag" data-parameter-name="T" data-is-type-parameter="data-is-type-parameter">type of elements</div>
            <div data-type="tag">a stream builder</div>
          </div>
          <div data-type="method" data-name="empty()">
            <div data-type="text">Returns an empty sequential  {@code Stream}.</div>
            <div data-type="tag" data-parameter-name="T" data-is-type-parameter="data-is-type-parameter">the type of stream elements</div>
            <div data-type="tag">an empty sequential stream</div>
          </div>
          <div data-type="method" data-name="of(T)">
            <div data-type="text">Returns a sequential  {@code Stream} containing a single element.</div>
            <div data-type="tag" data-parameter-name="t">the single element</div>
            <div data-type="tag" data-parameter-name="T" data-is-type-parameter="data-is-type-parameter">the type of stream elements</div>
            <div data-type="tag">a singleton sequential stream</div>
          </div>
          <div data-type="method" data-name="of(T...)">
            <div data-type="text">Returns a sequential ordered stream whose elements are the specified values.</div>
            <div data-type="tag" data-parameter-name="T" data-is-type-parameter="data-is-type-parameter">the type of stream elements</div>
            <div data-type="tag" data-parameter-name="values">the elements of the new stream</div>
            <div data-type="tag">the new stream</div>
          </div>
          <div data-type="method" data-name="iterate(T, java.util.function.UnaryOperator&lt;T&gt;)">
            <div data-type="text">Returns an infinite sequential ordered  {@code Stream} produced by iterative application of a function  {@code f} to an initial element  {@code seed}, producing a  {@code Stream} consisting of  {@code seed},  {@code f(seed)}, {@code f(f(seed))}, etc. <p>The first element (position  {@code 0}) in the  {@code Stream} will be the provided  {@code seed}.  For  {@code n &gt; 0}, the element at position {@code n}, will be the result of applying the function  {@code f} to the element at position  {@code n - 1}.</p></div>
            <div data-type="tag" data-parameter-name="T" data-is-type-parameter="data-is-type-parameter">the type of stream elements</div>
            <div data-type="tag" data-parameter-name="seed">the initial element</div>
            <div data-type="tag" data-parameter-name="f">a function to be applied to to the previous element to produce a new element</div>
            <div data-type="tag">a new sequential  {@code Stream}</div>
          </div>
          <div data-type="method" data-name="generate(java.util.function.Supplier&lt;T&gt;)">
            <div data-type="text">Returns an infinite sequential unordered stream where each element is generated by the provided  {@code Supplier}.  This is suitable for generating constant streams, streams of random elements, etc.</div>
            <div data-type="tag" data-parameter-name="T" data-is-type-parameter="data-is-type-parameter">the type of stream elements</div>
            <div data-type="tag" data-parameter-name="s">the  {@code Supplier} of generated elements</div>
            <div data-type="tag">a new infinite sequential unordered  {@code Stream}</div>
          </div>
          <div data-type="method" data-name="concat(java.util.stream.Stream&lt;? extends T&gt;, java.util.stream.Stream&lt;? extends T&gt;)">
            <div data-type="text">Creates a lazily concatenated stream whose elements are all the elements of the first stream followed by all the elements of the second stream.  The resulting stream is ordered if both of the input streams are ordered, and parallel if either of the input streams is parallel.  When the resulting stream is closed, the close handlers for both input streams are invoked.</div>
            <div data-type="tag">Use caution when constructing streams from repeated concatenation. Accessing an element of a deeply concatenated stream can result in deep call chains, or even  {@code StackOverflowException}.</div>
            <div data-type="tag" data-parameter-name="T" data-is-type-parameter="data-is-type-parameter">The type of stream elements</div>
            <div data-type="tag" data-parameter-name="a">the first stream</div>
            <div data-type="tag" data-parameter-name="b">the second stream</div>
            <div data-type="tag">the concatenation of the two input streams</div>
          </div>
        </div>
        <div data-type="class" data-name="java.util.stream.Stream.Builder">
          <div data-type="text">A mutable builder for a  {@code Stream}.  This allows the creation of a {@code Stream} by generating elements individually and adding them to the {@code Builder} (without the copying overhead that comes from using an  {@code ArrayList} as a temporary buffer.) <p>A stream builder has a lifecycle, which starts in a building phase, during which elements can be added, and then transitions to a built phase, after which elements may not be added.  The built phase begins when the  {@link #build()} method is called, which creates an ordered {@code Stream} whose elements are the elements that were added to the stream builder, in the order they were added.</p></div>
          <div data-type="tag" data-parameter-name="T" data-is-type-parameter="data-is-type-parameter">the type of stream elements</div>
          <div data-type="tag">Stream#builder()</div>
          <div data-type="tag">1.8</div>
          <div data-type="method" data-name="accept(T)">
            <div data-type="text">Adds an element to the stream being built.</div>
            <div data-type="tag" data-exception-name="IllegalStateException">if the builder has already transitioned to the built state</div>
          </div>
          <div data-type="method" data-name="add(T)">
            <div data-type="text">Adds an element to the stream being built.</div>
            <div data-type="tag">The default implementation behaves as if: <pre> {@code
    accept(t)
    return this;
}</pre></div>
            <div data-type="tag" data-parameter-name="t">the element to add</div>
            <div data-type="tag"> {@code this} builder</div>
            <div data-type="tag" data-exception-name="IllegalStateException">if the builder has already transitioned to the built state</div>
          </div>
          <div data-type="method" data-name="build()">
            <div data-type="text">Builds the stream, transitioning this builder to the built state. An  {@code IllegalStateException} is thrown if there are further attempts to operate on the builder after it has entered the built state.</div>
            <div data-type="tag">the built stream</div>
            <div data-type="tag" data-exception-name="IllegalStateException">if the builder has already transitioned to the built state</div>
          </div>
        </div>
        <div data-type="class" data-name="java.util.stream.LongStream">
          <div data-type="text">A sequence of primitive long-valued elements supporting sequential and parallel aggregate operations.  This is the  {@code long} primitive specialization of {@link Stream}. <p>The following example illustrates an aggregate operation using {@link Stream} and  {@link LongStream}, computing the sum of the weights of the red widgets: </p><pre> {@code
    long sum = widgets.stream()
                      .filter(w -&gt; w.getColor() == RED)
                      .mapToLong(w -&gt; w.getWeight())
                      .sum();
}</pre> See the class documentation for  {@link Stream} and the package documentation for <a href="package-summary.html">java.util.stream</a> for additional specification of streams, stream operations, stream pipelines, and parallelism.</div>
          <div data-type="tag">1.8</div>
          <div data-type="tag">Stream</div>
          <div data-type="tag">
            <a href="package-summary.html">java.util.stream</a>
          </div>
          <div data-type="method" data-name="filter(java.util.function.LongPredicate)">
            <div data-type="text">Returns a stream consisting of the elements of this stream that match the given predicate. <p>This is an <a href="package-summary.html#StreamOps">intermediate operation</a>.</p></div>
            <div data-type="tag" data-parameter-name="predicate">a <a href="package-summary.html#NonInterference">non-interfering</a>, <a href="package-summary.html#Statelessness">stateless</a> predicate to apply to each element to determine if it should be included</div>
            <div data-type="tag">the new stream</div>
          </div>
          <div data-type="method" data-name="map(java.util.function.LongUnaryOperator)">
            <div data-type="text">Returns a stream consisting of the results of applying the given function to the elements of this stream. <p>This is an <a href="package-summary.html#StreamOps">intermediate operation</a>.</p></div>
            <div data-type="tag" data-parameter-name="mapper">a <a href="package-summary.html#NonInterference">non-interfering</a>, <a href="package-summary.html#Statelessness">stateless</a> function to apply to each element</div>
            <div data-type="tag">the new stream</div>
          </div>
          <div data-type="method" data-name="mapToObj(java.util.function.LongFunction&lt;? extends U&gt;)">
            <div data-type="text">Returns an object-valued  {@code Stream} consisting of the results of applying the given function to the elements of this stream. <p>This is an <a href="package-summary.html#StreamOps"> intermediate operation</a>.</p></div>
            <div data-type="tag" data-parameter-name="U" data-is-type-parameter="data-is-type-parameter">the element type of the new stream</div>
            <div data-type="tag" data-parameter-name="mapper">a <a href="package-summary.html#NonInterference">non-interfering</a>, <a href="package-summary.html#Statelessness">stateless</a> function to apply to each element</div>
            <div data-type="tag">the new stream</div>
          </div>
          <div data-type="method" data-name="mapToInt(java.util.function.LongToIntFunction)">
            <div data-type="text">Returns an  {@code IntStream} consisting of the results of applying the given function to the elements of this stream. <p>This is an <a href="package-summary.html#StreamOps">intermediate operation</a>.</p></div>
            <div data-type="tag" data-parameter-name="mapper">a <a href="package-summary.html#NonInterference">non-interfering</a>, <a href="package-summary.html#Statelessness">stateless</a> function to apply to each element</div>
            <div data-type="tag">the new stream</div>
          </div>
          <div data-type="method" data-name="mapToDouble(java.util.function.LongToDoubleFunction)">
            <div data-type="text">Returns a  {@code DoubleStream} consisting of the results of applying the given function to the elements of this stream. <p>This is an <a href="package-summary.html#StreamOps">intermediate operation</a>.</p></div>
            <div data-type="tag" data-parameter-name="mapper">a <a href="package-summary.html#NonInterference">non-interfering</a>, <a href="package-summary.html#Statelessness">stateless</a> function to apply to each element</div>
            <div data-type="tag">the new stream</div>
          </div>
          <div data-type="method" data-name="flatMap(java.util.function.LongFunction&lt;? extends java.util.stream.LongStream&gt;)">
            <div data-type="text">Returns a stream consisting of the results of replacing each element of this stream with the contents of a mapped stream produced by applying the provided mapping function to each element.  Each mapped stream is {@link java.util.stream.BaseStream#close() closed} after its contents have been placed into this stream.  (If a mapped stream is  {@code null} an empty stream is used, instead.) <p>This is an <a href="package-summary.html#StreamOps">intermediate operation</a>.</p></div>
            <div data-type="tag" data-parameter-name="mapper">a <a href="package-summary.html#NonInterference">non-interfering</a>, <a href="package-summary.html#Statelessness">stateless</a> function to apply to each element which produces a {@code LongStream} of new values</div>
            <div data-type="tag">the new stream</div>
            <div data-type="tag">Stream#flatMap(Function)</div>
          </div>
          <div data-type="method" data-name="distinct()">
            <div data-type="text">Returns a stream consisting of the distinct elements of this stream. <p>This is a <a href="package-summary.html#StreamOps">stateful intermediate operation</a>.</p></div>
            <div data-type="tag">the new stream</div>
          </div>
          <div data-type="method" data-name="sorted()">
            <div data-type="text">Returns a stream consisting of the elements of this stream in sorted order. <p>This is a <a href="package-summary.html#StreamOps">stateful intermediate operation</a>.</p></div>
            <div data-type="tag">the new stream</div>
          </div>
          <div data-type="method" data-name="peek(java.util.function.LongConsumer)">
            <div data-type="text">Returns a stream consisting of the elements of this stream, additionally performing the provided action on each element as elements are consumed from the resulting stream. <p>This is an <a href="package-summary.html#StreamOps">intermediate operation</a>. </p><p>For parallel stream pipelines, the action may be called at whatever time and in whatever thread the element is made available by the upstream operation.  If the action modifies shared state, it is responsible for providing the required synchronization.</p></div>
            <div data-type="tag">This method exists mainly to support debugging, where you want to see the elements as they flow past a certain point in a pipeline: <pre> {@code
    LongStream.of(1, 2, 3, 4)
        .filter(e -&gt; e &gt; 2)
        .peek(e -&gt; System.out.println("Filtered value: " + e))
        .map(e -&gt; e * e)
        .peek(e -&gt; System.out.println("Mapped value: " + e))
        .sum();
}</pre></div>
            <div data-type="tag" data-parameter-name="action">a <a href="package-summary.html#NonInterference"> non-interfering</a> action to perform on the elements as they are consumed from the stream</div>
            <div data-type="tag">the new stream</div>
          </div>
          <div data-type="method" data-name="limit(long)">
            <div data-type="text">Returns a stream consisting of the elements of this stream, truncated to be no longer than  {@code maxSize} in length. <p>This is a <a href="package-summary.html#StreamOps">short-circuiting stateful intermediate operation</a>.</p></div>
            <div data-type="tag">While  {@code limit()} is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of  {@code maxSize}, since  {@code limit(n)} is constrained to return not just any <em>n</em> elements, but the <em>first n</em> elements in the encounter order.  Using an unordered stream source (such as  {@link #generate(LongSupplier)}) or removing the ordering constraint with  {@link #unordered()} may result in significant speedups of  {@code limit()} in parallel pipelines, if the semantics of your situation permit.  If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with {@code limit()} in parallel pipelines, switching to sequential execution with  {@link #sequential()} may improve performance.</div>
            <div data-type="tag" data-parameter-name="maxSize">the number of elements the stream should be limited to</div>
            <div data-type="tag">the new stream</div>
            <div data-type="tag" data-exception-name="IllegalArgumentException">if  {@code maxSize} is negative</div>
          </div>
          <div data-type="method" data-name="skip(long)">
            <div data-type="text">Returns a stream consisting of the remaining elements of this stream after discarding the first  {@code n} elements of the stream. If this stream contains fewer than  {@code n} elements then an empty stream will be returned. <p>This is a <a href="package-summary.html#StreamOps">stateful intermediate operation</a>.</p></div>
            <div data-type="tag">While  {@code skip()} is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of  {@code n}, since  {@code skip(n)} is constrained to skip not just any <em>n</em> elements, but the <em>first n</em> elements in the encounter order.  Using an unordered stream source (such as  {@link #generate(LongSupplier)}) or removing the ordering constraint with  {@link #unordered()} may result in significant speedups of  {@code skip()} in parallel pipelines, if the semantics of your situation permit.  If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with {@code skip()} in parallel pipelines, switching to sequential execution with  {@link #sequential()} may improve performance.</div>
            <div data-type="tag" data-parameter-name="n">the number of leading elements to skip</div>
            <div data-type="tag">the new stream</div>
            <div data-type="tag" data-exception-name="IllegalArgumentException">if  {@code n} is negative</div>
          </div>
          <div data-type="method" data-name="forEach(java.util.function.LongConsumer)">
            <div data-type="text">Performs an action for each element of this stream. <p>This is a <a href="package-summary.html#StreamOps">terminal operation</a>. </p><p>For parallel stream pipelines, this operation does <em>not</em> guarantee to respect the encounter order of the stream, as doing so would sacrifice the benefit of parallelism.  For any given element, the action may be performed at whatever time and in whatever thread the library chooses.  If the action accesses shared state, it is responsible for providing the required synchronization.</p></div>
            <div data-type="tag" data-parameter-name="action">a <a href="package-summary.html#NonInterference"> non-interfering</a> action to perform on the elements</div>
          </div>
          <div data-type="method" data-name="forEachOrdered(java.util.function.LongConsumer)">
            <div data-type="text">Performs an action for each element of this stream, guaranteeing that each element is processed in encounter order for streams that have a defined encounter order. <p>This is a <a href="package-summary.html#StreamOps">terminal operation</a>.</p></div>
            <div data-type="tag" data-parameter-name="action">a <a href="package-summary.html#NonInterference"> non-interfering</a> action to perform on the elements</div>
            <div data-type="tag">#forEach(LongConsumer)</div>
          </div>
          <div data-type="method" data-name="toArray()">
            <div data-type="text">Returns an array containing the elements of this stream. <p>This is a <a href="package-summary.html#StreamOps">terminal operation</a>.</p></div>
            <div data-type="tag">an array containing the elements of this stream</div>
          </div>
          <div data-type="method" data-name="reduce(long, java.util.function.LongBinaryOperator)">
            <div data-type="text">Performs a <a href="package-summary.html#Reduction">reduction</a> on the elements of this stream, using the provided identity value and an <a href="package-summary.html#Associativity">associative</a> accumulation function, and returns the reduced value.  This is equivalent to: <pre> {@code
    long result = identity;
    for (long element : this stream)
        result = accumulator.applyAsLong(result, element)
    return result;
}</pre> but is not constrained to execute sequentially. <p>The  {@code identity} value must be an identity for the accumulator function. This means that for all  {@code x}, {@code accumulator.apply(identity, x)} is equal to  {@code x}. The  {@code accumulator} function must be an <a href="package-summary.html#Associativity">associative</a> function. </p><p>This is a <a href="package-summary.html#StreamOps">terminal operation</a>.</p></div>
            <div data-type="tag">Sum, min, max, and average are all special cases of reduction. Summing a stream of numbers can be expressed as: <pre> {@code
    long sum = integers.reduce(0, (a, b) -&gt; a+b);
}</pre> or more compactly: <pre> {@code
    long sum = integers.reduce(0, Long::sum);
}</pre> <p>While this may seem a more roundabout way to perform an aggregation compared to simply mutating a running total in a loop, reduction operations parallelize more gracefully, without needing additional synchronization and with greatly reduced risk of data races.</p></div>
            <div data-type="tag" data-parameter-name="identity">the identity value for the accumulating function</div>
            <div data-type="tag" data-parameter-name="op">an <a href="package-summary.html#Associativity">associative</a>, <a href="package-summary.html#NonInterference">non-interfering</a>, <a href="package-summary.html#Statelessness">stateless</a> function for combining two values</div>
            <div data-type="tag">the result of the reduction</div>
            <div data-type="tag">#sum()</div>
            <div data-type="tag">#min()</div>
            <div data-type="tag">#max()</div>
            <div data-type="tag">#average()</div>
          </div>
          <div data-type="method" data-name="reduce(java.util.function.LongBinaryOperator)">
            <div data-type="text">Performs a <a href="package-summary.html#Reduction">reduction</a> on the elements of this stream, using an <a href="package-summary.html#Associativity">associative</a> accumulation function, and returns an  {@code OptionalLong} describing the reduced value, if any. This is equivalent to: <pre> {@code
    boolean foundAny = false;
    long result = null;
    for (long element : this stream) {
        if (!foundAny) {
            foundAny = true;
            result = element;
        }
        else
            result = accumulator.applyAsLong(result, element);
    }
    return foundAny ? OptionalLong.of(result) : OptionalLong.empty();
}</pre> but is not constrained to execute sequentially. <p>The  {@code accumulator} function must be an <a href="package-summary.html#Associativity">associative</a> function. </p><p>This is a <a href="package-summary.html#StreamOps">terminal operation</a>.</p></div>
            <div data-type="tag" data-parameter-name="op">an <a href="package-summary.html#Associativity">associative</a>, <a href="package-summary.html#NonInterference">non-interfering</a>, <a href="package-summary.html#Statelessness">stateless</a> function for combining two values</div>
            <div data-type="tag">the result of the reduction</div>
            <div data-type="tag">#reduce(long, LongBinaryOperator)</div>
          </div>
          <div data-type="method" data-name="collect(java.util.function.Supplier&lt;R&gt;, java.util.function.ObjLongConsumer&lt;R&gt;, java.util.function.BiConsumer&lt;R, R&gt;)">
            <div data-type="text">Performs a <a href="package-summary.html#MutableReduction">mutable reduction</a> operation on the elements of this stream.  A mutable reduction is one in which the reduced value is a mutable result container, such as an  {@code ArrayList}, and elements are incorporated by updating the state of the result rather than by replacing the result.  This produces a result equivalent to: <pre> {@code
    R result = supplier.get();
    for (long element : this stream)
        accumulator.accept(result, element);
    return result;
}</pre> <p>Like  {@link #reduce(long, LongBinaryOperator)},  {@code collect} operations can be parallelized without requiring additional synchronization. </p><p>This is a <a href="package-summary.html#StreamOps">terminal operation</a>.</p></div>
            <div data-type="tag" data-parameter-name="R" data-is-type-parameter="data-is-type-parameter">type of the result</div>
            <div data-type="tag" data-parameter-name="supplier">a function that creates a new result container. For a parallel execution, this function may be called multiple times and must return a fresh value each time.</div>
            <div data-type="tag" data-parameter-name="accumulator">an <a href="package-summary.html#Associativity">associative</a>, <a href="package-summary.html#NonInterference">non-interfering</a>, <a href="package-summary.html#Statelessness">stateless</a> function for incorporating an additional element into a result</div>
            <div data-type="tag" data-parameter-name="combiner">an <a href="package-summary.html#Associativity">associative</a>, <a href="package-summary.html#NonInterference">non-interfering</a>, <a href="package-summary.html#Statelessness">stateless</a> function for combining two values, which must be compatible with the accumulator function</div>
            <div data-type="tag">the result of the reduction</div>
            <div data-type="tag">Stream#collect(Supplier, BiConsumer, BiConsumer)</div>
          </div>
          <div data-type="method" data-name="sum()">
            <div data-type="text">Returns the sum of elements in this stream.  This is a special case of a <a href="package-summary.html#Reduction">reduction</a> and is equivalent to: <pre> {@code
    return reduce(0, Long::sum);
}</pre> <p>This is a <a href="package-summary.html#StreamOps">terminal operation</a>.</p></div>
            <div data-type="tag">the sum of elements in this stream</div>
          </div>
          <div data-type="method" data-name="min()">
            <div data-type="text">Returns an  {@code OptionalLong} describing the minimum element of this stream, or an empty optional if this stream is empty.  This is a special case of a <a href="package-summary.html#Reduction">reduction</a> and is equivalent to: <pre> {@code
    return reduce(Long::min);
}</pre> <p>This is a <a href="package-summary.html#StreamOps">terminal operation</a>.</p></div>
            <div data-type="tag">an  {@code OptionalLong} containing the minimum element of this stream, or an empty  {@code OptionalLong} if the stream is empty</div>
          </div>
          <div data-type="method" data-name="max()">
            <div data-type="text">Returns an  {@code OptionalLong} describing the maximum element of this stream, or an empty optional if this stream is empty.  This is a special case of a <a href="package-summary.html#Reduction">reduction</a> and is equivalent to: <pre> {@code
    return reduce(Long::max);
}</pre> <p>This is a <a href="package-summary.html#StreamOps">terminal operation</a>.</p></div>
            <div data-type="tag">an  {@code OptionalLong} containing the maximum element of this stream, or an empty  {@code OptionalLong} if the stream is empty</div>
          </div>
          <div data-type="method" data-name="count()">
            <div data-type="text">Returns the count of elements in this stream.  This is a special case of a <a href="package-summary.html#Reduction">reduction</a> and is equivalent to: <pre> {@code
    return map(e -&gt; 1L).sum();
}</pre> <p>This is a <a href="package-summary.html#StreamOps">terminal operation</a>.</p></div>
            <div data-type="tag">the count of elements in this stream</div>
          </div>
          <div data-type="method" data-name="average()">
            <div data-type="text">Returns an  {@code OptionalDouble} describing the arithmetic mean of elements of this stream, or an empty optional if this stream is empty.  This is a special case of a <a href="package-summary.html#Reduction">reduction</a>. <p>This is a <a href="package-summary.html#StreamOps">terminal operation</a>.</p></div>
            <div data-type="tag">an  {@code OptionalDouble} containing the average element of this stream, or an empty optional if the stream is empty</div>
          </div>
          <div data-type="method" data-name="summaryStatistics()">
            <div data-type="text">Returns a  {@code LongSummaryStatistics} describing various summary data about the elements of this stream.  This is a special case of a <a href="package-summary.html#Reduction">reduction</a>. <p>This is a <a href="package-summary.html#StreamOps">terminal operation</a>.</p></div>
            <div data-type="tag">a  {@code LongSummaryStatistics} describing various summary data about the elements of this stream</div>
          </div>
          <div data-type="method" data-name="anyMatch(java.util.function.LongPredicate)">
            <div data-type="text">Returns whether any elements of this stream match the provided predicate.  May not evaluate the predicate on all elements if not necessary for determining the result.  If the stream is empty then {@code false} is returned and the predicate is not evaluated. <p>This is a <a href="package-summary.html#StreamOps">short-circuiting terminal operation</a>.</p></div>
            <div data-type="tag">This method evaluates the <em>existential quantification</em> of the predicate over the elements of the stream (for some x P(x)).</div>
            <div data-type="tag" data-parameter-name="predicate">a <a href="package-summary.html#NonInterference">non-interfering</a>, <a href="package-summary.html#Statelessness">stateless</a> predicate to apply to elements of this stream</div>
            <div data-type="tag"> {@code true} if any elements of the stream match the provided predicate, otherwise  {@code false}</div>
          </div>
          <div data-type="method" data-name="allMatch(java.util.function.LongPredicate)">
            <div data-type="text">Returns whether all elements of this stream match the provided predicate. May not evaluate the predicate on all elements if not necessary for determining the result.  If the stream is empty then  {@code true} is returned and the predicate is not evaluated. <p>This is a <a href="package-summary.html#StreamOps">short-circuiting terminal operation</a>.</p></div>
            <div data-type="tag">This method evaluates the <em>universal quantification</em> of the predicate over the elements of the stream (for all x P(x)).  If the stream is empty, the quantification is said to be <em>vacuously satisfied</em> and is always  {@code true} (regardless of P(x)).</div>
            <div data-type="tag" data-parameter-name="predicate">a <a href="package-summary.html#NonInterference">non-interfering</a>, <a href="package-summary.html#Statelessness">stateless</a> predicate to apply to elements of this stream</div>
            <div data-type="tag"> {@code true} if either all elements of the stream match the provided predicate or the stream is empty, otherwise  {@code false}</div>
          </div>
          <div data-type="method" data-name="noneMatch(java.util.function.LongPredicate)">
            <div data-type="text">Returns whether no elements of this stream match the provided predicate. May not evaluate the predicate on all elements if not necessary for determining the result.  If the stream is empty then  {@code true} is returned and the predicate is not evaluated. <p>This is a <a href="package-summary.html#StreamOps">short-circuiting terminal operation</a>.</p></div>
            <div data-type="tag">This method evaluates the <em>universal quantification</em> of the negated predicate over the elements of the stream (for all x ~P(x)).  If the stream is empty, the quantification is said to be vacuously satisfied and is always  {@code true}, regardless of P(x).</div>
            <div data-type="tag" data-parameter-name="predicate">a <a href="package-summary.html#NonInterference">non-interfering</a>, <a href="package-summary.html#Statelessness">stateless</a> predicate to apply to elements of this stream</div>
            <div data-type="tag"> {@code true} if either no elements of the stream match the provided predicate or the stream is empty, otherwise  {@code false}</div>
          </div>
          <div data-type="method" data-name="findFirst()">
            <div data-type="text">Returns an  {@link OptionalLong} describing the first element of this stream, or an empty  {@code OptionalLong} if the stream is empty.  If the stream has no encounter order, then any element may be returned. <p>This is a <a href="package-summary.html#StreamOps">short-circuiting terminal operation</a>.</p></div>
            <div data-type="tag">an  {@code OptionalLong} describing the first element of this stream, or an empty  {@code OptionalLong} if the stream is empty</div>
          </div>
          <div data-type="method" data-name="findAny()">
            <div data-type="text">Returns an  {@link OptionalLong} describing some element of the stream, or an empty  {@code OptionalLong} if the stream is empty. <p>This is a <a href="package-summary.html#StreamOps">short-circuiting terminal operation</a>. </p><p>The behavior of this operation is explicitly nondeterministic; it is free to select any element in the stream.  This is to allow for maximal performance in parallel operations; the cost is that multiple invocations on the same source may not return the same result.  (If a stable result is desired, use  {@link #findFirst()} instead.)</p></div>
            <div data-type="tag">an  {@code OptionalLong} describing some element of this stream, or an empty  {@code OptionalLong} if the stream is empty</div>
            <div data-type="tag">#findFirst()</div>
          </div>
          <div data-type="method" data-name="asDoubleStream()">
            <div data-type="text">Returns a  {@code DoubleStream} consisting of the elements of this stream, converted to  {@code double}. <p>This is an <a href="package-summary.html#StreamOps">intermediate operation</a>.</p></div>
            <div data-type="tag">a  {@code DoubleStream} consisting of the elements of this stream, converted to  {@code double}</div>
          </div>
          <div data-type="method" data-name="boxed()">
            <div data-type="text">Returns a  {@code Stream} consisting of the elements of this stream, each boxed to a  {@code Long}. <p>This is an <a href="package-summary.html#StreamOps">intermediate operation</a>.</p></div>
            <div data-type="tag">a  {@code Stream} consistent of the elements of this stream, each boxed to  {@code Long}</div>
          </div>
          <div data-type="method" data-name="builder()">
            <div data-type="text">Returns a builder for a  {@code LongStream}.</div>
            <div data-type="tag">a stream builder</div>
          </div>
          <div data-type="method" data-name="empty()">
            <div data-type="text">Returns an empty sequential  {@code LongStream}.</div>
            <div data-type="tag">an empty sequential stream</div>
          </div>
          <div data-type="method" data-name="of(long)">
            <div data-type="text">Returns a sequential  {@code LongStream} containing a single element.</div>
            <div data-type="tag" data-parameter-name="t">the single element</div>
            <div data-type="tag">a singleton sequential stream</div>
          </div>
          <div data-type="method" data-name="of(long...)">
            <div data-type="text">Returns a sequential ordered stream whose elements are the specified values.</div>
            <div data-type="tag" data-parameter-name="values">the elements of the new stream</div>
            <div data-type="tag">the new stream</div>
          </div>
          <div data-type="method" data-name="iterate(long, java.util.function.LongUnaryOperator)">
            <div data-type="text">Returns an infinite sequential ordered  {@code LongStream} produced by iterative application of a function  {@code f} to an initial element  {@code seed}, producing a  {@code Stream} consisting of  {@code seed},  {@code f(seed)}, {@code f(f(seed))}, etc. <p>The first element (position  {@code 0}) in the  {@code LongStream} will be the provided  {@code seed}.  For  {@code n &gt; 0}, the element at position {@code n}, will be the result of applying the function  {@code f} to the element at position  {@code n - 1}.</p></div>
            <div data-type="tag" data-parameter-name="seed">the initial element</div>
            <div data-type="tag" data-parameter-name="f">a function to be applied to to the previous element to produce a new element</div>
            <div data-type="tag">a new sequential  {@code LongStream}</div>
          </div>
          <div data-type="method" data-name="generate(java.util.function.LongSupplier)">
            <div data-type="text">Returns an infinite sequential unordered stream where each element is generated by the provided  {@code LongSupplier}.  This is suitable for generating constant streams, streams of random elements, etc.</div>
            <div data-type="tag" data-parameter-name="s">the  {@code LongSupplier} for generated elements</div>
            <div data-type="tag">a new infinite sequential unordered  {@code LongStream}</div>
          </div>
          <div data-type="method" data-name="range(long, long)">
            <div data-type="text">Returns a sequential ordered  {@code LongStream} from  {@code startInclusive} (inclusive) to  {@code endExclusive} (exclusive) by an incremental step of {@code 1}.</div>
            <div data-type="tag">
              <p>An equivalent sequence of increasing values can be produced sequentially using a  {@code for} loop as follows: </p>
              <pre> {@code
    for (long i = startInclusive; i &lt; endExclusive ; i++) { ... }
}</pre>
            </div>
            <div data-type="tag" data-parameter-name="startInclusive">the (inclusive) initial value</div>
            <div data-type="tag" data-parameter-name="endExclusive">the exclusive upper bound</div>
            <div data-type="tag">a sequential  {@code LongStream} for the range of  {@code long} elements</div>
          </div>
          <div data-type="method" data-name="rangeClosed(long, long)">
            <div data-type="text">Returns a sequential ordered  {@code LongStream} from  {@code startInclusive} (inclusive) to  {@code endInclusive} (inclusive) by an incremental step of {@code 1}.</div>
            <div data-type="tag">
              <p>An equivalent sequence of increasing values can be produced sequentially using a  {@code for} loop as follows: </p>
              <pre> {@code
    for (long i = startInclusive; i &lt;= endInclusive ; i++) { ... }
}</pre>
            </div>
            <div data-type="tag" data-parameter-name="startInclusive">the (inclusive) initial value</div>
            <div data-type="tag" data-parameter-name="endInclusive">the inclusive upper bound</div>
            <div data-type="tag">a sequential  {@code LongStream} for the range of  {@code long} elements</div>
          </div>
          <div data-type="method" data-name="concat(java.util.stream.LongStream, java.util.stream.LongStream)">
            <div data-type="text">Creates a lazily concatenated stream whose elements are all the elements of the first stream followed by all the elements of the second stream.  The resulting stream is ordered if both of the input streams are ordered, and parallel if either of the input streams is parallel.  When the resulting stream is closed, the close handlers for both input streams are invoked.</div>
            <div data-type="tag">Use caution when constructing streams from repeated concatenation. Accessing an element of a deeply concatenated stream can result in deep call chains, or even  {@code StackOverflowException}.</div>
            <div data-type="tag" data-parameter-name="a">the first stream</div>
            <div data-type="tag" data-parameter-name="b">the second stream</div>
            <div data-type="tag">the concatenation of the two input streams</div>
          </div>
        </div>
        <div data-type="class" data-name="java.util.stream.LongStream.Builder">
          <div data-type="text">A mutable builder for a  {@code LongStream}. <p>A stream builder has a lifecycle, which starts in a building phase, during which elements can be added, and then transitions to a built phase, after which elements may not be added.  The built phase begins begins when the  {@link #build()} method is called, which creates an ordered stream whose elements are the elements that were added to the stream builder, in the order they were added.</p></div>
          <div data-type="tag">LongStream#builder()</div>
          <div data-type="tag">1.8</div>
          <div data-type="method" data-name="accept(long)">
            <div data-type="text">Adds an element to the stream being built.</div>
            <div data-type="tag" data-exception-name="IllegalStateException">if the builder has already transitioned to the built state</div>
          </div>
          <div data-type="method" data-name="add(long)">
            <div data-type="text">Adds an element to the stream being built.</div>
            <div data-type="tag">The default implementation behaves as if: <pre> {@code
    accept(t)
    return this;
}</pre></div>
            <div data-type="tag" data-parameter-name="t">the element to add</div>
            <div data-type="tag"> {@code this} builder</div>
            <div data-type="tag" data-exception-name="IllegalStateException">if the builder has already transitioned to the built state</div>
          </div>
          <div data-type="method" data-name="build()">
            <div data-type="text">Builds the stream, transitioning this builder to the built state. An  {@code IllegalStateException} is thrown if there are further attempts to operate on the builder after it has entered the built state.</div>
            <div data-type="tag">the built stream</div>
            <div data-type="tag" data-exception-name="IllegalStateException">if the builder has already transitioned to the built state</div>
          </div>
        </div>
        <div data-type="class" data-name="java.util.stream.IntStream">
          <div data-type="text">A sequence of primitive int-valued elements supporting sequential and parallel aggregate operations.  This is the  {@code int} primitive specialization of {@link Stream}. <p>The following example illustrates an aggregate operation using {@link Stream} and  {@link IntStream}, computing the sum of the weights of the red widgets: </p><pre> {@code
    int sum = widgets.stream()
                     .filter(w -&gt; w.getColor() == RED)
                     .mapToInt(w -&gt; w.getWeight())
                     .sum();
}</pre> See the class documentation for  {@link Stream} and the package documentation for <a href="package-summary.html">java.util.stream</a> for additional specification of streams, stream operations, stream pipelines, and parallelism.</div>
          <div data-type="tag">1.8</div>
          <div data-type="tag">Stream</div>
          <div data-type="tag">
            <a href="package-summary.html">java.util.stream</a>
          </div>
          <div data-type="method" data-name="filter(java.util.function.IntPredicate)">
            <div data-type="text">Returns a stream consisting of the elements of this stream that match the given predicate. <p>This is an <a href="package-summary.html#StreamOps">intermediate operation</a>.</p></div>
            <div data-type="tag" data-parameter-name="predicate">a <a href="package-summary.html#NonInterference">non-interfering</a>, <a href="package-summary.html#Statelessness">stateless</a> predicate to apply to each element to determine if it should be included</div>
            <div data-type="tag">the new stream</div>
          </div>
          <div data-type="method" data-name="map(java.util.function.IntUnaryOperator)">
            <div data-type="text">Returns a stream consisting of the results of applying the given function to the elements of this stream. <p>This is an <a href="package-summary.html#StreamOps">intermediate operation</a>.</p></div>
            <div data-type="tag" data-parameter-name="mapper">a <a href="package-summary.html#NonInterference">non-interfering</a>, <a href="package-summary.html#Statelessness">stateless</a> function to apply to each element</div>
            <div data-type="tag">the new stream</div>
          </div>
          <div data-type="method" data-name="mapToObj(java.util.function.IntFunction&lt;? extends U&gt;)">
            <div data-type="text">Returns an object-valued  {@code Stream} consisting of the results of applying the given function to the elements of this stream. <p>This is an <a href="package-summary.html#StreamOps"> intermediate operation</a>.</p></div>
            <div data-type="tag" data-parameter-name="U" data-is-type-parameter="data-is-type-parameter">the element type of the new stream</div>
            <div data-type="tag" data-parameter-name="mapper">a <a href="package-summary.html#NonInterference">non-interfering</a>, <a href="package-summary.html#Statelessness">stateless</a> function to apply to each element</div>
            <div data-type="tag">the new stream</div>
          </div>
          <div data-type="method" data-name="mapToLong(java.util.function.IntToLongFunction)">
            <div data-type="text">Returns a  {@code LongStream} consisting of the results of applying the given function to the elements of this stream. <p>This is an <a href="package-summary.html#StreamOps">intermediate operation</a>.</p></div>
            <div data-type="tag" data-parameter-name="mapper">a <a href="package-summary.html#NonInterference">non-interfering</a>, <a href="package-summary.html#Statelessness">stateless</a> function to apply to each element</div>
            <div data-type="tag">the new stream</div>
          </div>
          <div data-type="method" data-name="mapToDouble(java.util.function.IntToDoubleFunction)">
            <div data-type="text">Returns a  {@code DoubleStream} consisting of the results of applying the given function to the elements of this stream. <p>This is an <a href="package-summary.html#StreamOps">intermediate operation</a>.</p></div>
            <div data-type="tag" data-parameter-name="mapper">a <a href="package-summary.html#NonInterference">non-interfering</a>, <a href="package-summary.html#Statelessness">stateless</a> function to apply to each element</div>
            <div data-type="tag">the new stream</div>
          </div>
          <div data-type="method" data-name="flatMap(java.util.function.IntFunction&lt;? extends java.util.stream.IntStream&gt;)">
            <div data-type="text">Returns a stream consisting of the results of replacing each element of this stream with the contents of a mapped stream produced by applying the provided mapping function to each element.  Each mapped stream is {@link java.util.stream.BaseStream#close() closed} after its contents have been placed into this stream.  (If a mapped stream is  {@code null} an empty stream is used, instead.) <p>This is an <a href="package-summary.html#StreamOps">intermediate operation</a>.</p></div>
            <div data-type="tag" data-parameter-name="mapper">a <a href="package-summary.html#NonInterference">non-interfering</a>, <a href="package-summary.html#Statelessness">stateless</a> function to apply to each element which produces an {@code IntStream} of new values</div>
            <div data-type="tag">the new stream</div>
            <div data-type="tag">Stream#flatMap(Function)</div>
          </div>
          <div data-type="method" data-name="distinct()">
            <div data-type="text">Returns a stream consisting of the distinct elements of this stream. <p>This is a <a href="package-summary.html#StreamOps">stateful intermediate operation</a>.</p></div>
            <div data-type="tag">the new stream</div>
          </div>
          <div data-type="method" data-name="sorted()">
            <div data-type="text">Returns a stream consisting of the elements of this stream in sorted order. <p>This is a <a href="package-summary.html#StreamOps">stateful intermediate operation</a>.</p></div>
            <div data-type="tag">the new stream</div>
          </div>
          <div data-type="method" data-name="peek(java.util.function.IntConsumer)">
            <div data-type="text">Returns a stream consisting of the elements of this stream, additionally performing the provided action on each element as elements are consumed from the resulting stream. <p>This is an <a href="package-summary.html#StreamOps">intermediate operation</a>. </p><p>For parallel stream pipelines, the action may be called at whatever time and in whatever thread the element is made available by the upstream operation.  If the action modifies shared state, it is responsible for providing the required synchronization.</p></div>
            <div data-type="tag">This method exists mainly to support debugging, where you want to see the elements as they flow past a certain point in a pipeline: <pre> {@code
    IntStream.of(1, 2, 3, 4)
        .filter(e -&gt; e &gt; 2)
        .peek(e -&gt; System.out.println("Filtered value: " + e))
        .map(e -&gt; e * e)
        .peek(e -&gt; System.out.println("Mapped value: " + e))
        .sum();
}</pre></div>
            <div data-type="tag" data-parameter-name="action">a <a href="package-summary.html#NonInterference"> non-interfering</a> action to perform on the elements as they are consumed from the stream</div>
            <div data-type="tag">the new stream</div>
          </div>
          <div data-type="method" data-name="limit(long)">
            <div data-type="text">Returns a stream consisting of the elements of this stream, truncated to be no longer than  {@code maxSize} in length. <p>This is a <a href="package-summary.html#StreamOps">short-circuiting stateful intermediate operation</a>.</p></div>
            <div data-type="tag">While  {@code limit()} is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of  {@code maxSize}, since  {@code limit(n)} is constrained to return not just any <em>n</em> elements, but the <em>first n</em> elements in the encounter order.  Using an unordered stream source (such as  {@link #generate(IntSupplier)}) or removing the ordering constraint with  {@link #unordered()} may result in significant speedups of  {@code limit()} in parallel pipelines, if the semantics of your situation permit.  If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with {@code limit()} in parallel pipelines, switching to sequential execution with  {@link #sequential()} may improve performance.</div>
            <div data-type="tag" data-parameter-name="maxSize">the number of elements the stream should be limited to</div>
            <div data-type="tag">the new stream</div>
            <div data-type="tag" data-exception-name="IllegalArgumentException">if  {@code maxSize} is negative</div>
          </div>
          <div data-type="method" data-name="skip(long)">
            <div data-type="text">Returns a stream consisting of the remaining elements of this stream after discarding the first  {@code n} elements of the stream. If this stream contains fewer than  {@code n} elements then an empty stream will be returned. <p>This is a <a href="package-summary.html#StreamOps">stateful intermediate operation</a>.</p></div>
            <div data-type="tag">While  {@code skip()} is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of  {@code n}, since  {@code skip(n)} is constrained to skip not just any <em>n</em> elements, but the <em>first n</em> elements in the encounter order.  Using an unordered stream source (such as  {@link #generate(IntSupplier)}) or removing the ordering constraint with  {@link #unordered()} may result in significant speedups of  {@code skip()} in parallel pipelines, if the semantics of your situation permit.  If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with {@code skip()} in parallel pipelines, switching to sequential execution with  {@link #sequential()} may improve performance.</div>
            <div data-type="tag" data-parameter-name="n">the number of leading elements to skip</div>
            <div data-type="tag">the new stream</div>
            <div data-type="tag" data-exception-name="IllegalArgumentException">if  {@code n} is negative</div>
          </div>
          <div data-type="method" data-name="forEach(java.util.function.IntConsumer)">
            <div data-type="text">Performs an action for each element of this stream. <p>This is a <a href="package-summary.html#StreamOps">terminal operation</a>. </p><p>For parallel stream pipelines, this operation does <em>not</em> guarantee to respect the encounter order of the stream, as doing so would sacrifice the benefit of parallelism.  For any given element, the action may be performed at whatever time and in whatever thread the library chooses.  If the action accesses shared state, it is responsible for providing the required synchronization.</p></div>
            <div data-type="tag" data-parameter-name="action">a <a href="package-summary.html#NonInterference"> non-interfering</a> action to perform on the elements</div>
          </div>
          <div data-type="method" data-name="forEachOrdered(java.util.function.IntConsumer)">
            <div data-type="text">Performs an action for each element of this stream, guaranteeing that each element is processed in encounter order for streams that have a defined encounter order. <p>This is a <a href="package-summary.html#StreamOps">terminal operation</a>.</p></div>
            <div data-type="tag" data-parameter-name="action">a <a href="package-summary.html#NonInterference"> non-interfering</a> action to perform on the elements</div>
            <div data-type="tag">#forEach(IntConsumer)</div>
          </div>
          <div data-type="method" data-name="toArray()">
            <div data-type="text">Returns an array containing the elements of this stream. <p>This is a <a href="package-summary.html#StreamOps">terminal operation</a>.</p></div>
            <div data-type="tag">an array containing the elements of this stream</div>
          </div>
          <div data-type="method" data-name="reduce(int, java.util.function.IntBinaryOperator)">
            <div data-type="text">Performs a <a href="package-summary.html#Reduction">reduction</a> on the elements of this stream, using the provided identity value and an <a href="package-summary.html#Associativity">associative</a> accumulation function, and returns the reduced value.  This is equivalent to: <pre> {@code
    int result = identity;
    for (int element : this stream)
        result = accumulator.applyAsInt(result, element)
    return result;
}</pre> but is not constrained to execute sequentially. <p>The  {@code identity} value must be an identity for the accumulator function. This means that for all  {@code x}, {@code accumulator.apply(identity, x)} is equal to  {@code x}. The  {@code accumulator} function must be an <a href="package-summary.html#Associativity">associative</a> function. </p><p>This is a <a href="package-summary.html#StreamOps">terminal operation</a>.</p></div>
            <div data-type="tag">Sum, min, max, and average are all special cases of reduction. Summing a stream of numbers can be expressed as: <pre> {@code
    int sum = integers.reduce(0, (a, b) -&gt; a+b);
}</pre> or more compactly: <pre> {@code
    int sum = integers.reduce(0, Integer::sum);
}</pre> <p>While this may seem a more roundabout way to perform an aggregation compared to simply mutating a running total in a loop, reduction operations parallelize more gracefully, without needing additional synchronization and with greatly reduced risk of data races.</p></div>
            <div data-type="tag" data-parameter-name="identity">the identity value for the accumulating function</div>
            <div data-type="tag" data-parameter-name="op">an <a href="package-summary.html#Associativity">associative</a>, <a href="package-summary.html#NonInterference">non-interfering</a>, <a href="package-summary.html#Statelessness">stateless</a> function for combining two values</div>
            <div data-type="tag">the result of the reduction</div>
            <div data-type="tag">#sum()</div>
            <div data-type="tag">#min()</div>
            <div data-type="tag">#max()</div>
            <div data-type="tag">#average()</div>
          </div>
          <div data-type="method" data-name="reduce(java.util.function.IntBinaryOperator)">
            <div data-type="text">Performs a <a href="package-summary.html#Reduction">reduction</a> on the elements of this stream, using an <a href="package-summary.html#Associativity">associative</a> accumulation function, and returns an  {@code OptionalInt} describing the reduced value, if any. This is equivalent to: <pre> {@code
    boolean foundAny = false;
    int result = null;
    for (int element : this stream) {
        if (!foundAny) {
            foundAny = true;
            result = element;
        }
        else
            result = accumulator.applyAsInt(result, element);
    }
    return foundAny ? OptionalInt.of(result) : OptionalInt.empty();
}</pre> but is not constrained to execute sequentially. <p>The  {@code accumulator} function must be an <a href="package-summary.html#Associativity">associative</a> function. </p><p>This is a <a href="package-summary.html#StreamOps">terminal operation</a>.</p></div>
            <div data-type="tag" data-parameter-name="op">an <a href="package-summary.html#Associativity">associative</a>, <a href="package-summary.html#NonInterference">non-interfering</a>, <a href="package-summary.html#Statelessness">stateless</a> function for combining two values</div>
            <div data-type="tag">the result of the reduction</div>
            <div data-type="tag">#reduce(int, IntBinaryOperator)</div>
          </div>
          <div data-type="method" data-name="collect(java.util.function.Supplier&lt;R&gt;, java.util.function.ObjIntConsumer&lt;R&gt;, java.util.function.BiConsumer&lt;R, R&gt;)">
            <div data-type="text">Performs a <a href="package-summary.html#MutableReduction">mutable reduction</a> operation on the elements of this stream.  A mutable reduction is one in which the reduced value is a mutable result container, such as an  {@code ArrayList}, and elements are incorporated by updating the state of the result rather than by replacing the result.  This produces a result equivalent to: <pre> {@code
    R result = supplier.get();
    for (int element : this stream)
        accumulator.accept(result, element);
    return result;
}</pre> <p>Like  {@link #reduce(int, IntBinaryOperator)},  {@code collect} operations can be parallelized without requiring additional synchronization. </p><p>This is a <a href="package-summary.html#StreamOps">terminal operation</a>.</p></div>
            <div data-type="tag" data-parameter-name="R" data-is-type-parameter="data-is-type-parameter">type of the result</div>
            <div data-type="tag" data-parameter-name="supplier">a function that creates a new result container. For a parallel execution, this function may be called multiple times and must return a fresh value each time.</div>
            <div data-type="tag" data-parameter-name="accumulator">an <a href="package-summary.html#Associativity">associative</a>, <a href="package-summary.html#NonInterference">non-interfering</a>, <a href="package-summary.html#Statelessness">stateless</a> function for incorporating an additional element into a result</div>
            <div data-type="tag" data-parameter-name="combiner">an <a href="package-summary.html#Associativity">associative</a>, <a href="package-summary.html#NonInterference">non-interfering</a>, <a href="package-summary.html#Statelessness">stateless</a> function for combining two values, which must be compatible with the accumulator function</div>
            <div data-type="tag">the result of the reduction</div>
            <div data-type="tag">Stream#collect(Supplier, BiConsumer, BiConsumer)</div>
          </div>
          <div data-type="method" data-name="sum()">
            <div data-type="text">Returns the sum of elements in this stream.  This is a special case of a <a href="package-summary.html#Reduction">reduction</a> and is equivalent to: <pre> {@code
    return reduce(0, Integer::sum);
}</pre> <p>This is a <a href="package-summary.html#StreamOps">terminal operation</a>.</p></div>
            <div data-type="tag">the sum of elements in this stream</div>
          </div>
          <div data-type="method" data-name="min()">
            <div data-type="text">Returns an  {@code OptionalInt} describing the minimum element of this stream, or an empty optional if this stream is empty.  This is a special case of a <a href="package-summary.html#Reduction">reduction</a> and is equivalent to: <pre> {@code
    return reduce(Integer::min);
}</pre> <p>This is a <a href="package-summary.html#StreamOps">terminal operation</a>.</p></div>
            <div data-type="tag">an  {@code OptionalInt} containing the minimum element of this stream, or an empty  {@code OptionalInt} if the stream is empty</div>
          </div>
          <div data-type="method" data-name="max()">
            <div data-type="text">Returns an  {@code OptionalInt} describing the maximum element of this stream, or an empty optional if this stream is empty.  This is a special case of a <a href="package-summary.html#Reduction">reduction</a> and is equivalent to: <pre> {@code
    return reduce(Integer::max);
}</pre> <p>This is a <a href="package-summary.html#StreamOps">terminal operation</a>.</p></div>
            <div data-type="tag">an  {@code OptionalInt} containing the maximum element of this stream, or an empty  {@code OptionalInt} if the stream is empty</div>
          </div>
          <div data-type="method" data-name="count()">
            <div data-type="text">Returns the count of elements in this stream.  This is a special case of a <a href="package-summary.html#Reduction">reduction</a> and is equivalent to: <pre> {@code
    return mapToLong(e -&gt; 1L).sum();
}</pre> <p>This is a <a href="package-summary.html#StreamOps">terminal operation</a>.</p></div>
            <div data-type="tag">the count of elements in this stream</div>
          </div>
          <div data-type="method" data-name="average()">
            <div data-type="text">Returns an  {@code OptionalDouble} describing the arithmetic mean of elements of this stream, or an empty optional if this stream is empty.  This is a special case of a <a href="package-summary.html#Reduction">reduction</a>. <p>This is a <a href="package-summary.html#StreamOps">terminal operation</a>.</p></div>
            <div data-type="tag">an  {@code OptionalDouble} containing the average element of this stream, or an empty optional if the stream is empty</div>
          </div>
          <div data-type="method" data-name="summaryStatistics()">
            <div data-type="text">Returns an  {@code IntSummaryStatistics} describing various summary data about the elements of this stream.  This is a special case of a <a href="package-summary.html#Reduction">reduction</a>. <p>This is a <a href="package-summary.html#StreamOps">terminal operation</a>.</p></div>
            <div data-type="tag">an  {@code IntSummaryStatistics} describing various summary data about the elements of this stream</div>
          </div>
          <div data-type="method" data-name="anyMatch(java.util.function.IntPredicate)">
            <div data-type="text">Returns whether any elements of this stream match the provided predicate.  May not evaluate the predicate on all elements if not necessary for determining the result.  If the stream is empty then {@code false} is returned and the predicate is not evaluated. <p>This is a <a href="package-summary.html#StreamOps">short-circuiting terminal operation</a>.</p></div>
            <div data-type="tag">This method evaluates the <em>existential quantification</em> of the predicate over the elements of the stream (for some x P(x)).</div>
            <div data-type="tag" data-parameter-name="predicate">a <a href="package-summary.html#NonInterference">non-interfering</a>, <a href="package-summary.html#Statelessness">stateless</a> predicate to apply to elements of this stream</div>
            <div data-type="tag"> {@code true} if any elements of the stream match the provided predicate, otherwise  {@code false}</div>
          </div>
          <div data-type="method" data-name="allMatch(java.util.function.IntPredicate)">
            <div data-type="text">Returns whether all elements of this stream match the provided predicate. May not evaluate the predicate on all elements if not necessary for determining the result.  If the stream is empty then  {@code true} is returned and the predicate is not evaluated. <p>This is a <a href="package-summary.html#StreamOps">short-circuiting terminal operation</a>.</p></div>
            <div data-type="tag">This method evaluates the <em>universal quantification</em> of the predicate over the elements of the stream (for all x P(x)).  If the stream is empty, the quantification is said to be <em>vacuously satisfied</em> and is always  {@code true} (regardless of P(x)).</div>
            <div data-type="tag" data-parameter-name="predicate">a <a href="package-summary.html#NonInterference">non-interfering</a>, <a href="package-summary.html#Statelessness">stateless</a> predicate to apply to elements of this stream</div>
            <div data-type="tag"> {@code true} if either all elements of the stream match the provided predicate or the stream is empty, otherwise  {@code false}</div>
          </div>
          <div data-type="method" data-name="noneMatch(java.util.function.IntPredicate)">
            <div data-type="text">Returns whether no elements of this stream match the provided predicate. May not evaluate the predicate on all elements if not necessary for determining the result.  If the stream is empty then  {@code true} is returned and the predicate is not evaluated. <p>This is a <a href="package-summary.html#StreamOps">short-circuiting terminal operation</a>.</p></div>
            <div data-type="tag">This method evaluates the <em>universal quantification</em> of the negated predicate over the elements of the stream (for all x ~P(x)).  If the stream is empty, the quantification is said to be vacuously satisfied and is always  {@code true}, regardless of P(x).</div>
            <div data-type="tag" data-parameter-name="predicate">a <a href="package-summary.html#NonInterference">non-interfering</a>, <a href="package-summary.html#Statelessness">stateless</a> predicate to apply to elements of this stream</div>
            <div data-type="tag"> {@code true} if either no elements of the stream match the provided predicate or the stream is empty, otherwise  {@code false}</div>
          </div>
          <div data-type="method" data-name="findFirst()">
            <div data-type="text">Returns an  {@link OptionalInt} describing the first element of this stream, or an empty  {@code OptionalInt} if the stream is empty.  If the stream has no encounter order, then any element may be returned. <p>This is a <a href="package-summary.html#StreamOps">short-circuiting terminal operation</a>.</p></div>
            <div data-type="tag">an  {@code OptionalInt} describing the first element of this stream, or an empty  {@code OptionalInt} if the stream is empty</div>
          </div>
          <div data-type="method" data-name="findAny()">
            <div data-type="text">Returns an  {@link OptionalInt} describing some element of the stream, or an empty  {@code OptionalInt} if the stream is empty. <p>This is a <a href="package-summary.html#StreamOps">short-circuiting terminal operation</a>. </p><p>The behavior of this operation is explicitly nondeterministic; it is free to select any element in the stream.  This is to allow for maximal performance in parallel operations; the cost is that multiple invocations on the same source may not return the same result.  (If a stable result is desired, use  {@link #findFirst()} instead.)</p></div>
            <div data-type="tag">an  {@code OptionalInt} describing some element of this stream, or an empty  {@code OptionalInt} if the stream is empty</div>
            <div data-type="tag">#findFirst()</div>
          </div>
          <div data-type="method" data-name="asLongStream()">
            <div data-type="text">Returns a  {@code LongStream} consisting of the elements of this stream, converted to  {@code long}. <p>This is an <a href="package-summary.html#StreamOps">intermediate operation</a>.</p></div>
            <div data-type="tag">a  {@code LongStream} consisting of the elements of this stream, converted to  {@code long}</div>
          </div>
          <div data-type="method" data-name="asDoubleStream()">
            <div data-type="text">Returns a  {@code DoubleStream} consisting of the elements of this stream, converted to  {@code double}. <p>This is an <a href="package-summary.html#StreamOps">intermediate operation</a>.</p></div>
            <div data-type="tag">a  {@code DoubleStream} consisting of the elements of this stream, converted to  {@code double}</div>
          </div>
          <div data-type="method" data-name="boxed()">
            <div data-type="text">Returns a  {@code Stream} consisting of the elements of this stream, each boxed to an  {@code Integer}. <p>This is an <a href="package-summary.html#StreamOps">intermediate operation</a>.</p></div>
            <div data-type="tag">a  {@code Stream} consistent of the elements of this stream, each boxed to an  {@code Integer}</div>
          </div>
          <div data-type="method" data-name="builder()">
            <div data-type="text">Returns a builder for an  {@code IntStream}.</div>
            <div data-type="tag">a stream builder</div>
          </div>
          <div data-type="method" data-name="empty()">
            <div data-type="text">Returns an empty sequential  {@code IntStream}.</div>
            <div data-type="tag">an empty sequential stream</div>
          </div>
          <div data-type="method" data-name="of(int)">
            <div data-type="text">Returns a sequential  {@code IntStream} containing a single element.</div>
            <div data-type="tag" data-parameter-name="t">the single element</div>
            <div data-type="tag">a singleton sequential stream</div>
          </div>
          <div data-type="method" data-name="of(int...)">
            <div data-type="text">Returns a sequential ordered stream whose elements are the specified values.</div>
            <div data-type="tag" data-parameter-name="values">the elements of the new stream</div>
            <div data-type="tag">the new stream</div>
          </div>
          <div data-type="method" data-name="iterate(int, java.util.function.IntUnaryOperator)">
            <div data-type="text">Returns an infinite sequential ordered  {@code IntStream} produced by iterative application of a function  {@code f} to an initial element  {@code seed}, producing a  {@code Stream} consisting of  {@code seed},  {@code f(seed)}, {@code f(f(seed))}, etc. <p>The first element (position  {@code 0}) in the  {@code IntStream} will be the provided  {@code seed}.  For  {@code n &gt; 0}, the element at position {@code n}, will be the result of applying the function  {@code f} to the element at position  {@code n - 1}.</p></div>
            <div data-type="tag" data-parameter-name="seed">the initial element</div>
            <div data-type="tag" data-parameter-name="f">a function to be applied to to the previous element to produce a new element</div>
            <div data-type="tag">A new sequential  {@code IntStream}</div>
          </div>
          <div data-type="method" data-name="generate(java.util.function.IntSupplier)">
            <div data-type="text">Returns an infinite sequential unordered stream where each element is generated by the provided  {@code IntSupplier}.  This is suitable for generating constant streams, streams of random elements, etc.</div>
            <div data-type="tag" data-parameter-name="s">the  {@code IntSupplier} for generated elements</div>
            <div data-type="tag">a new infinite sequential unordered  {@code IntStream}</div>
          </div>
          <div data-type="method" data-name="range(int, int)">
            <div data-type="text">Returns a sequential ordered  {@code IntStream} from  {@code startInclusive} (inclusive) to  {@code endExclusive} (exclusive) by an incremental step of {@code 1}.</div>
            <div data-type="tag">
              <p>An equivalent sequence of increasing values can be produced sequentially using a  {@code for} loop as follows: </p>
              <pre> {@code
    for (int i = startInclusive; i &lt; endExclusive ; i++) { ... }
}</pre>
            </div>
            <div data-type="tag" data-parameter-name="startInclusive">the (inclusive) initial value</div>
            <div data-type="tag" data-parameter-name="endExclusive">the exclusive upper bound</div>
            <div data-type="tag">a sequential  {@code IntStream} for the range of  {@code int} elements</div>
          </div>
          <div data-type="method" data-name="rangeClosed(int, int)">
            <div data-type="text">Returns a sequential ordered  {@code IntStream} from  {@code startInclusive} (inclusive) to  {@code endInclusive} (inclusive) by an incremental step of {@code 1}.</div>
            <div data-type="tag">
              <p>An equivalent sequence of increasing values can be produced sequentially using a  {@code for} loop as follows: </p>
              <pre> {@code
    for (int i = startInclusive; i &lt;= endInclusive ; i++) { ... }
}</pre>
            </div>
            <div data-type="tag" data-parameter-name="startInclusive">the (inclusive) initial value</div>
            <div data-type="tag" data-parameter-name="endInclusive">the inclusive upper bound</div>
            <div data-type="tag">a sequential  {@code IntStream} for the range of  {@code int} elements</div>
          </div>
          <div data-type="method" data-name="concat(java.util.stream.IntStream, java.util.stream.IntStream)">
            <div data-type="text">Creates a lazily concatenated stream whose elements are all the elements of the first stream followed by all the elements of the second stream.  The resulting stream is ordered if both of the input streams are ordered, and parallel if either of the input streams is parallel.  When the resulting stream is closed, the close handlers for both input streams are invoked.</div>
            <div data-type="tag">Use caution when constructing streams from repeated concatenation. Accessing an element of a deeply concatenated stream can result in deep call chains, or even  {@code StackOverflowException}.</div>
            <div data-type="tag" data-parameter-name="a">the first stream</div>
            <div data-type="tag" data-parameter-name="b">the second stream</div>
            <div data-type="tag">the concatenation of the two input streams</div>
          </div>
        </div>
        <div data-type="class" data-name="java.util.stream.IntStream.Builder">
          <div data-type="text">A mutable builder for an  {@code IntStream}. <p>A stream builder has a lifecycle, which starts in a building phase, during which elements can be added, and then transitions to a built phase, after which elements may not be added.  The built phase begins when the  {@link #build()} method is called, which creates an ordered stream whose elements are the elements that were added to the stream builder, in the order they were added.</p></div>
          <div data-type="tag">IntStream#builder()</div>
          <div data-type="tag">1.8</div>
          <div data-type="method" data-name="accept(int)">
            <div data-type="text">Adds an element to the stream being built.</div>
            <div data-type="tag" data-exception-name="IllegalStateException">if the builder has already transitioned to the built state</div>
          </div>
          <div data-type="method" data-name="add(int)">
            <div data-type="text">Adds an element to the stream being built.</div>
            <div data-type="tag">The default implementation behaves as if: <pre> {@code
    accept(t)
    return this;
}</pre></div>
            <div data-type="tag" data-parameter-name="t">the element to add</div>
            <div data-type="tag"> {@code this} builder</div>
            <div data-type="tag" data-exception-name="IllegalStateException">if the builder has already transitioned to the built state</div>
          </div>
          <div data-type="method" data-name="build()">
            <div data-type="text">Builds the stream, transitioning this builder to the built state. An  {@code IllegalStateException} is thrown if there are further attempts to operate on the builder after it has entered the built state.</div>
            <div data-type="tag">the built stream</div>
            <div data-type="tag" data-exception-name="IllegalStateException">if the builder has already transitioned to the built state</div>
          </div>
        </div>
        <div data-type="class" data-name="java.util.stream.DoubleStream">
          <div data-type="text">A sequence of primitive double-valued elements supporting sequential and parallel aggregate operations.  This is the  {@code double} primitive specialization of {@link Stream}. <p>The following example illustrates an aggregate operation using {@link Stream} and  {@link DoubleStream}, computing the sum of the weights of the red widgets: </p><pre> {@code
    double sum = widgets.stream()
                        .filter(w -&gt; w.getColor() == RED)
                        .mapToDouble(w -&gt; w.getWeight())
                        .sum();
}</pre> See the class documentation for  {@link Stream} and the package documentation for <a href="package-summary.html">java.util.stream</a> for additional specification of streams, stream operations, stream pipelines, and parallelism.</div>
          <div data-type="tag">1.8</div>
          <div data-type="tag">Stream</div>
          <div data-type="tag">
            <a href="package-summary.html">java.util.stream</a>
          </div>
          <div data-type="method" data-name="filter(java.util.function.DoublePredicate)">
            <div data-type="text">Returns a stream consisting of the elements of this stream that match the given predicate. <p>This is an <a href="package-summary.html#StreamOps">intermediate operation</a>.</p></div>
            <div data-type="tag" data-parameter-name="predicate">a <a href="package-summary.html#NonInterference">non-interfering</a>, <a href="package-summary.html#Statelessness">stateless</a> predicate to apply to each element to determine if it should be included</div>
            <div data-type="tag">the new stream</div>
          </div>
          <div data-type="method" data-name="map(java.util.function.DoubleUnaryOperator)">
            <div data-type="text">Returns a stream consisting of the results of applying the given function to the elements of this stream. <p>This is an <a href="package-summary.html#StreamOps">intermediate operation</a>.</p></div>
            <div data-type="tag" data-parameter-name="mapper">a <a href="package-summary.html#NonInterference">non-interfering</a>, <a href="package-summary.html#Statelessness">stateless</a> function to apply to each element</div>
            <div data-type="tag">the new stream</div>
          </div>
          <div data-type="method" data-name="mapToObj(java.util.function.DoubleFunction&lt;? extends U&gt;)">
            <div data-type="text">Returns an object-valued  {@code Stream} consisting of the results of applying the given function to the elements of this stream. <p>This is an <a href="package-summary.html#StreamOps"> intermediate operation</a>.</p></div>
            <div data-type="tag" data-parameter-name="U" data-is-type-parameter="data-is-type-parameter">the element type of the new stream</div>
            <div data-type="tag" data-parameter-name="mapper">a <a href="package-summary.html#NonInterference">non-interfering</a>, <a href="package-summary.html#Statelessness">stateless</a> function to apply to each element</div>
            <div data-type="tag">the new stream</div>
          </div>
          <div data-type="method" data-name="mapToInt(java.util.function.DoubleToIntFunction)">
            <div data-type="text">Returns an  {@code IntStream} consisting of the results of applying the given function to the elements of this stream. <p>This is an <a href="package-summary.html#StreamOps">intermediate operation</a>.</p></div>
            <div data-type="tag" data-parameter-name="mapper">a <a href="package-summary.html#NonInterference">non-interfering</a>, <a href="package-summary.html#Statelessness">stateless</a> function to apply to each element</div>
            <div data-type="tag">the new stream</div>
          </div>
          <div data-type="method" data-name="mapToLong(java.util.function.DoubleToLongFunction)">
            <div data-type="text">Returns a  {@code LongStream} consisting of the results of applying the given function to the elements of this stream. <p>This is an <a href="package-summary.html#StreamOps">intermediate operation</a>.</p></div>
            <div data-type="tag" data-parameter-name="mapper">a <a href="package-summary.html#NonInterference">non-interfering</a>, <a href="package-summary.html#Statelessness">stateless</a> function to apply to each element</div>
            <div data-type="tag">the new stream</div>
          </div>
          <div data-type="method" data-name="flatMap(java.util.function.DoubleFunction&lt;? extends java.util.stream.DoubleStream&gt;)">
            <div data-type="text">Returns a stream consisting of the results of replacing each element of this stream with the contents of a mapped stream produced by applying the provided mapping function to each element.  Each mapped stream is {@link java.util.stream.BaseStream#close() closed} after its contents have been placed into this stream.  (If a mapped stream is  {@code null} an empty stream is used, instead.) <p>This is an <a href="package-summary.html#StreamOps">intermediate operation</a>.</p></div>
            <div data-type="tag" data-parameter-name="mapper">a <a href="package-summary.html#NonInterference">non-interfering</a>, <a href="package-summary.html#Statelessness">stateless</a> function to apply to each element which produces a {@code DoubleStream} of new values</div>
            <div data-type="tag">the new stream</div>
            <div data-type="tag">Stream#flatMap(Function)</div>
          </div>
          <div data-type="method" data-name="distinct()">
            <div data-type="text">Returns a stream consisting of the distinct elements of this stream. The elements are compared for equality according to {@link java.lang.Double#compare(double, double)}. <p>This is a <a href="package-summary.html#StreamOps">stateful intermediate operation</a>.</p></div>
            <div data-type="tag">the result stream</div>
          </div>
          <div data-type="method" data-name="sorted()">
            <div data-type="text">Returns a stream consisting of the elements of this stream in sorted order. The elements are compared for equality according to {@link java.lang.Double#compare(double, double)}. <p>This is a <a href="package-summary.html#StreamOps">stateful intermediate operation</a>.</p></div>
            <div data-type="tag">the result stream</div>
          </div>
          <div data-type="method" data-name="peek(java.util.function.DoubleConsumer)">
            <div data-type="text">Returns a stream consisting of the elements of this stream, additionally performing the provided action on each element as elements are consumed from the resulting stream. <p>This is an <a href="package-summary.html#StreamOps">intermediate operation</a>. </p><p>For parallel stream pipelines, the action may be called at whatever time and in whatever thread the element is made available by the upstream operation.  If the action modifies shared state, it is responsible for providing the required synchronization.</p></div>
            <div data-type="tag">This method exists mainly to support debugging, where you want to see the elements as they flow past a certain point in a pipeline: <pre> {@code
    DoubleStream.of(1, 2, 3, 4)
        .filter(e -&gt; e &gt; 2)
        .peek(e -&gt; System.out.println("Filtered value: " + e))
        .map(e -&gt; e * e)
        .peek(e -&gt; System.out.println("Mapped value: " + e))
        .sum();
}</pre></div>
            <div data-type="tag" data-parameter-name="action">a <a href="package-summary.html#NonInterference"> non-interfering</a> action to perform on the elements as they are consumed from the stream</div>
            <div data-type="tag">the new stream</div>
          </div>
          <div data-type="method" data-name="limit(long)">
            <div data-type="text">Returns a stream consisting of the elements of this stream, truncated to be no longer than  {@code maxSize} in length. <p>This is a <a href="package-summary.html#StreamOps">short-circuiting stateful intermediate operation</a>.</p></div>
            <div data-type="tag">While  {@code limit()} is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of  {@code maxSize}, since  {@code limit(n)} is constrained to return not just any <em>n</em> elements, but the <em>first n</em> elements in the encounter order.  Using an unordered stream source (such as  {@link #generate(DoubleSupplier)}) or removing the ordering constraint with  {@link #unordered()} may result in significant speedups of  {@code limit()} in parallel pipelines, if the semantics of your situation permit.  If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with {@code limit()} in parallel pipelines, switching to sequential execution with  {@link #sequential()} may improve performance.</div>
            <div data-type="tag" data-parameter-name="maxSize">the number of elements the stream should be limited to</div>
            <div data-type="tag">the new stream</div>
            <div data-type="tag" data-exception-name="IllegalArgumentException">if  {@code maxSize} is negative</div>
          </div>
          <div data-type="method" data-name="skip(long)">
            <div data-type="text">Returns a stream consisting of the remaining elements of this stream after discarding the first  {@code n} elements of the stream. If this stream contains fewer than  {@code n} elements then an empty stream will be returned. <p>This is a <a href="package-summary.html#StreamOps">stateful intermediate operation</a>.</p></div>
            <div data-type="tag">While  {@code skip()} is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of  {@code n}, since  {@code skip(n)} is constrained to skip not just any <em>n</em> elements, but the <em>first n</em> elements in the encounter order.  Using an unordered stream source (such as  {@link #generate(DoubleSupplier)}) or removing the ordering constraint with  {@link #unordered()} may result in significant speedups of  {@code skip()} in parallel pipelines, if the semantics of your situation permit.  If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with {@code skip()} in parallel pipelines, switching to sequential execution with  {@link #sequential()} may improve performance.</div>
            <div data-type="tag" data-parameter-name="n">the number of leading elements to skip</div>
            <div data-type="tag">the new stream</div>
            <div data-type="tag" data-exception-name="IllegalArgumentException">if  {@code n} is negative</div>
          </div>
          <div data-type="method" data-name="forEach(java.util.function.DoubleConsumer)">
            <div data-type="text">Performs an action for each element of this stream. <p>This is a <a href="package-summary.html#StreamOps">terminal operation</a>. </p><p>For parallel stream pipelines, this operation does <em>not</em> guarantee to respect the encounter order of the stream, as doing so would sacrifice the benefit of parallelism.  For any given element, the action may be performed at whatever time and in whatever thread the library chooses.  If the action accesses shared state, it is responsible for providing the required synchronization.</p></div>
            <div data-type="tag" data-parameter-name="action">a <a href="package-summary.html#NonInterference"> non-interfering</a> action to perform on the elements</div>
          </div>
          <div data-type="method" data-name="forEachOrdered(java.util.function.DoubleConsumer)">
            <div data-type="text">Performs an action for each element of this stream, guaranteeing that each element is processed in encounter order for streams that have a defined encounter order. <p>This is a <a href="package-summary.html#StreamOps">terminal operation</a>.</p></div>
            <div data-type="tag" data-parameter-name="action">a <a href="package-summary.html#NonInterference"> non-interfering</a> action to perform on the elements</div>
            <div data-type="tag">#forEach(DoubleConsumer)</div>
          </div>
          <div data-type="method" data-name="toArray()">
            <div data-type="text">Returns an array containing the elements of this stream. <p>This is a <a href="package-summary.html#StreamOps">terminal operation</a>.</p></div>
            <div data-type="tag">an array containing the elements of this stream</div>
          </div>
          <div data-type="method" data-name="reduce(double, java.util.function.DoubleBinaryOperator)">
            <div data-type="text">Performs a <a href="package-summary.html#Reduction">reduction</a> on the elements of this stream, using the provided identity value and an <a href="package-summary.html#Associativity">associative</a> accumulation function, and returns the reduced value.  This is equivalent to: <pre> {@code
    double result = identity;
    for (double element : this stream)
        result = accumulator.applyAsDouble(result, element)
    return result;
}</pre> but is not constrained to execute sequentially. <p>The  {@code identity} value must be an identity for the accumulator function. This means that for all  {@code x}, {@code accumulator.apply(identity, x)} is equal to  {@code x}. The  {@code accumulator} function must be an <a href="package-summary.html#Associativity">associative</a> function. </p><p>This is a <a href="package-summary.html#StreamOps">terminal operation</a>.</p></div>
            <div data-type="tag">Sum, min, max, and average are all special cases of reduction. Summing a stream of numbers can be expressed as: <pre> {@code
    double sum = numbers.reduce(0, (a, b) -&gt; a+b);
}</pre> or more compactly: <pre> {@code
    double sum = numbers.reduce(0, Double::sum);
}</pre> <p>While this may seem a more roundabout way to perform an aggregation compared to simply mutating a running total in a loop, reduction operations parallelize more gracefully, without needing additional synchronization and with greatly reduced risk of data races.</p></div>
            <div data-type="tag" data-parameter-name="identity">the identity value for the accumulating function</div>
            <div data-type="tag" data-parameter-name="op">an <a href="package-summary.html#Associativity">associative</a>, <a href="package-summary.html#NonInterference">non-interfering</a>, <a href="package-summary.html#Statelessness">stateless</a> function for combining two values</div>
            <div data-type="tag">the result of the reduction</div>
            <div data-type="tag">#sum()</div>
            <div data-type="tag">#min()</div>
            <div data-type="tag">#max()</div>
            <div data-type="tag">#average()</div>
          </div>
          <div data-type="method" data-name="reduce(java.util.function.DoubleBinaryOperator)">
            <div data-type="text">Performs a <a href="package-summary.html#Reduction">reduction</a> on the elements of this stream, using an <a href="package-summary.html#Associativity">associative</a> accumulation function, and returns an  {@code OptionalDouble} describing the reduced value, if any. This is equivalent to: <pre> {@code
    boolean foundAny = false;
    double result = null;
    for (double element : this stream) {
        if (!foundAny) {
            foundAny = true;
            result = element;
        }
        else
            result = accumulator.applyAsDouble(result, element);
    }
    return foundAny ? OptionalDouble.of(result) : OptionalDouble.empty();
}</pre> but is not constrained to execute sequentially. <p>The  {@code accumulator} function must be an <a href="package-summary.html#Associativity">associative</a> function. </p><p>This is a <a href="package-summary.html#StreamOps">terminal operation</a>.</p></div>
            <div data-type="tag" data-parameter-name="op">an <a href="package-summary.html#Associativity">associative</a>, <a href="package-summary.html#NonInterference">non-interfering</a>, <a href="package-summary.html#Statelessness">stateless</a> function for combining two values</div>
            <div data-type="tag">the result of the reduction</div>
            <div data-type="tag">#reduce(double, DoubleBinaryOperator)</div>
          </div>
          <div data-type="method" data-name="collect(java.util.function.Supplier&lt;R&gt;, java.util.function.ObjDoubleConsumer&lt;R&gt;, java.util.function.BiConsumer&lt;R, R&gt;)">
            <div data-type="text">Performs a <a href="package-summary.html#MutableReduction">mutable reduction</a> operation on the elements of this stream.  A mutable reduction is one in which the reduced value is a mutable result container, such as an  {@code ArrayList}, and elements are incorporated by updating the state of the result rather than by replacing the result.  This produces a result equivalent to: <pre> {@code
    R result = supplier.get();
    for (double element : this stream)
        accumulator.accept(result, element);
    return result;
}</pre> <p>Like  {@link #reduce(double, DoubleBinaryOperator)},  {@code collect} operations can be parallelized without requiring additional synchronization. </p><p>This is a <a href="package-summary.html#StreamOps">terminal operation</a>.</p></div>
            <div data-type="tag" data-parameter-name="R" data-is-type-parameter="data-is-type-parameter">type of the result</div>
            <div data-type="tag" data-parameter-name="supplier">a function that creates a new result container. For a parallel execution, this function may be called multiple times and must return a fresh value each time.</div>
            <div data-type="tag" data-parameter-name="accumulator">an <a href="package-summary.html#Associativity">associative</a>, <a href="package-summary.html#NonInterference">non-interfering</a>, <a href="package-summary.html#Statelessness">stateless</a> function for incorporating an additional element into a result</div>
            <div data-type="tag" data-parameter-name="combiner">an <a href="package-summary.html#Associativity">associative</a>, <a href="package-summary.html#NonInterference">non-interfering</a>, <a href="package-summary.html#Statelessness">stateless</a> function for combining two values, which must be compatible with the accumulator function</div>
            <div data-type="tag">the result of the reduction</div>
            <div data-type="tag">Stream#collect(Supplier, BiConsumer, BiConsumer)</div>
          </div>
          <div data-type="method" data-name="sum()">
            <div data-type="text">Returns the sum of elements in this stream. Summation is a special case of a <a href="package-summary.html#Reduction">reduction</a>. If floating-point summation were exact, this method would be equivalent to: <pre> {@code
    return reduce(0, Double::sum);
}</pre> However, since floating-point summation is not exact, the above code is not necessarily equivalent to the summation computation done by this method. <p>If any stream element is a NaN or the sum is at any point a NaN then the sum will be NaN. The value of a floating-point sum is a function both of the input values as well as the order of addition operations. The order of addition operations of this method is intentionally not defined to allow for implementation flexibility to improve the speed and accuracy of the computed result. In particular, this method may be implemented using compensated summation or other technique to reduce the error bound in the numerical sum compared to a simple summation of  {@code double} values. </p><p>This is a <a href="package-summary.html#StreamOps">terminal operation</a>.</p></div>
            <div data-type="tag">Elements sorted by increasing absolute magnitude tend to yield more accurate results.</div>
            <div data-type="tag">the sum of elements in this stream</div>
          </div>
          <div data-type="method" data-name="min()">
            <div data-type="text">Returns an  {@code OptionalDouble} describing the minimum element of this stream, or an empty OptionalDouble if this stream is empty.  The minimum element will be  {@code Double.NaN} if any stream element was NaN. Unlike the numerical comparison operators, this method considers negative zero to be strictly smaller than positive zero. This is a special case of a <a href="package-summary.html#Reduction">reduction</a> and is equivalent to: <pre> {@code
    return reduce(Double::min);
}</pre> <p>This is a <a href="package-summary.html#StreamOps">terminal operation</a>.</p></div>
            <div data-type="tag">an  {@code OptionalDouble} containing the minimum element of this stream, or an empty optional if the stream is empty</div>
          </div>
          <div data-type="method" data-name="max()">
            <div data-type="text">Returns an  {@code OptionalDouble} describing the maximum element of this stream, or an empty OptionalDouble if this stream is empty.  The maximum element will be  {@code Double.NaN} if any stream element was NaN. Unlike the numerical comparison operators, this method considers negative zero to be strictly smaller than positive zero. This is a special case of a <a href="package-summary.html#Reduction">reduction</a> and is equivalent to: <pre> {@code
    return reduce(Double::max);
}</pre> <p>This is a <a href="package-summary.html#StreamOps">terminal operation</a>.</p></div>
            <div data-type="tag">an  {@code OptionalDouble} containing the maximum element of this stream, or an empty optional if the stream is empty</div>
          </div>
          <div data-type="method" data-name="count()">
            <div data-type="text">Returns the count of elements in this stream.  This is a special case of a <a href="package-summary.html#Reduction">reduction</a> and is equivalent to: <pre> {@code
    return mapToLong(e -&gt; 1L).sum();
}</pre> <p>This is a <a href="package-summary.html#StreamOps">terminal operation</a>.</p></div>
            <div data-type="tag">the count of elements in this stream</div>
          </div>
          <div data-type="method" data-name="average()">
            <div data-type="text">Returns an  {@code OptionalDouble} describing the arithmetic mean of elements of this stream, or an empty optional if this stream is empty. If any recorded value is a NaN or the sum is at any point a NaN then the average will be NaN. <p>The average returned can vary depending upon the order in which values are recorded. This method may be implemented using compensated summation or other technique to reduce the error bound in the  {@link #sum numerical sum} used to compute the average. </p><p>The average is a special case of a <a href="package-summary.html#Reduction">reduction</a>. </p><p>This is a <a href="package-summary.html#StreamOps">terminal operation</a>.</p></div>
            <div data-type="tag">Elements sorted by increasing absolute magnitude tend to yield more accurate results.</div>
            <div data-type="tag">an  {@code OptionalDouble} containing the average element of this stream, or an empty optional if the stream is empty</div>
          </div>
          <div data-type="method" data-name="summaryStatistics()">
            <div data-type="text">Returns a  {@code DoubleSummaryStatistics} describing various summary data about the elements of this stream.  This is a special case of a <a href="package-summary.html#Reduction">reduction</a>. <p>This is a <a href="package-summary.html#StreamOps">terminal operation</a>.</p></div>
            <div data-type="tag">a  {@code DoubleSummaryStatistics} describing various summary data about the elements of this stream</div>
          </div>
          <div data-type="method" data-name="anyMatch(java.util.function.DoublePredicate)">
            <div data-type="text">Returns whether any elements of this stream match the provided predicate.  May not evaluate the predicate on all elements if not necessary for determining the result.  If the stream is empty then {@code false} is returned and the predicate is not evaluated. <p>This is a <a href="package-summary.html#StreamOps">short-circuiting terminal operation</a>.</p></div>
            <div data-type="tag">This method evaluates the <em>existential quantification</em> of the predicate over the elements of the stream (for some x P(x)).</div>
            <div data-type="tag" data-parameter-name="predicate">a <a href="package-summary.html#NonInterference">non-interfering</a>, <a href="package-summary.html#Statelessness">stateless</a> predicate to apply to elements of this stream</div>
            <div data-type="tag"> {@code true} if any elements of the stream match the provided predicate, otherwise  {@code false}</div>
          </div>
          <div data-type="method" data-name="allMatch(java.util.function.DoublePredicate)">
            <div data-type="text">Returns whether all elements of this stream match the provided predicate. May not evaluate the predicate on all elements if not necessary for determining the result.  If the stream is empty then  {@code true} is returned and the predicate is not evaluated. <p>This is a <a href="package-summary.html#StreamOps">short-circuiting terminal operation</a>.</p></div>
            <div data-type="tag">This method evaluates the <em>universal quantification</em> of the predicate over the elements of the stream (for all x P(x)).  If the stream is empty, the quantification is said to be <em>vacuously satisfied</em> and is always  {@code true} (regardless of P(x)).</div>
            <div data-type="tag" data-parameter-name="predicate">a <a href="package-summary.html#NonInterference">non-interfering</a>, <a href="package-summary.html#Statelessness">stateless</a> predicate to apply to elements of this stream</div>
            <div data-type="tag"> {@code true} if either all elements of the stream match the provided predicate or the stream is empty, otherwise  {@code false}</div>
          </div>
          <div data-type="method" data-name="noneMatch(java.util.function.DoublePredicate)">
            <div data-type="text">Returns whether no elements of this stream match the provided predicate. May not evaluate the predicate on all elements if not necessary for determining the result.  If the stream is empty then  {@code true} is returned and the predicate is not evaluated. <p>This is a <a href="package-summary.html#StreamOps">short-circuiting terminal operation</a>.</p></div>
            <div data-type="tag">This method evaluates the <em>universal quantification</em> of the negated predicate over the elements of the stream (for all x ~P(x)).  If the stream is empty, the quantification is said to be vacuously satisfied and is always  {@code true}, regardless of P(x).</div>
            <div data-type="tag" data-parameter-name="predicate">a <a href="package-summary.html#NonInterference">non-interfering</a>, <a href="package-summary.html#Statelessness">stateless</a> predicate to apply to elements of this stream</div>
            <div data-type="tag"> {@code true} if either no elements of the stream match the provided predicate or the stream is empty, otherwise  {@code false}</div>
          </div>
          <div data-type="method" data-name="findFirst()">
            <div data-type="text">Returns an  {@link OptionalDouble} describing the first element of this stream, or an empty  {@code OptionalDouble} if the stream is empty.  If the stream has no encounter order, then any element may be returned. <p>This is a <a href="package-summary.html#StreamOps">short-circuiting terminal operation</a>.</p></div>
            <div data-type="tag">an  {@code OptionalDouble} describing the first element of this stream, or an empty  {@code OptionalDouble} if the stream is empty</div>
          </div>
          <div data-type="method" data-name="findAny()">
            <div data-type="text">Returns an  {@link OptionalDouble} describing some element of the stream, or an empty  {@code OptionalDouble} if the stream is empty. <p>This is a <a href="package-summary.html#StreamOps">short-circuiting terminal operation</a>. </p><p>The behavior of this operation is explicitly nondeterministic; it is free to select any element in the stream.  This is to allow for maximal performance in parallel operations; the cost is that multiple invocations on the same source may not return the same result.  (If a stable result is desired, use  {@link #findFirst()} instead.)</p></div>
            <div data-type="tag">an  {@code OptionalDouble} describing some element of this stream, or an empty  {@code OptionalDouble} if the stream is empty</div>
            <div data-type="tag">#findFirst()</div>
          </div>
          <div data-type="method" data-name="boxed()">
            <div data-type="text">Returns a  {@code Stream} consisting of the elements of this stream, boxed to  {@code Double}. <p>This is an <a href="package-summary.html#StreamOps">intermediate operation</a>.</p></div>
            <div data-type="tag">a  {@code Stream} consistent of the elements of this stream, each boxed to a  {@code Double}</div>
          </div>
          <div data-type="method" data-name="builder()">
            <div data-type="text">Returns a builder for a  {@code DoubleStream}.</div>
            <div data-type="tag">a stream builder</div>
          </div>
          <div data-type="method" data-name="empty()">
            <div data-type="text">Returns an empty sequential  {@code DoubleStream}.</div>
            <div data-type="tag">an empty sequential stream</div>
          </div>
          <div data-type="method" data-name="of(double)">
            <div data-type="text">Returns a sequential  {@code DoubleStream} containing a single element.</div>
            <div data-type="tag" data-parameter-name="t">the single element</div>
            <div data-type="tag">a singleton sequential stream</div>
          </div>
          <div data-type="method" data-name="of(double...)">
            <div data-type="text">Returns a sequential ordered stream whose elements are the specified values.</div>
            <div data-type="tag" data-parameter-name="values">the elements of the new stream</div>
            <div data-type="tag">the new stream</div>
          </div>
          <div data-type="method" data-name="iterate(double, java.util.function.DoubleUnaryOperator)">
            <div data-type="text">Returns an infinite sequential ordered  {@code DoubleStream} produced by iterative application of a function  {@code f} to an initial element  {@code seed}, producing a  {@code Stream} consisting of  {@code seed},  {@code f(seed)}, {@code f(f(seed))}, etc. <p>The first element (position  {@code 0}) in the  {@code DoubleStream} will be the provided  {@code seed}.  For  {@code n &gt; 0}, the element at position  {@code n}, will be the result of applying the function  {@code f} to the element at position  {@code n - 1}.</p></div>
            <div data-type="tag" data-parameter-name="seed">the initial element</div>
            <div data-type="tag" data-parameter-name="f">a function to be applied to to the previous element to produce a new element</div>
            <div data-type="tag">a new sequential  {@code DoubleStream}</div>
          </div>
          <div data-type="method" data-name="generate(java.util.function.DoubleSupplier)">
            <div data-type="text">Returns an infinite sequential unordered stream where each element is generated by the provided  {@code DoubleSupplier}.  This is suitable for generating constant streams, streams of random elements, etc.</div>
            <div data-type="tag" data-parameter-name="s">the  {@code DoubleSupplier} for generated elements</div>
            <div data-type="tag">a new infinite sequential unordered  {@code DoubleStream}</div>
          </div>
          <div data-type="method" data-name="concat(java.util.stream.DoubleStream, java.util.stream.DoubleStream)">
            <div data-type="text">Creates a lazily concatenated stream whose elements are all the elements of the first stream followed by all the elements of the second stream.  The resulting stream is ordered if both of the input streams are ordered, and parallel if either of the input streams is parallel.  When the resulting stream is closed, the close handlers for both input streams are invoked.</div>
            <div data-type="tag">Use caution when constructing streams from repeated concatenation. Accessing an element of a deeply concatenated stream can result in deep call chains, or even  {@code StackOverflowException}.</div>
            <div data-type="tag" data-parameter-name="a">the first stream</div>
            <div data-type="tag" data-parameter-name="b">the second stream</div>
            <div data-type="tag">the concatenation of the two input streams</div>
          </div>
        </div>
        <div data-type="class" data-name="java.util.stream.DoubleStream.Builder">
          <div data-type="text">A mutable builder for a  {@code DoubleStream}. <p>A stream builder has a lifecycle, which starts in a building phase, during which elements can be added, and then transitions to a built phase, after which elements may not be added.  The built phase begins when the  {@link #build()} method is called, which creates an ordered stream whose elements are the elements that were added to the stream builder, in the order they were added.</p></div>
          <div data-type="tag">DoubleStream#builder()</div>
          <div data-type="tag">1.8</div>
          <div data-type="method" data-name="accept(double)">
            <div data-type="text">Adds an element to the stream being built.</div>
            <div data-type="tag" data-exception-name="IllegalStateException">if the builder has already transitioned to the built state</div>
          </div>
          <div data-type="method" data-name="add(double)">
            <div data-type="text">Adds an element to the stream being built.</div>
            <div data-type="tag">The default implementation behaves as if: <pre> {@code
    accept(t)
    return this;
}</pre></div>
            <div data-type="tag" data-parameter-name="t">the element to add</div>
            <div data-type="tag"> {@code this} builder</div>
            <div data-type="tag" data-exception-name="IllegalStateException">if the builder has already transitioned to the built state</div>
          </div>
          <div data-type="method" data-name="build()">
            <div data-type="text">Builds the stream, transitioning this builder to the built state. An  {@code IllegalStateException} is thrown if there are further attempts to operate on the builder after it has entered the built state.</div>
            <div data-type="tag">the built stream</div>
            <div data-type="tag" data-exception-name="IllegalStateException">if the builder has already transitioned to the built state</div>
          </div>
        </div>
        <div data-type="class" data-name="java.util.stream.Collectors">
          <div data-type="text">Implementations of  {@link Collector} that implement various useful reduction operations, such as accumulating elements into collections, summarizing elements according to various criteria, etc. <p>The following are examples of using the predefined collectors to perform common mutable reduction tasks: </p><pre> {@code
    // Accumulate names into a List
    List&lt;String&gt; list = people.stream().map(Person::getName).collect(Collectors.toList());

    // Accumulate names into a TreeSet
    Set&lt;String&gt; set = people.stream().map(Person::getName).collect(Collectors.toCollection(TreeSet::new));

    // Convert elements to strings and concatenate them, separated by commas
    String joined = things.stream()
                          .map(Object::toString)
                          .collect(Collectors.joining(", "));

    // Compute sum of salaries of employee
    int total = employees.stream()
                         .collect(Collectors.summingInt(Employee::getSalary)));

    // Group employees by department
    Map&lt;Department, List&lt;Employee&gt;&gt; byDept
        = employees.stream()
                   .collect(Collectors.groupingBy(Employee::getDepartment));

    // Compute sum of salaries by department
    Map&lt;Department, Integer&gt; totalByDept
        = employees.stream()
                   .collect(Collectors.groupingBy(Employee::getDepartment,
                                                  Collectors.summingInt(Employee::getSalary)));

    // Partition students into passing and failing
    Map&lt;Boolean, List&lt;Student&gt;&gt; passingFailing =
        students.stream()
                .collect(Collectors.partitioningBy(s -&gt; s.getGrade() &gt;= PASS_THRESHOLD));

}</pre></div>
          <div data-type="tag">1.8</div>
          <div data-type="method" data-name="toCollection(java.util.function.Supplier&lt;C&gt;)">
            <div data-type="text">Returns a  {@code Collector} that accumulates the input elements into a new  {@code Collection}, in encounter order.  The  {@code Collection} is created by the provided factory.</div>
            <div data-type="tag" data-parameter-name="T" data-is-type-parameter="data-is-type-parameter">the type of the input elements</div>
            <div data-type="tag" data-parameter-name="C" data-is-type-parameter="data-is-type-parameter">the type of the resulting  {@code Collection}</div>
            <div data-type="tag" data-parameter-name="collectionFactory">a  {@code Supplier} which returns a new, empty {@code Collection} of the appropriate type</div>
            <div data-type="tag">a  {@code Collector} which collects all the input elements into a {@code Collection}, in encounter order</div>
          </div>
          <div data-type="method" data-name="toList()">
            <div data-type="text">Returns a  {@code Collector} that accumulates the input elements into a new  {@code List}. There are no guarantees on the type, mutability, serializability, or thread-safety of the  {@code List} returned; if more control over the returned  {@code List} is required, use  {@link #toCollection(Supplier)}.</div>
            <div data-type="tag" data-parameter-name="T" data-is-type-parameter="data-is-type-parameter">the type of the input elements</div>
            <div data-type="tag">a  {@code Collector} which collects all the input elements into a {@code List}, in encounter order</div>
          </div>
          <div data-type="method" data-name="toSet()">
            <div data-type="text">Returns a  {@code Collector} that accumulates the input elements into a new  {@code Set}. There are no guarantees on the type, mutability, serializability, or thread-safety of the  {@code Set} returned; if more control over the returned  {@code Set} is required, use {@link #toCollection(Supplier)}. <p>This is an  {@link Collector.Characteristics#UNORDERED unordered} Collector.</p></div>
            <div data-type="tag" data-parameter-name="T" data-is-type-parameter="data-is-type-parameter">the type of the input elements</div>
            <div data-type="tag">a  {@code Collector} which collects all the input elements into a {@code Set}</div>
          </div>
          <div data-type="method" data-name="joining()">
            <div data-type="text">Returns a  {@code Collector} that concatenates the input elements into a {@code String}, in encounter order.</div>
            <div data-type="tag">a  {@code Collector} that concatenates the input elements into a {@code String}, in encounter order</div>
          </div>
          <div data-type="method" data-name="joining(java.lang.CharSequence)">
            <div data-type="text">Returns a  {@code Collector} that concatenates the input elements, separated by the specified delimiter, in encounter order.</div>
            <div data-type="tag" data-parameter-name="delimiter">the delimiter to be used between each element</div>
            <div data-type="tag">A  {@code Collector} which concatenates CharSequence elements, separated by the specified delimiter, in encounter order</div>
          </div>
          <div data-type="method" data-name="joining(java.lang.CharSequence, java.lang.CharSequence, java.lang.CharSequence)">
            <div data-type="text">Returns a  {@code Collector} that concatenates the input elements, separated by the specified delimiter, with the specified prefix and suffix, in encounter order.</div>
            <div data-type="tag" data-parameter-name="delimiter">the delimiter to be used between each element</div>
            <div data-type="tag" data-parameter-name="prefix">the sequence of characters to be used at the beginning of the joined result</div>
            <div data-type="tag" data-parameter-name="suffix">the sequence of characters to be used at the end of the joined result</div>
            <div data-type="tag">A  {@code Collector} which concatenates CharSequence elements, separated by the specified delimiter, in encounter order</div>
          </div>
          <div data-type="method" data-name="mapping(java.util.function.Function&lt;? super T, ? extends U&gt;, java.util.stream.Collector&lt;? super U, A, R&gt;)">
            <div data-type="text">Adapts a  {@code Collector} accepting elements of type  {@code U} to one accepting elements of type  {@code T} by applying a mapping function to each input element before accumulation.</div>
            <div data-type="tag">The  {@code mapping()} collectors are most useful when used in a multi-level reduction, such as downstream of a  {@code groupingBy} or {@code partitioningBy}.  For example, given a stream of {@code Person}, to accumulate the set of last names in each city: <pre> {@code
    Map&lt;City, Set&lt;String&gt;&gt; lastNamesByCity
        = people.stream().collect(groupingBy(Person::getCity,
                                             mapping(Person::getLastName, toSet())));
}</pre></div>
            <div data-type="tag" data-parameter-name="T" data-is-type-parameter="data-is-type-parameter">the type of the input elements</div>
            <div data-type="tag" data-parameter-name="U" data-is-type-parameter="data-is-type-parameter">type of elements accepted by downstream collector</div>
            <div data-type="tag" data-parameter-name="A" data-is-type-parameter="data-is-type-parameter">intermediate accumulation type of the downstream collector</div>
            <div data-type="tag" data-parameter-name="R" data-is-type-parameter="data-is-type-parameter">result type of collector</div>
            <div data-type="tag" data-parameter-name="mapper">a function to be applied to the input elements</div>
            <div data-type="tag" data-parameter-name="downstream">a collector which will accept mapped values</div>
            <div data-type="tag">a collector which applies the mapping function to the input elements and provides the mapped results to the downstream collector</div>
          </div>
          <div data-type="method" data-name="collectingAndThen(java.util.stream.Collector&lt;T, A, R&gt;, java.util.function.Function&lt;R, RR&gt;)">
            <div data-type="text">Adapts a  {@code Collector} to perform an additional finishing transformation.  For example, one could adapt the  {@link #toList()} collector to always produce an immutable list with: <pre> {@code
    List&lt;String&gt; people
        = people.stream().collect(collectingAndThen(toList(), Collections::unmodifiableList));
}</pre></div>
            <div data-type="tag" data-parameter-name="T" data-is-type-parameter="data-is-type-parameter">the type of the input elements</div>
            <div data-type="tag" data-parameter-name="A" data-is-type-parameter="data-is-type-parameter">intermediate accumulation type of the downstream collector</div>
            <div data-type="tag" data-parameter-name="R" data-is-type-parameter="data-is-type-parameter">result type of the downstream collector</div>
            <div data-type="tag" data-parameter-name="RR" data-is-type-parameter="data-is-type-parameter">result type of the resulting collector</div>
            <div data-type="tag" data-parameter-name="downstream">a collector</div>
            <div data-type="tag" data-parameter-name="finisher">a function to be applied to the final result of the downstream collector</div>
            <div data-type="tag">a collector which performs the action of the downstream collector, followed by an additional finishing step</div>
          </div>
          <div data-type="method" data-name="counting()">
            <div data-type="text">Returns a  {@code Collector} accepting elements of type  {@code T} that counts the number of input elements.  If no elements are present, the result is 0.</div>
            <div data-type="tag">This produces a result equivalent to: <pre> {@code
    reducing(0L, e -&gt; 1L, Long::sum)
}</pre></div>
            <div data-type="tag" data-parameter-name="T" data-is-type-parameter="data-is-type-parameter">the type of the input elements</div>
            <div data-type="tag">a  {@code Collector} that counts the input elements</div>
          </div>
          <div data-type="method" data-name="minBy(java.util.Comparator&lt;? super T&gt;)">
            <div data-type="text">Returns a  {@code Collector} that produces the minimal element according to a given  {@code Comparator}, described as an  {@code Optional&lt;T&gt;}.</div>
            <div data-type="tag">This produces a result equivalent to: <pre> {@code
    reducing(BinaryOperator.minBy(comparator))
}</pre></div>
            <div data-type="tag" data-parameter-name="T" data-is-type-parameter="data-is-type-parameter">the type of the input elements</div>
            <div data-type="tag" data-parameter-name="comparator">a  {@code Comparator} for comparing elements</div>
            <div data-type="tag">a  {@code Collector} that produces the minimal value</div>
          </div>
          <div data-type="method" data-name="maxBy(java.util.Comparator&lt;? super T&gt;)">
            <div data-type="text">Returns a  {@code Collector} that produces the maximal element according to a given  {@code Comparator}, described as an  {@code Optional&lt;T&gt;}.</div>
            <div data-type="tag">This produces a result equivalent to: <pre> {@code
    reducing(BinaryOperator.maxBy(comparator))
}</pre></div>
            <div data-type="tag" data-parameter-name="T" data-is-type-parameter="data-is-type-parameter">the type of the input elements</div>
            <div data-type="tag" data-parameter-name="comparator">a  {@code Comparator} for comparing elements</div>
            <div data-type="tag">a  {@code Collector} that produces the maximal value</div>
          </div>
          <div data-type="method" data-name="summingInt(java.util.function.ToIntFunction&lt;? super T&gt;)">
            <div data-type="text">Returns a  {@code Collector} that produces the sum of a integer-valued function applied to the input elements.  If no elements are present, the result is 0.</div>
            <div data-type="tag" data-parameter-name="T" data-is-type-parameter="data-is-type-parameter">the type of the input elements</div>
            <div data-type="tag" data-parameter-name="mapper">a function extracting the property to be summed</div>
            <div data-type="tag">a  {@code Collector} that produces the sum of a derived property</div>
          </div>
          <div data-type="method" data-name="summingLong(java.util.function.ToLongFunction&lt;? super T&gt;)">
            <div data-type="text">Returns a  {@code Collector} that produces the sum of a long-valued function applied to the input elements.  If no elements are present, the result is 0.</div>
            <div data-type="tag" data-parameter-name="T" data-is-type-parameter="data-is-type-parameter">the type of the input elements</div>
            <div data-type="tag" data-parameter-name="mapper">a function extracting the property to be summed</div>
            <div data-type="tag">a  {@code Collector} that produces the sum of a derived property</div>
          </div>
          <div data-type="method" data-name="summingDouble(java.util.function.ToDoubleFunction&lt;? super T&gt;)">
            <div data-type="text">Returns a  {@code Collector} that produces the sum of a double-valued function applied to the input elements.  If no elements are present, the result is 0. <p>The sum returned can vary depending upon the order in which values are recorded, due to accumulated rounding error in addition of values of differing magnitudes. Values sorted by increasing absolute magnitude tend to yield more accurate results.  If any recorded value is a  {@code NaN} or the sum is at any point a  {@code NaN} then the sum will be  {@code NaN}.</p></div>
            <div data-type="tag" data-parameter-name="T" data-is-type-parameter="data-is-type-parameter">the type of the input elements</div>
            <div data-type="tag" data-parameter-name="mapper">a function extracting the property to be summed</div>
            <div data-type="tag">a  {@code Collector} that produces the sum of a derived property</div>
          </div>
          <div data-type="method" data-name="averagingInt(java.util.function.ToIntFunction&lt;? super T&gt;)">
            <div data-type="text">Returns a  {@code Collector} that produces the arithmetic mean of an integer-valued function applied to the input elements.  If no elements are present, the result is 0.</div>
            <div data-type="tag" data-parameter-name="T" data-is-type-parameter="data-is-type-parameter">the type of the input elements</div>
            <div data-type="tag" data-parameter-name="mapper">a function extracting the property to be summed</div>
            <div data-type="tag">a  {@code Collector} that produces the sum of a derived property</div>
          </div>
          <div data-type="method" data-name="averagingLong(java.util.function.ToLongFunction&lt;? super T&gt;)">
            <div data-type="text">Returns a  {@code Collector} that produces the arithmetic mean of a long-valued function applied to the input elements.  If no elements are present, the result is 0.</div>
            <div data-type="tag" data-parameter-name="T" data-is-type-parameter="data-is-type-parameter">the type of the input elements</div>
            <div data-type="tag" data-parameter-name="mapper">a function extracting the property to be summed</div>
            <div data-type="tag">a  {@code Collector} that produces the sum of a derived property</div>
          </div>
          <div data-type="method" data-name="averagingDouble(java.util.function.ToDoubleFunction&lt;? super T&gt;)">
            <div data-type="text">Returns a  {@code Collector} that produces the arithmetic mean of a double-valued function applied to the input elements.  If no elements are present, the result is 0. <p>The average returned can vary depending upon the order in which values are recorded, due to accumulated rounding error in addition of values of differing magnitudes. Values sorted by increasing absolute magnitude tend to yield more accurate results.  If any recorded value is a  {@code NaN} or the sum is at any point a  {@code NaN} then the average will be  {@code NaN}.</p></div>
            <div data-type="tag">The  {@code double} format can represent all consecutive integers in the range -2<sup>53</sup> to 2<sup>53</sup>. If the pipeline has more than 2<sup>53</sup> values, the divisor in the average computation will saturate at 2<sup>53</sup>, leading to additional numerical errors.</div>
            <div data-type="tag" data-parameter-name="T" data-is-type-parameter="data-is-type-parameter">the type of the input elements</div>
            <div data-type="tag" data-parameter-name="mapper">a function extracting the property to be summed</div>
            <div data-type="tag">a  {@code Collector} that produces the sum of a derived property</div>
          </div>
          <div data-type="method" data-name="reducing(T, java.util.function.BinaryOperator&lt;T&gt;)">
            <div data-type="text">Returns a  {@code Collector} which performs a reduction of its input elements under a specified  {@code BinaryOperator} using the provided identity.</div>
            <div data-type="tag">The  {@code reducing()} collectors are most useful when used in a multi-level reduction, downstream of  {@code groupingBy} or {@code partitioningBy}.  To perform a simple reduction on a stream, use  {@link Stream#reduce(Object, BinaryOperator)}} instead.</div>
            <div data-type="tag" data-parameter-name="T" data-is-type-parameter="data-is-type-parameter">element type for the input and output of the reduction</div>
            <div data-type="tag" data-parameter-name="identity">the identity value for the reduction (also, the value that is returned when there are no input elements)</div>
            <div data-type="tag" data-parameter-name="op">a  {@code BinaryOperator&lt;T&gt;} used to reduce the input elements</div>
            <div data-type="tag">a  {@code Collector} which implements the reduction operation</div>
            <div data-type="tag">#reducing(BinaryOperator)</div>
            <div data-type="tag">#reducing(Object, Function, BinaryOperator)</div>
          </div>
          <div data-type="method" data-name="reducing(java.util.function.BinaryOperator&lt;T&gt;)">
            <div data-type="text">Returns a  {@code Collector} which performs a reduction of its input elements under a specified  {@code BinaryOperator}.  The result is described as an  {@code Optional&lt;T&gt;}.</div>
            <div data-type="tag">The  {@code reducing()} collectors are most useful when used in a multi-level reduction, downstream of  {@code groupingBy} or {@code partitioningBy}.  To perform a simple reduction on a stream, use  {@link Stream#reduce(BinaryOperator)} instead. <p>For example, given a stream of  {@code Person}, to calculate tallest person in each city: </p><pre> {@code
    Comparator&lt;Person&gt; byHeight = Comparator.comparing(Person::getHeight);
    Map&lt;City, Person&gt; tallestByCity
        = people.stream().collect(groupingBy(Person::getCity, reducing(BinaryOperator.maxBy(byHeight))));
}</pre></div>
            <div data-type="tag" data-parameter-name="T" data-is-type-parameter="data-is-type-parameter">element type for the input and output of the reduction</div>
            <div data-type="tag" data-parameter-name="op">a  {@code BinaryOperator&lt;T&gt;} used to reduce the input elements</div>
            <div data-type="tag">a  {@code Collector} which implements the reduction operation</div>
            <div data-type="tag">#reducing(Object, BinaryOperator)</div>
            <div data-type="tag">#reducing(Object, Function, BinaryOperator)</div>
          </div>
          <div data-type="method" data-name="reducing(U, java.util.function.Function&lt;? super T, ? extends U&gt;, java.util.function.BinaryOperator&lt;U&gt;)">
            <div data-type="text">Returns a  {@code Collector} which performs a reduction of its input elements under a specified mapping function and {@code BinaryOperator}. This is a generalization of {@link #reducing(Object, BinaryOperator)} which allows a transformation of the elements before reduction.</div>
            <div data-type="tag">The  {@code reducing()} collectors are most useful when used in a multi-level reduction, downstream of  {@code groupingBy} or {@code partitioningBy}.  To perform a simple map-reduce on a stream, use  {@link Stream#map(Function)} and  {@link Stream#reduce(Object, BinaryOperator)} instead. <p>For example, given a stream of  {@code Person}, to calculate the longest last name of residents in each city: </p><pre> {@code
    Comparator&lt;String&gt; byLength = Comparator.comparing(String::length);
    Map&lt;City, String&gt; longestLastNameByCity
        = people.stream().collect(groupingBy(Person::getCity,
                                             reducing(Person::getLastName, BinaryOperator.maxBy(byLength))));
}</pre></div>
            <div data-type="tag" data-parameter-name="T" data-is-type-parameter="data-is-type-parameter">the type of the input elements</div>
            <div data-type="tag" data-parameter-name="U" data-is-type-parameter="data-is-type-parameter">the type of the mapped values</div>
            <div data-type="tag" data-parameter-name="identity">the identity value for the reduction (also, the value that is returned when there are no input elements)</div>
            <div data-type="tag" data-parameter-name="mapper">a mapping function to apply to each input value</div>
            <div data-type="tag" data-parameter-name="op">a  {@code BinaryOperator&lt;U&gt;} used to reduce the mapped values</div>
            <div data-type="tag">a  {@code Collector} implementing the map-reduce operation</div>
            <div data-type="tag">#reducing(Object, BinaryOperator)</div>
            <div data-type="tag">#reducing(BinaryOperator)</div>
          </div>
          <div data-type="method" data-name="groupingBy(java.util.function.Function&lt;? super T, ? extends K&gt;)">
            <div data-type="text">Returns a  {@code Collector} implementing a "group by" operation on input elements of type  {@code T}, grouping elements according to a classification function, and returning the results in a  {@code Map}. <p>The classification function maps elements to some key type  {@code K}. The collector produces a  {@code Map&lt;K, List&lt;T&gt;&gt;} whose keys are the values resulting from applying the classification function to the input elements, and whose corresponding values are  {@code List}s containing the input elements which map to the associated key under the classification function. </p><p>There are no guarantees on the type, mutability, serializability, or thread-safety of the  {@code Map} or  {@code List} objects returned.</p></div>
            <div data-type="tag">This produces a result similar to: <pre> {@code
    groupingBy(classifier, toList());
}</pre></div>
            <div data-type="tag">The returned  {@code Collector} is not concurrent.  For parallel stream pipelines, the  {@code combiner} function operates by merging the keys from one map into another, which can be an expensive operation.  If preservation of the order in which elements appear in the resulting  {@code Map} collector is not required, using  {@link #groupingByConcurrent(Function)} may offer better parallel performance.</div>
            <div data-type="tag" data-parameter-name="T" data-is-type-parameter="data-is-type-parameter">the type of the input elements</div>
            <div data-type="tag" data-parameter-name="K" data-is-type-parameter="data-is-type-parameter">the type of the keys</div>
            <div data-type="tag" data-parameter-name="classifier">the classifier function mapping input elements to keys</div>
            <div data-type="tag">a  {@code Collector} implementing the group-by operation</div>
            <div data-type="tag">#groupingBy(Function, Collector)</div>
            <div data-type="tag">#groupingBy(Function, Supplier, Collector)</div>
            <div data-type="tag">#groupingByConcurrent(Function)</div>
          </div>
          <div data-type="method" data-name="groupingBy(java.util.function.Function&lt;? super T, ? extends K&gt;, java.util.stream.Collector&lt;? super T, A, D&gt;)">
            <div data-type="text">Returns a  {@code Collector} implementing a cascaded "group by" operation on input elements of type  {@code T}, grouping elements according to a classification function, and then performing a reduction operation on the values associated with a given key using the specified downstream {@code Collector}. <p>The classification function maps elements to some key type  {@code K}. The downstream collector operates on elements of type  {@code T} and produces a result of type  {@code D}. The resulting collector produces a {@code Map&lt;K, D&gt;}. </p><p>There are no guarantees on the type, mutability, serializability, or thread-safety of the  {@code Map} returned. </p><p>For example, to compute the set of last names of people in each city: </p><pre> {@code
    Map&lt;City, Set&lt;String&gt;&gt; namesByCity
        = people.stream().collect(groupingBy(Person::getCity,
                                             mapping(Person::getLastName, toSet())));
}</pre></div>
            <div data-type="tag">The returned  {@code Collector} is not concurrent.  For parallel stream pipelines, the  {@code combiner} function operates by merging the keys from one map into another, which can be an expensive operation.  If preservation of the order in which elements are presented to the downstream collector is not required, using  {@link #groupingByConcurrent(Function, Collector)} may offer better parallel performance.</div>
            <div data-type="tag" data-parameter-name="T" data-is-type-parameter="data-is-type-parameter">the type of the input elements</div>
            <div data-type="tag" data-parameter-name="K" data-is-type-parameter="data-is-type-parameter">the type of the keys</div>
            <div data-type="tag" data-parameter-name="A" data-is-type-parameter="data-is-type-parameter">the intermediate accumulation type of the downstream collector</div>
            <div data-type="tag" data-parameter-name="D" data-is-type-parameter="data-is-type-parameter">the result type of the downstream reduction</div>
            <div data-type="tag" data-parameter-name="classifier">a classifier function mapping input elements to keys</div>
            <div data-type="tag" data-parameter-name="downstream">a  {@code Collector} implementing the downstream reduction</div>
            <div data-type="tag">a  {@code Collector} implementing the cascaded group-by operation</div>
            <div data-type="tag">#groupingBy(Function)</div>
            <div data-type="tag">#groupingBy(Function, Supplier, Collector)</div>
            <div data-type="tag">#groupingByConcurrent(Function, Collector)</div>
          </div>
          <div data-type="method" data-name="groupingBy(java.util.function.Function&lt;? super T, ? extends K&gt;, java.util.function.Supplier&lt;M&gt;, java.util.stream.Collector&lt;? super T, A, D&gt;)">
            <div data-type="text">Returns a  {@code Collector} implementing a cascaded "group by" operation on input elements of type  {@code T}, grouping elements according to a classification function, and then performing a reduction operation on the values associated with a given key using the specified downstream {@code Collector}.  The  {@code Map} produced by the Collector is created with the supplied factory function. <p>The classification function maps elements to some key type  {@code K}. The downstream collector operates on elements of type  {@code T} and produces a result of type  {@code D}. The resulting collector produces a {@code Map&lt;K, D&gt;}. </p><p>For example, to compute the set of last names of people in each city, where the city names are sorted: </p><pre> {@code
    Map&lt;City, Set&lt;String&gt;&gt; namesByCity
        = people.stream().collect(groupingBy(Person::getCity, TreeMap::new,
                                             mapping(Person::getLastName, toSet())));
}</pre></div>
            <div data-type="tag">The returned  {@code Collector} is not concurrent.  For parallel stream pipelines, the  {@code combiner} function operates by merging the keys from one map into another, which can be an expensive operation.  If preservation of the order in which elements are presented to the downstream collector is not required, using  {@link #groupingByConcurrent(Function, Supplier, Collector)} may offer better parallel performance.</div>
            <div data-type="tag" data-parameter-name="T" data-is-type-parameter="data-is-type-parameter">the type of the input elements</div>
            <div data-type="tag" data-parameter-name="K" data-is-type-parameter="data-is-type-parameter">the type of the keys</div>
            <div data-type="tag" data-parameter-name="A" data-is-type-parameter="data-is-type-parameter">the intermediate accumulation type of the downstream collector</div>
            <div data-type="tag" data-parameter-name="D" data-is-type-parameter="data-is-type-parameter">the result type of the downstream reduction</div>
            <div data-type="tag" data-parameter-name="M" data-is-type-parameter="data-is-type-parameter">the type of the resulting  {@code Map}</div>
            <div data-type="tag" data-parameter-name="classifier">a classifier function mapping input elements to keys</div>
            <div data-type="tag" data-parameter-name="downstream">a  {@code Collector} implementing the downstream reduction</div>
            <div data-type="tag" data-parameter-name="mapFactory">a function which, when called, produces a new empty {@code Map} of the desired type</div>
            <div data-type="tag">a  {@code Collector} implementing the cascaded group-by operation</div>
            <div data-type="tag">#groupingBy(Function, Collector)</div>
            <div data-type="tag">#groupingBy(Function)</div>
            <div data-type="tag">#groupingByConcurrent(Function, Supplier, Collector)</div>
          </div>
          <div data-type="method" data-name="groupingByConcurrent(java.util.function.Function&lt;? super T, ? extends K&gt;)">
            <div data-type="text">Returns a concurrent  {@code Collector} implementing a "group by" operation on input elements of type  {@code T}, grouping elements according to a classification function. <p>This is a  {@link Collector.Characteristics#CONCURRENT concurrent} and {@link Collector.Characteristics#UNORDERED unordered} Collector. </p><p>The classification function maps elements to some key type  {@code K}. The collector produces a  {@code ConcurrentMap&lt;K, List&lt;T&gt;&gt;} whose keys are the values resulting from applying the classification function to the input elements, and whose corresponding values are  {@code List}s containing the input elements which map to the associated key under the classification function. </p><p>There are no guarantees on the type, mutability, or serializability of the  {@code Map} or  {@code List} objects returned, or of the thread-safety of the  {@code List} objects returned.</p></div>
            <div data-type="tag">This produces a result similar to: <pre> {@code
    groupingByConcurrent(classifier, toList());
}</pre></div>
            <div data-type="tag" data-parameter-name="T" data-is-type-parameter="data-is-type-parameter">the type of the input elements</div>
            <div data-type="tag" data-parameter-name="K" data-is-type-parameter="data-is-type-parameter">the type of the keys</div>
            <div data-type="tag" data-parameter-name="classifier">a classifier function mapping input elements to keys</div>
            <div data-type="tag">a concurrent, unordered  {@code Collector} implementing the group-by operation</div>
            <div data-type="tag">#groupingBy(Function)</div>
            <div data-type="tag">#groupingByConcurrent(Function, Collector)</div>
            <div data-type="tag">#groupingByConcurrent(Function, Supplier, Collector)</div>
          </div>
          <div data-type="method" data-name="groupingByConcurrent(java.util.function.Function&lt;? super T, ? extends K&gt;, java.util.stream.Collector&lt;? super T, A, D&gt;)">
            <div data-type="text">Returns a concurrent  {@code Collector} implementing a cascaded "group by" operation on input elements of type  {@code T}, grouping elements according to a classification function, and then performing a reduction operation on the values associated with a given key using the specified downstream  {@code Collector}. <p>This is a  {@link Collector.Characteristics#CONCURRENT concurrent} and {@link Collector.Characteristics#UNORDERED unordered} Collector. </p><p>The classification function maps elements to some key type  {@code K}. The downstream collector operates on elements of type  {@code T} and produces a result of type  {@code D}. The resulting collector produces a {@code Map&lt;K, D&gt;}. </p><p>For example, to compute the set of last names of people in each city, where the city names are sorted: </p><pre> {@code
    ConcurrentMap&lt;City, Set&lt;String&gt;&gt; namesByCity
        = people.stream().collect(groupingByConcurrent(Person::getCity,
                                                       mapping(Person::getLastName, toSet())));
}</pre></div>
            <div data-type="tag" data-parameter-name="T" data-is-type-parameter="data-is-type-parameter">the type of the input elements</div>
            <div data-type="tag" data-parameter-name="K" data-is-type-parameter="data-is-type-parameter">the type of the keys</div>
            <div data-type="tag" data-parameter-name="A" data-is-type-parameter="data-is-type-parameter">the intermediate accumulation type of the downstream collector</div>
            <div data-type="tag" data-parameter-name="D" data-is-type-parameter="data-is-type-parameter">the result type of the downstream reduction</div>
            <div data-type="tag" data-parameter-name="classifier">a classifier function mapping input elements to keys</div>
            <div data-type="tag" data-parameter-name="downstream">a  {@code Collector} implementing the downstream reduction</div>
            <div data-type="tag">a concurrent, unordered  {@code Collector} implementing the cascaded group-by operation</div>
            <div data-type="tag">#groupingBy(Function, Collector)</div>
            <div data-type="tag">#groupingByConcurrent(Function)</div>
            <div data-type="tag">#groupingByConcurrent(Function, Supplier, Collector)</div>
          </div>
          <div data-type="method" data-name="groupingByConcurrent(java.util.function.Function&lt;? super T, ? extends K&gt;, java.util.function.Supplier&lt;M&gt;, java.util.stream.Collector&lt;? super T, A, D&gt;)">
            <div data-type="text">Returns a concurrent  {@code Collector} implementing a cascaded "group by" operation on input elements of type  {@code T}, grouping elements according to a classification function, and then performing a reduction operation on the values associated with a given key using the specified downstream  {@code Collector}.  The  {@code ConcurrentMap} produced by the Collector is created with the supplied factory function. <p>This is a  {@link Collector.Characteristics#CONCURRENT concurrent} and {@link Collector.Characteristics#UNORDERED unordered} Collector. </p><p>The classification function maps elements to some key type  {@code K}. The downstream collector operates on elements of type  {@code T} and produces a result of type  {@code D}. The resulting collector produces a {@code Map&lt;K, D&gt;}. </p><p>For example, to compute the set of last names of people in each city, where the city names are sorted: </p><pre> {@code
    ConcurrentMap&lt;City, Set&lt;String&gt;&gt; namesByCity
        = people.stream().collect(groupingBy(Person::getCity, ConcurrentSkipListMap::new,
                                             mapping(Person::getLastName, toSet())));
}</pre></div>
            <div data-type="tag" data-parameter-name="T" data-is-type-parameter="data-is-type-parameter">the type of the input elements</div>
            <div data-type="tag" data-parameter-name="K" data-is-type-parameter="data-is-type-parameter">the type of the keys</div>
            <div data-type="tag" data-parameter-name="A" data-is-type-parameter="data-is-type-parameter">the intermediate accumulation type of the downstream collector</div>
            <div data-type="tag" data-parameter-name="D" data-is-type-parameter="data-is-type-parameter">the result type of the downstream reduction</div>
            <div data-type="tag" data-parameter-name="M" data-is-type-parameter="data-is-type-parameter">the type of the resulting  {@code ConcurrentMap}</div>
            <div data-type="tag" data-parameter-name="classifier">a classifier function mapping input elements to keys</div>
            <div data-type="tag" data-parameter-name="downstream">a  {@code Collector} implementing the downstream reduction</div>
            <div data-type="tag" data-parameter-name="mapFactory">a function which, when called, produces a new empty {@code ConcurrentMap} of the desired type</div>
            <div data-type="tag">a concurrent, unordered  {@code Collector} implementing the cascaded group-by operation</div>
            <div data-type="tag">#groupingByConcurrent(Function)</div>
            <div data-type="tag">#groupingByConcurrent(Function, Collector)</div>
            <div data-type="tag">#groupingBy(Function, Supplier, Collector)</div>
          </div>
          <div data-type="method" data-name="partitioningBy(java.util.function.Predicate&lt;? super T&gt;)">
            <div data-type="text">Returns a  {@code Collector} which partitions the input elements according to a  {@code Predicate}, and organizes them into a {@code Map&lt;Boolean, List&lt;T&gt;&gt;}. There are no guarantees on the type, mutability, serializability, or thread-safety of the  {@code Map} returned.</div>
            <div data-type="tag" data-parameter-name="T" data-is-type-parameter="data-is-type-parameter">the type of the input elements</div>
            <div data-type="tag" data-parameter-name="predicate">a predicate used for classifying input elements</div>
            <div data-type="tag">a  {@code Collector} implementing the partitioning operation</div>
            <div data-type="tag">#partitioningBy(Predicate, Collector)</div>
          </div>
          <div data-type="method" data-name="partitioningBy(java.util.function.Predicate&lt;? super T&gt;, java.util.stream.Collector&lt;? super T, A, D&gt;)">
            <div data-type="text">Returns a  {@code Collector} which partitions the input elements according to a  {@code Predicate}, reduces the values in each partition according to another  {@code Collector}, and organizes them into a {@code Map&lt;Boolean, D&gt;} whose values are the result of the downstream reduction. <p>There are no guarantees on the type, mutability, serializability, or thread-safety of the  {@code Map} returned.</p></div>
            <div data-type="tag" data-parameter-name="T" data-is-type-parameter="data-is-type-parameter">the type of the input elements</div>
            <div data-type="tag" data-parameter-name="A" data-is-type-parameter="data-is-type-parameter">the intermediate accumulation type of the downstream collector</div>
            <div data-type="tag" data-parameter-name="D" data-is-type-parameter="data-is-type-parameter">the result type of the downstream reduction</div>
            <div data-type="tag" data-parameter-name="predicate">a predicate used for classifying input elements</div>
            <div data-type="tag" data-parameter-name="downstream">a  {@code Collector} implementing the downstream reduction</div>
            <div data-type="tag">a  {@code Collector} implementing the cascaded partitioning operation</div>
            <div data-type="tag">#partitioningBy(Predicate)</div>
          </div>
          <div data-type="method" data-name="toMap(java.util.function.Function&lt;? super T, ? extends K&gt;, java.util.function.Function&lt;? super T, ? extends U&gt;)">
            <div data-type="text">Returns a  {@code Collector} that accumulates elements into a {@code Map} whose keys and values are the result of applying the provided mapping functions to the input elements. <p>If the mapped keys contains duplicates (according to {@link Object#equals(Object)}), an  {@code IllegalStateException} is thrown when the collection operation is performed.  If the mapped keys may have duplicates, use  {@link #toMap(Function, Function, BinaryOperator)} instead.</p></div>
            <div data-type="tag">It is common for either the key or the value to be the input elements. In this case, the utility method {@link java.util.function.Function#identity()} may be helpful. For example, the following produces a  {@code Map} mapping students to their grade point average: <pre> {@code
    Map&lt;Student, Double&gt; studentToGPA
        students.stream().collect(toMap(Functions.identity(),
                                        student -&gt; computeGPA(student)));
}</pre> And the following produces a  {@code Map} mapping a unique identifier to students: <pre> {@code
    Map&lt;String, Student&gt; studentIdToStudent
        students.stream().collect(toMap(Student::getId,
                                        Functions.identity());
}</pre></div>
            <div data-type="tag">The returned  {@code Collector} is not concurrent.  For parallel stream pipelines, the  {@code combiner} function operates by merging the keys from one map into another, which can be an expensive operation.  If it is not required that results are inserted into the  {@code Map} in encounter order, using  {@link #toConcurrentMap(Function, Function)} may offer better parallel performance.</div>
            <div data-type="tag" data-parameter-name="T" data-is-type-parameter="data-is-type-parameter">the type of the input elements</div>
            <div data-type="tag" data-parameter-name="K" data-is-type-parameter="data-is-type-parameter">the output type of the key mapping function</div>
            <div data-type="tag" data-parameter-name="U" data-is-type-parameter="data-is-type-parameter">the output type of the value mapping function</div>
            <div data-type="tag" data-parameter-name="keyMapper">a mapping function to produce keys</div>
            <div data-type="tag" data-parameter-name="valueMapper">a mapping function to produce values</div>
            <div data-type="tag">a  {@code Collector} which collects elements into a  {@code Map} whose keys and values are the result of applying mapping functions to the input elements</div>
            <div data-type="tag">#toMap(Function, Function, BinaryOperator)</div>
            <div data-type="tag">#toMap(Function, Function, BinaryOperator, Supplier)</div>
            <div data-type="tag">#toConcurrentMap(Function, Function)</div>
          </div>
          <div data-type="method" data-name="toMap(java.util.function.Function&lt;? super T, ? extends K&gt;, java.util.function.Function&lt;? super T, ? extends U&gt;, java.util.function.BinaryOperator&lt;U&gt;)">
            <div data-type="text">Returns a  {@code Collector} that accumulates elements into a {@code Map} whose keys and values are the result of applying the provided mapping functions to the input elements. <p>If the mapped keys contains duplicates (according to  {@link Object#equals(Object)}), the value mapping function is applied to each equal element, and the results are merged using the provided merging function.</p></div>
            <div data-type="tag">There are multiple ways to deal with collisions between multiple elements mapping to the same key.  The other forms of  {@code toMap} simply use a merge function that throws unconditionally, but you can easily write more flexible merge policies.  For example, if you have a stream of  {@code Person}, and you want to produce a "phone book" mapping name to address, but it is possible that two persons have the same name, you can do as follows to gracefully deals with these collisions, and produce a {@code Map} mapping names to a concatenated list of addresses: <pre> {@code
    Map&lt;String, String&gt; phoneBook
        people.stream().collect(toMap(Person::getName,
                                      Person::getAddress,
                                      (s, a) -&gt; s + ", " + a));
}</pre></div>
            <div data-type="tag">The returned  {@code Collector} is not concurrent.  For parallel stream pipelines, the  {@code combiner} function operates by merging the keys from one map into another, which can be an expensive operation.  If it is not required that results are merged into the  {@code Map} in encounter order, using  {@link #toConcurrentMap(Function, Function, BinaryOperator)} may offer better parallel performance.</div>
            <div data-type="tag" data-parameter-name="T" data-is-type-parameter="data-is-type-parameter">the type of the input elements</div>
            <div data-type="tag" data-parameter-name="K" data-is-type-parameter="data-is-type-parameter">the output type of the key mapping function</div>
            <div data-type="tag" data-parameter-name="U" data-is-type-parameter="data-is-type-parameter">the output type of the value mapping function</div>
            <div data-type="tag" data-parameter-name="keyMapper">a mapping function to produce keys</div>
            <div data-type="tag" data-parameter-name="valueMapper">a mapping function to produce values</div>
            <div data-type="tag" data-parameter-name="mergeFunction">a merge function, used to resolve collisions between values associated with the same key, as supplied to  {@link Map#merge(Object, Object, BiFunction)}</div>
            <div data-type="tag">a  {@code Collector} which collects elements into a  {@code Map} whose keys are the result of applying a key mapping function to the input elements, and whose values are the result of applying a value mapping function to all input elements equal to the key and combining them using the merge function</div>
            <div data-type="tag">#toMap(Function, Function)</div>
            <div data-type="tag">#toMap(Function, Function, BinaryOperator, Supplier)</div>
            <div data-type="tag">#toConcurrentMap(Function, Function, BinaryOperator)</div>
          </div>
          <div data-type="method" data-name="toMap(java.util.function.Function&lt;? super T, ? extends K&gt;, java.util.function.Function&lt;? super T, ? extends U&gt;, java.util.function.BinaryOperator&lt;U&gt;, java.util.function.Supplier&lt;M&gt;)">
            <div data-type="text">Returns a  {@code Collector} that accumulates elements into a {@code Map} whose keys and values are the result of applying the provided mapping functions to the input elements. <p>If the mapped keys contains duplicates (according to  {@link Object#equals(Object)}), the value mapping function is applied to each equal element, and the results are merged using the provided merging function.  The  {@code Map} is created by a provided supplier function.</p></div>
            <div data-type="tag">The returned  {@code Collector} is not concurrent.  For parallel stream pipelines, the  {@code combiner} function operates by merging the keys from one map into another, which can be an expensive operation.  If it is not required that results are merged into the  {@code Map} in encounter order, using  {@link #toConcurrentMap(Function, Function, BinaryOperator, Supplier)} may offer better parallel performance.</div>
            <div data-type="tag" data-parameter-name="T" data-is-type-parameter="data-is-type-parameter">the type of the input elements</div>
            <div data-type="tag" data-parameter-name="K" data-is-type-parameter="data-is-type-parameter">the output type of the key mapping function</div>
            <div data-type="tag" data-parameter-name="U" data-is-type-parameter="data-is-type-parameter">the output type of the value mapping function</div>
            <div data-type="tag" data-parameter-name="M" data-is-type-parameter="data-is-type-parameter">the type of the resulting  {@code Map}</div>
            <div data-type="tag" data-parameter-name="keyMapper">a mapping function to produce keys</div>
            <div data-type="tag" data-parameter-name="valueMapper">a mapping function to produce values</div>
            <div data-type="tag" data-parameter-name="mergeFunction">a merge function, used to resolve collisions between values associated with the same key, as supplied to  {@link Map#merge(Object, Object, BiFunction)}</div>
            <div data-type="tag" data-parameter-name="mapSupplier">a function which returns a new, empty  {@code Map} into which the results will be inserted</div>
            <div data-type="tag">a  {@code Collector} which collects elements into a  {@code Map} whose keys are the result of applying a key mapping function to the input elements, and whose values are the result of applying a value mapping function to all input elements equal to the key and combining them using the merge function</div>
            <div data-type="tag">#toMap(Function, Function)</div>
            <div data-type="tag">#toMap(Function, Function, BinaryOperator)</div>
            <div data-type="tag">#toConcurrentMap(Function, Function, BinaryOperator, Supplier)</div>
          </div>
          <div data-type="method" data-name="toConcurrentMap(java.util.function.Function&lt;? super T, ? extends K&gt;, java.util.function.Function&lt;? super T, ? extends U&gt;)">
            <div data-type="text">Returns a concurrent  {@code Collector} that accumulates elements into a {@code ConcurrentMap} whose keys and values are the result of applying the provided mapping functions to the input elements. <p>If the mapped keys contains duplicates (according to {@link Object#equals(Object)}), an  {@code IllegalStateException} is thrown when the collection operation is performed.  If the mapped keys may have duplicates, use {@link #toConcurrentMap(Function, Function, BinaryOperator)} instead.</p></div>
            <div data-type="tag">It is common for either the key or the value to be the input elements. In this case, the utility method {@link java.util.function.Function#identity()} may be helpful. For example, the following produces a  {@code Map} mapping students to their grade point average: <pre> {@code
    Map&lt;Student, Double&gt; studentToGPA
        students.stream().collect(toMap(Functions.identity(),
                                        student -&gt; computeGPA(student)));
}</pre> And the following produces a  {@code Map} mapping a unique identifier to students: <pre> {@code
    Map&lt;String, Student&gt; studentIdToStudent
        students.stream().collect(toConcurrentMap(Student::getId,
                                                  Functions.identity());
}</pre> <p>This is a  {@link Collector.Characteristics#CONCURRENT concurrent} and {@link Collector.Characteristics#UNORDERED unordered} Collector.</p></div>
            <div data-type="tag" data-parameter-name="T" data-is-type-parameter="data-is-type-parameter">the type of the input elements</div>
            <div data-type="tag" data-parameter-name="K" data-is-type-parameter="data-is-type-parameter">the output type of the key mapping function</div>
            <div data-type="tag" data-parameter-name="U" data-is-type-parameter="data-is-type-parameter">the output type of the value mapping function</div>
            <div data-type="tag" data-parameter-name="keyMapper">the mapping function to produce keys</div>
            <div data-type="tag" data-parameter-name="valueMapper">the mapping function to produce values</div>
            <div data-type="tag">a concurrent, unordered  {@code Collector} which collects elements into a {@code ConcurrentMap} whose keys are the result of applying a key mapping function to the input elements, and whose values are the result of applying a value mapping function to the input elements</div>
            <div data-type="tag">#toMap(Function, Function)</div>
            <div data-type="tag">#toConcurrentMap(Function, Function, BinaryOperator)</div>
            <div data-type="tag">#toConcurrentMap(Function, Function, BinaryOperator, Supplier)</div>
          </div>
          <div data-type="method" data-name="toConcurrentMap(java.util.function.Function&lt;? super T, ? extends K&gt;, java.util.function.Function&lt;? super T, ? extends U&gt;, java.util.function.BinaryOperator&lt;U&gt;)">
            <div data-type="text">Returns a concurrent  {@code Collector} that accumulates elements into a {@code ConcurrentMap} whose keys and values are the result of applying the provided mapping functions to the input elements. <p>If the mapped keys contains duplicates (according to  {@link Object#equals(Object)}), the value mapping function is applied to each equal element, and the results are merged using the provided merging function.</p></div>
            <div data-type="tag">There are multiple ways to deal with collisions between multiple elements mapping to the same key.  The other forms of  {@code toConcurrentMap} simply use a merge function that throws unconditionally, but you can easily write more flexible merge policies.  For example, if you have a stream of  {@code Person}, and you want to produce a "phone book" mapping name to address, but it is possible that two persons have the same name, you can do as follows to gracefully deals with these collisions, and produce a {@code Map} mapping names to a concatenated list of addresses: <pre> {@code
    Map&lt;String, String&gt; phoneBook
        people.stream().collect(toConcurrentMap(Person::getName,
                                                Person::getAddress,
                                                (s, a) -&gt; s + ", " + a));
}</pre> <p>This is a  {@link Collector.Characteristics#CONCURRENT concurrent} and {@link Collector.Characteristics#UNORDERED unordered} Collector.</p></div>
            <div data-type="tag" data-parameter-name="T" data-is-type-parameter="data-is-type-parameter">the type of the input elements</div>
            <div data-type="tag" data-parameter-name="K" data-is-type-parameter="data-is-type-parameter">the output type of the key mapping function</div>
            <div data-type="tag" data-parameter-name="U" data-is-type-parameter="data-is-type-parameter">the output type of the value mapping function</div>
            <div data-type="tag" data-parameter-name="keyMapper">a mapping function to produce keys</div>
            <div data-type="tag" data-parameter-name="valueMapper">a mapping function to produce values</div>
            <div data-type="tag" data-parameter-name="mergeFunction">a merge function, used to resolve collisions between values associated with the same key, as supplied to  {@link Map#merge(Object, Object, BiFunction)}</div>
            <div data-type="tag">a concurrent, unordered  {@code Collector} which collects elements into a {@code ConcurrentMap} whose keys are the result of applying a key mapping function to the input elements, and whose values are the result of applying a value mapping function to all input elements equal to the key and combining them using the merge function</div>
            <div data-type="tag">#toConcurrentMap(Function, Function)</div>
            <div data-type="tag">#toConcurrentMap(Function, Function, BinaryOperator, Supplier)</div>
            <div data-type="tag">#toMap(Function, Function, BinaryOperator)</div>
          </div>
          <div data-type="method" data-name="toConcurrentMap(java.util.function.Function&lt;? super T, ? extends K&gt;, java.util.function.Function&lt;? super T, ? extends U&gt;, java.util.function.BinaryOperator&lt;U&gt;, java.util.function.Supplier&lt;M&gt;)">
            <div data-type="text">Returns a concurrent  {@code Collector} that accumulates elements into a {@code ConcurrentMap} whose keys and values are the result of applying the provided mapping functions to the input elements. <p>If the mapped keys contains duplicates (according to  {@link Object#equals(Object)}), the value mapping function is applied to each equal element, and the results are merged using the provided merging function.  The {@code ConcurrentMap} is created by a provided supplier function. </p><p>This is a  {@link Collector.Characteristics#CONCURRENT concurrent} and {@link Collector.Characteristics#UNORDERED unordered} Collector.</p></div>
            <div data-type="tag" data-parameter-name="T" data-is-type-parameter="data-is-type-parameter">the type of the input elements</div>
            <div data-type="tag" data-parameter-name="K" data-is-type-parameter="data-is-type-parameter">the output type of the key mapping function</div>
            <div data-type="tag" data-parameter-name="U" data-is-type-parameter="data-is-type-parameter">the output type of the value mapping function</div>
            <div data-type="tag" data-parameter-name="M" data-is-type-parameter="data-is-type-parameter">the type of the resulting  {@code ConcurrentMap}</div>
            <div data-type="tag" data-parameter-name="keyMapper">a mapping function to produce keys</div>
            <div data-type="tag" data-parameter-name="valueMapper">a mapping function to produce values</div>
            <div data-type="tag" data-parameter-name="mergeFunction">a merge function, used to resolve collisions between values associated with the same key, as supplied to  {@link Map#merge(Object, Object, BiFunction)}</div>
            <div data-type="tag" data-parameter-name="mapSupplier">a function which returns a new, empty  {@code Map} into which the results will be inserted</div>
            <div data-type="tag">a concurrent, unordered  {@code Collector} which collects elements into a {@code ConcurrentMap} whose keys are the result of applying a key mapping function to the input elements, and whose values are the result of applying a value mapping function to all input elements equal to the key and combining them using the merge function</div>
            <div data-type="tag">#toConcurrentMap(Function, Function)</div>
            <div data-type="tag">#toConcurrentMap(Function, Function, BinaryOperator)</div>
            <div data-type="tag">#toMap(Function, Function, BinaryOperator, Supplier)</div>
          </div>
          <div data-type="method" data-name="summarizingInt(java.util.function.ToIntFunction&lt;? super T&gt;)">
            <div data-type="text">Returns a  {@code Collector} which applies an  {@code int}-producing mapping function to each input element, and returns summary statistics for the resulting values.</div>
            <div data-type="tag" data-parameter-name="T" data-is-type-parameter="data-is-type-parameter">the type of the input elements</div>
            <div data-type="tag" data-parameter-name="mapper">a mapping function to apply to each element</div>
            <div data-type="tag">a  {@code Collector} implementing the summary-statistics reduction</div>
            <div data-type="tag">#summarizingDouble(ToDoubleFunction)</div>
            <div data-type="tag">#summarizingLong(ToLongFunction)</div>
          </div>
          <div data-type="method" data-name="summarizingLong(java.util.function.ToLongFunction&lt;? super T&gt;)">
            <div data-type="text">Returns a  {@code Collector} which applies an  {@code long}-producing mapping function to each input element, and returns summary statistics for the resulting values.</div>
            <div data-type="tag" data-parameter-name="T" data-is-type-parameter="data-is-type-parameter">the type of the input elements</div>
            <div data-type="tag" data-parameter-name="mapper">the mapping function to apply to each element</div>
            <div data-type="tag">a  {@code Collector} implementing the summary-statistics reduction</div>
            <div data-type="tag">#summarizingDouble(ToDoubleFunction)</div>
            <div data-type="tag">#summarizingInt(ToIntFunction)</div>
          </div>
          <div data-type="method" data-name="summarizingDouble(java.util.function.ToDoubleFunction&lt;? super T&gt;)">
            <div data-type="text">Returns a  {@code Collector} which applies an  {@code double}-producing mapping function to each input element, and returns summary statistics for the resulting values.</div>
            <div data-type="tag" data-parameter-name="T" data-is-type-parameter="data-is-type-parameter">the type of the input elements</div>
            <div data-type="tag" data-parameter-name="mapper">a mapping function to apply to each element</div>
            <div data-type="tag">a  {@code Collector} implementing the summary-statistics reduction</div>
            <div data-type="tag">#summarizingLong(ToLongFunction)</div>
            <div data-type="tag">#summarizingInt(ToIntFunction)</div>
          </div>
        </div>
        <div data-type="class" data-name="java.util.stream.Collector">
          <div data-type="text">A <a href="package-summary.html#Reduction">mutable reduction operation</a> that accumulates input elements into a mutable result container, optionally transforming the accumulated result into a final representation after all input elements have been processed.  Reduction operations can be performed either sequentially or in parallel. <p>Examples of mutable reduction operations include: accumulating elements into a  {@code Collection}; concatenating strings using a  {@code StringBuilder}; computing summary information about elements such as sum, min, max, or average; computing "pivot table" summaries such as "maximum valued transaction by seller", etc.  The class  {@link Collectors} provides implementations of many common mutable reductions. </p><p>A  {@code Collector} is specified by four functions that work together to accumulate entries into a mutable result container, and optionally perform a final transform on the result.  They are: </p><ul> <li>creation of a new result container ( {@link #supplier()})</li> <li>incorporating a new data element into a result container ( {@link #accumulator()})</li> <li>combining two result containers into one ( {@link #combiner()})</li> <li>performing an optional final transform on the container ( {@link #finisher()})</li> </ul> <p>Collectors also have a set of characteristics, such as {@link Characteristics#CONCURRENT}, that provide hints that can be used by a reduction implementation to provide better performance. </p><p>A sequential implementation of a reduction using a collector would create a single result container using the supplier function, and invoke the accumulator function once for each input element.  A parallel implementation would partition the input, create a result container for each partition, accumulate the contents of each partition into a subresult for that partition, and then use the combiner function to merge the subresults into a combined result. </p><p>To ensure that sequential and parallel executions produce equivalent results, the collector functions must satisfy an <em>identity</em> and an <a href="package-summary.html#Associativity">associativity</a> constraints. </p><p>The identity constraint says that for any partially accumulated result, combining it with an empty result container must produce an equivalent result.  That is, for a partially accumulated result  {@code a} that is the result of any series of accumulator and combiner invocations,  {@code a} must be equivalent to  {@code combiner.apply(a, supplier.get())}. </p><p>The associativity constraint says that splitting the computation must produce an equivalent result.  That is, for any input elements  {@code t1} and  {@code t2}, the results  {@code r1} and  {@code r2} in the computation below must be equivalent: </p><pre> {@code
    A a1 = supplier.get();
    accumulator.accept(a1, t1);
    accumulator.accept(a1, t2);
    R r1 = finisher.apply(a1);  // result without splitting

    A a2 = supplier.get();
    accumulator.accept(a2, t1);
    A a3 = supplier.get();
    accumulator.accept(a3, t2);
    R r2 = finisher.apply(combiner.apply(a2, a3));  // result with splitting
} </pre> <p>For collectors that do not have the  {@code UNORDERED} characteristic, two accumulated results  {@code a1} and  {@code a2} are equivalent if {@code finisher.apply(a1).equals(finisher.apply(a2))}.  For unordered collectors, equivalence is relaxed to allow for non-equality related to differences in order.  (For example, an unordered collector that accumulated elements to a  {@code List} would consider two lists equivalent if they contained the same elements, ignoring order.) </p><p>Libraries that implement reduction based on  {@code Collector}, such as {@link Stream#collect(Collector)}, must adhere to the following constraints: </p><ul> <li>The first argument passed to the accumulator function, both arguments passed to the combiner function, and the argument passed to the finisher function must be the result of a previous invocation of the result supplier, accumulator, or combiner functions.</li> <li>The implementation should not do anything with the result of any of the result supplier, accumulator, or combiner functions other than to pass them again to the accumulator, combiner, or finisher functions, or return them to the caller of the reduction operation.</li> <li>If a result is passed to the combiner or finisher function, and the same object is not returned from that function, it is never used again.</li> <li>Once a result is passed to the combiner or finisher function, it is never passed to the accumulator function again.</li> <li>For non-concurrent collectors, any result returned from the result supplier, accumulator, or combiner functions must be serially thread-confined.  This enables collection to occur in parallel without the  {@code Collector} needing to implement any additional synchronization. The reduction implementation must manage that the input is properly partitioned, that partitions are processed in isolation, and combining happens only after accumulation is complete.</li> <li>For concurrent collectors, an implementation is free to (but not required to) implement reduction concurrently.  A concurrent reduction is one where the accumulator function is called concurrently from multiple threads, using the same concurrently-modifiable result container, rather than keeping the result isolated during accumulation. A concurrent reduction should only be applied if the collector has the {@link Characteristics#UNORDERED} characteristics or if the originating data is unordered.</li> </ul> <p>In addition to the predefined implementations in  {@link Collectors}, the static factory methods  {@link #of(Supplier, BiConsumer, BinaryOperator, Characteristics...)} can be used to construct collectors.  For example, you could create a collector that accumulates widgets into a  {@code TreeSet} with: </p><pre> {@code
    Collector&lt;Widget, ?, TreeSet&lt;Widget&gt;&gt; intoSet =
        Collector.of(TreeSet::new, TreeSet::add,
                     (left, right) -&gt; { left.addAll(right); return left; });
}</pre> (This behavior is also implemented by the predefined collector {@link Collectors#toCollection(Supplier)}).</div>
          <div data-type="tag">Performing a reduction operation with a  {@code Collector} should produce a result equivalent to: <pre> {@code
    R container = collector.supplier().get();
    for (T t : data)
        collector.accumulator().accept(container, t);
    return collector.finisher().apply(container);
}</pre> <p>However, the library is free to partition the input, perform the reduction on the partitions, and then use the combiner function to combine the partial results to achieve a parallel reduction.  (Depending on the specific reduction operation, this may perform better or worse, depending on the relative cost of the accumulator and combiner functions.) </p><p>Collectors are designed to be <em>composed</em>; many of the methods in  {@link Collectors} are functions that take a collector and produce a new collector.  For example, given the following collector that computes the sum of the salaries of a stream of employees: </p><pre> {@code
    Collector&lt;Employee, ?, Integer&gt; summingSalaries
        = Collectors.summingInt(Employee::getSalary))
}</pre> If we wanted to create a collector to tabulate the sum of salaries by department, we could reuse the "sum of salaries" logic using {@link Collectors#groupingBy(Function, Collector)}: <pre> {@code
    Collector&lt;Employee, ?, Map&lt;Department, Integer&gt;&gt; summingSalariesByDept
        = Collectors.groupingBy(Employee::getDepartment, summingSalaries);
}</pre></div>
          <div data-type="tag">Stream#collect(Collector)</div>
          <div data-type="tag">Collectors</div>
          <div data-type="tag" data-parameter-name="T" data-is-type-parameter="data-is-type-parameter">the type of input elements to the reduction operation</div>
          <div data-type="tag" data-parameter-name="A" data-is-type-parameter="data-is-type-parameter">the mutable accumulation type of the reduction operation (often hidden as an implementation detail)</div>
          <div data-type="tag" data-parameter-name="R" data-is-type-parameter="data-is-type-parameter">the result type of the reduction operation</div>
          <div data-type="tag">1.8</div>
          <div data-type="method" data-name="supplier()">
            <div data-type="text">A function that creates and returns a new mutable result container.</div>
            <div data-type="tag">a function which returns a new, mutable result container</div>
          </div>
          <div data-type="method" data-name="accumulator()">
            <div data-type="text">A function that folds a value into a mutable result container.</div>
            <div data-type="tag">a function which folds a value into a mutable result container</div>
          </div>
          <div data-type="method" data-name="combiner()">
            <div data-type="text">A function that accepts two partial results and merges them.  The combiner function may fold state from one argument into the other and return that, or may return a new result container.</div>
            <div data-type="tag">a function which combines two partial results into a combined result</div>
          </div>
          <div data-type="method" data-name="finisher()">
            <div data-type="text">Perform the final transformation from the intermediate accumulation type {@code A} to the final result type  {@code R}. <p>If the characteristic  {@code IDENTITY_TRANSFORM} is set, this function may be presumed to be an identity transform with an unchecked cast from  {@code A} to  {@code R}.</p></div>
            <div data-type="tag">a function which transforms the intermediate result to the final result</div>
          </div>
          <div data-type="method" data-name="characteristics()">
            <div data-type="text">Returns a  {@code Set} of  {@code Collector.Characteristics} indicating the characteristics of this Collector.  This set should be immutable.</div>
            <div data-type="tag">an immutable set of collector characteristics</div>
          </div>
          <div data-type="method" data-name="of(java.util.function.Supplier&lt;R&gt;, java.util.function.BiConsumer&lt;R, T&gt;, java.util.function.BinaryOperator&lt;R&gt;, java.util.stream.Collector.Characteristics...)">
            <div data-type="text">Returns a new  {@code Collector} described by the given  {@code supplier}, {@code accumulator}, and  {@code combiner} functions.  The resulting {@code Collector} has the  {@code Collector.Characteristics.IDENTITY_FINISH} characteristic.</div>
            <div data-type="tag" data-parameter-name="supplier">The supplier function for the new collector</div>
            <div data-type="tag" data-parameter-name="accumulator">The accumulator function for the new collector</div>
            <div data-type="tag" data-parameter-name="combiner">The combiner function for the new collector</div>
            <div data-type="tag" data-parameter-name="characteristics">The collector characteristics for the new collector</div>
            <div data-type="tag" data-parameter-name="T" data-is-type-parameter="data-is-type-parameter">The type of input elements for the new collector</div>
            <div data-type="tag" data-parameter-name="R" data-is-type-parameter="data-is-type-parameter">The type of intermediate accumulation result, and final result, for the new collector</div>
            <div data-type="tag" data-exception-name="NullPointerException">if any argument is null</div>
            <div data-type="tag">the new  {@code Collector}</div>
          </div>
          <div data-type="method" data-name="of(java.util.function.Supplier&lt;A&gt;, java.util.function.BiConsumer&lt;A, T&gt;, java.util.function.BinaryOperator&lt;A&gt;, java.util.function.Function&lt;A, R&gt;, java.util.stream.Collector.Characteristics...)">
            <div data-type="text">Returns a new  {@code Collector} described by the given  {@code supplier}, {@code accumulator},  {@code combiner}, and  {@code finisher} functions.</div>
            <div data-type="tag" data-parameter-name="supplier">The supplier function for the new collector</div>
            <div data-type="tag" data-parameter-name="accumulator">The accumulator function for the new collector</div>
            <div data-type="tag" data-parameter-name="combiner">The combiner function for the new collector</div>
            <div data-type="tag" data-parameter-name="finisher">The finisher function for the new collector</div>
            <div data-type="tag" data-parameter-name="characteristics">The collector characteristics for the new collector</div>
            <div data-type="tag" data-parameter-name="T" data-is-type-parameter="data-is-type-parameter">The type of input elements for the new collector</div>
            <div data-type="tag" data-parameter-name="A" data-is-type-parameter="data-is-type-parameter">The intermediate accumulation type of the new collector</div>
            <div data-type="tag" data-parameter-name="R" data-is-type-parameter="data-is-type-parameter">The final result type of the new collector</div>
            <div data-type="tag" data-exception-name="NullPointerException">if any argument is null</div>
            <div data-type="tag">the new  {@code Collector}</div>
          </div>
        </div>
        <div data-type="class" data-name="java.util.stream.Collector.Characteristics">
          <div data-type="text">Characteristics indicating properties of a  {@code Collector}, which can be used to optimize reduction implementations.</div>
          <enumConstant xmlns="" name="CONCURRENT">
            <div xmlns="http://www.w3.org/1999/xhtml" data-type="text">Indicates that this collector is <em>concurrent</em>, meaning that the result container can support the accumulator function being called concurrently with the same result container from multiple threads. <p>If a  {@code CONCURRENT} collector is not also  {@code UNORDERED}, then it should only be evaluated concurrently if applied to an unordered data source.</p></div>
          </enumConstant>
          <enumConstant xmlns="" name="UNORDERED">
            <div xmlns="http://www.w3.org/1999/xhtml" data-type="text">Indicates that the collection operation does not commit to preserving the encounter order of input elements.  (This might be true if the result container has no intrinsic order, such as a  {@link Set}.)</div>
          </enumConstant>
          <enumConstant xmlns="" name="IDENTITY_FINISH">
            <div xmlns="http://www.w3.org/1999/xhtml" data-type="text">Indicates that the finisher function is the identity function and can be elided.  If set, it must be the case that an unchecked cast from A to R will succeed.</div>
          </enumConstant>
        </div>
        <div data-type="class" data-name="java.util.stream.BaseStream">
          <div data-type="text">Base interface for streams, which are sequences of elements supporting sequential and parallel aggregate operations.  The following example illustrates an aggregate operation using the stream types  {@link Stream} and  {@link IntStream}, computing the sum of the weights of the red widgets: <pre> {@code
    int sum = widgets.stream()
                     .filter(w -&gt; w.getColor() == RED)
                     .mapToInt(w -&gt; w.getWeight())
                     .sum();
}</pre> See the class documentation for  {@link Stream} and the package documentation for <a href="package-summary.html">java.util.stream</a> for additional specification of streams, stream operations, stream pipelines, and parallelism, which governs the behavior of all stream types.</div>
          <div data-type="tag" data-parameter-name="T" data-is-type-parameter="data-is-type-parameter">the type of the stream elements</div>
          <div data-type="tag" data-parameter-name="S" data-is-type-parameter="data-is-type-parameter">the type of of the stream implementing  {@code BaseStream}</div>
          <div data-type="tag">1.8</div>
          <div data-type="tag">Stream</div>
          <div data-type="tag">IntStream</div>
          <div data-type="tag">LongStream</div>
          <div data-type="tag">DoubleStream</div>
          <div data-type="tag">
            <a href="package-summary.html">java.util.stream</a>
          </div>
          <div data-type="method" data-name="iterator()">
            <div data-type="text">Returns an iterator for the elements of this stream. <p>This is a <a href="package-summary.html#StreamOps">terminal operation</a>.</p></div>
            <div data-type="tag">the element iterator for this stream</div>
          </div>
          <div data-type="method" data-name="spliterator()">
            <div data-type="text">Returns a spliterator for the elements of this stream. <p>This is a <a href="package-summary.html#StreamOps">terminal operation</a>.</p></div>
            <div data-type="tag">the element spliterator for this stream</div>
          </div>
          <div data-type="method" data-name="isParallel()">
            <div data-type="text">Returns whether this stream, if a terminal operation were to be executed, would execute in parallel.  Calling this method after invoking an terminal stream operation method may yield unpredictable results.</div>
            <div data-type="tag"> {@code true} if this stream would execute in parallel if executed</div>
          </div>
          <div data-type="method" data-name="sequential()">
            <div data-type="text">Returns an equivalent stream that is sequential.  May return itself, either because the stream was already sequential, or because the underlying stream state was modified to be sequential. <p>This is an <a href="package-summary.html#StreamOps">intermediate operation</a>.</p></div>
            <div data-type="tag">a sequential stream</div>
          </div>
          <div data-type="method" data-name="parallel()">
            <div data-type="text">Returns an equivalent stream that is parallel.  May return itself, either because the stream was already parallel, or because the underlying stream state was modified to be parallel. <p>This is an <a href="package-summary.html#StreamOps">intermediate operation</a>.</p></div>
            <div data-type="tag">a parallel stream</div>
          </div>
          <div data-type="method" data-name="unordered()">
            <div data-type="text">Returns an equivalent stream that is <a href="package-summary.html#Ordering">unordered</a>.  May return itself, either because the stream was already unordered, or because the underlying stream state was modified to be unordered. <p>This is an <a href="package-summary.html#StreamOps">intermediate operation</a>.</p></div>
            <div data-type="tag">an unordered stream</div>
          </div>
          <div data-type="method" data-name="onClose(java.lang.Runnable)">
            <div data-type="text">Returns an equivalent stream with an additional close handler.  Close handlers are run when the  {@link #close()} method is called on the stream, and are executed in the order they were added.  All close handlers are run, even if earlier close handlers throw exceptions.  If any close handler throws an exception, the first exception thrown will be relayed to the caller of  {@code close()}, with any remaining exceptions added to that exception as suppressed exceptions (unless one of the remaining exceptions is the same exception as the first exception, since an exception cannot suppress itself.)  May return itself. <p>This is an <a href="package-summary.html#StreamOps">intermediate operation</a>.</p></div>
            <div data-type="tag" data-parameter-name="closeHandler">A task to execute when the stream is closed</div>
            <div data-type="tag">a stream with a handler that is run if the stream is closed</div>
          </div>
          <div data-type="method" data-name="close()">
            <div data-type="text">Closes this stream, causing all close handlers for this stream pipeline to be called.</div>
            <div data-type="tag">AutoCloseable#close()</div>
          </div>
        </div>
      </div>
    </div>
  </body>
</html>
